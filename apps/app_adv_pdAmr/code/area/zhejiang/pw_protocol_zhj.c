/*
*********************************************************************
* Copyright(C) 2019 南京新联电子股份有限公司
* All rights reserved. 
* @brief： 功能描述
* @date： 2020-01-03
*********************************************************************
*/
#include "pw_redef.h"#include "pw_protocol.h"#include "pw_debug.h"#include "pw_common.h"#include "pw_lib.h" #include "pw_protocol_zhj.h" #include "pw_common_zhj.h"
/***************************************************************
***信号点表配置区
***************************************************************///变量保存私有文件名char *g_pFixedAreaPathZhj = {"/data/app/pdAmr/data/ZhjFixedIden"};  //定值区特性私有文件char *g_pParamValuePathZhj = {"/data/app/pdAmr/data/ZhjFixedPara"};  //定值参数私有文件//历史冻结数据私有文件名char *g_pFrozenValuePathZhj = {"/data/app/pdAmr/data/ZhjFrozenValue"};  //不同任务对应的历史冻结数据
uint16 g_nPowerTerminal = 0;       //终端
uint16 g_nTransformer = 0;         //配电变压器
uint16 g_nSVG = 0;                 //SVG
uint16 g_nCapacitor = 0;           //智能电容器
uint16 g_nCommutationSwitch = 0;   //换相开关
uint16 g_nResidentMeter = 0;       //用户表
uint16 g_nChargingPile = 0;        //充电桩
uint16 g_nPhotovoltaic = 0;        //光伏
uint16 g_nResidualCurrent = 0;     //剩余电流动作保护器
uint16 g_nIntelligentSwitch = 0;   //智能开关
uint16 g_nLowVoltShunt = 0;        //智能低压分路监测设备
uint16 g_nLowVoltFault = 0;        //智能低压故障传感器
uint16 g_nMeaCtrlMeter = 0;        //多功能测控表
uint16 g_nStationMonitor = 0;      //站所环境监测终端
 uint16 g_aGroupCountZhj[MAX_EQUIP_TYPE_NUM] = {0};  //表示不同类型设备实际组数
uint16 g_aEquipCountZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM] = {{0}};  //表示不同类型设备实际数量

//遥信点表实际配置个数
uint16 g_nConfigYxNumZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM]; uint32 g_nTotalYxNumZhj = 0;//所有遥信点表数量之和

//遥测点表实际配置个数
uint16 g_nConfigYcNumZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM]; uint32 g_nTotalYcNumZhj = 0;//所有遥测点表数量之和

//参数点表实际配置个数
uint16 g_nConfigParaNumZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM]; uint32 g_nTotalParaNumZhj = 0;//所有参数点表数量之和
 //事件点表实际配置个数
uint16 g_nConfigFaultNumZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM]; uint32 g_nTotalFaultNumZhj = 0;//所有故障点表数量之和
//遥信点表配置
YX_DATA_CONFIG_ZHJ g_aYxDataConfigZhj[MAX_YX_NUM_ZHJ];    //遥信信号配置区
YX_DATA_SEND   g_aYxDataSendZhj[MAX_YX_NUM_ZHJ];  //遥信信号存储区
uint32         g_aYxDataIndexZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];  //信号索引
//遥测点表配置
YC_DATA_CONFIG_ZHJ g_aYcDataConfigZhj[MAX_YC_NUM_ZHJ];  //遥测数据配置区
YC_DATA_SEND   g_aYcDataSendZhj[MAX_YC_NUM_ZHJ];  //遥测数据存储区 uint32         g_aYcDataIndexZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];  //信号索引 uint32         g_nYcStatVoltDay = 0;  //日电压监测统计起始点 uint32         g_nYcStatHarmonyDay = 0;  //日电压谐波统计起始点 uint32         g_nYcStatVoltUnbalanceDay = 0;  //日电压不平衡度统计起始点 uint32         g_nYcVoltUnbalance = 0;  //电压不平衡度实时值起始点 uint32         g_nYcStatCurrUnbalanceDay = 0;  //日电流不平衡度统计起始点 uint32         g_nYcStatFrequencyDay = 0;  //日频率统计起始点 uint32         g_nYcStatExtremeDay = 0; //极值统计起始点 uint32         g_nYcStatPwrFactDay = 0; //功率因数统计起始点 //事件点表配置
FAULT_REPORT_CONFIG_ZHJ g_aFaultDataConfigZhj[FAULT_MAX_NUM_ZHJ];  //故障信息配置区 uint32         g_aFaultDataIndexZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];  //信号索引//定值区号与变化标志uint16 g_nFixedAreaIdZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];    //定值区号uint8 g_bFixedChangeFlagZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_FIXED_AREA_NUM];    //定值参数改变标志，需要同步至数据中心//定值区特征标识结构体参数配置uint16 g_aFixedAreaNumZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//定值区数量FIXED_AREA_IDEN_ZHJ g_aFixedValueAreaZhj[MAX_AREA_NUM_ZHJ][IDEN_MAX_NUM_ZHJ];//定值区特征标识uint32 g_aFixedAreaIndexZhj[MAX_AREA_NUM_ZHJ][MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//信号索引//定值参数配置PARA_SET_VALUE_ZHJ g_aParaValueInitZhj[PARA_MAX_NUM_ZHJ];//点表参数uint32             g_aParaValueIndexZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//信号索引PARA_SET_VALUE_ZHJ g_aParaSetValueZhj[MAX_AREA_NUM_ZHJ][PARA_MAX_NUM_ZHJ];//私有文件保存参数//写定值参数时解析的公共地址uint16 g_nFixedValuePubAddrZhj = 0;   //写定值参数的公共地址	uint8 g_aFixedValueStateZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//参数固化标志uint8  g_nParaFixedFlagZhj[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_FIXED_AREA_NUM];//参数固化标志//终端上报任务配置REPORT_TASK_CONFIG_ZHJ g_aReportTaskConfig[TASK_MAX_NUM_ZHJ];//配置REPORT_TASK_DATA_ZHJ   g_aReportTaskData[TASK_MAX_NUM_ZHJ];//单周期或单实时冻结数据uint32                 g_aReportTaskIndex[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//信号索引uint16                 g_aReportTaskNum[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//单设备任务数量//终端上报任务的公共地址(统计共有几种不同的公共地址)uint16 g_aReportTaskPubAddrNum[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];uint16 g_aReportTaskPubAddr[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM][MAX_INFO_ITEM_NUM];uint8 g_aReportTaskPubAddrState[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM][MAX_INFO_ITEM_NUM];    //冻结数据存储(历史数据)uint16 g_aHisFrozenDataNum[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//数量//设备档案集合(默认一个设备只对应一个档案)OOP_METER_FILE_ZHJ g_aAllEquipFiles[FILE_MAX_NUM_ZHJ];uint32             g_aEquipFilesIndex[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//信号索引//普通采集方案记录列选择汇总uint16 g_aSchemeColOADNum[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM];//关联OAD的具体个数uint32 g_aSchemeColOAD[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_YC_NUM];//最多情况为每个遥测项对应一个oad//总召唤附带的公共地址(设备类型+设备序号)	uint16 g_nAllCallPubAddrZhj = 0;   //总召唤附带的公共地址(设备类型+设备序号)	//总召唤设备类型与设备组号、设备编号uint8 g_aZeroNull[MAX_EQUIP_COUNT_NUM] = {0};uint8 g_aAllCallEquipState[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];uint8 g_aAllCallEquipStateYX[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥信uint8 g_aAllCallEquipStateYC_R[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型)uint8 g_aAllCallEquipStateYC_R_T[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型 带时标)uint8 g_aAllCallEquipStateYC_STR[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(字符串)//电量召唤附带的公共地址(设备类型+设备组号+设备序号)	uint16 g_nEnergyCallPubAddrZhj = 0;   //总召唤附带的公共地址(设备类型+设备组号+设备序号)	uint8 g_aEnergyCallEquipState[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//点召唤附带的公共地址(设备类型+设备组号+设备序号)	uint16 g_nPointCallPubAddrZhj = 0;   //点召唤附带的公共地址(设备类型+设备组号+设备序号)uint8 g_nPointCallInfoAddrNum = 0;//点召唤地址数量uint32 g_aPointCallInfoAddr[MAX_POINT_CALL_NUM] = {0};//点召唤地址备份uint8 g_aPointCallEquipState[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];uint8 g_aPointCallEquipStateYX[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥信uint8 g_aPointCallEquipStateYC_R[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型)uint8 g_aPointCallEquipStateYC_R_T[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型 带时标)uint8 g_aPointCallEquipStateYC_R_EN[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型 电量)uint8 g_aPointCallEquipStateYC_STR[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(字符串)//任务召唤设备类型与设备编号uint16 g_nTaskCallPubAddrZhj = 0;   //任务召唤附带的公共地址(设备类型+设备组号+设备序号)TASK_CALL_CONFIG_ZHJ g_stTaskCallConfig = {0};//任务召唤的起止时间uint8 g_aTaskCallEquipState[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];uint8 g_aTaskCallEquipStateYX[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//未使用uint8 g_aTaskCallEquipStateYC_R[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//未使用uint8 g_aTaskCallEquipStateYC_STR[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//未使用uint8 g_aTaskCallPubAddrState[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM][MAX_INFO_ITEM_NUM];//数据变化主动上报设备类型与设备编号uint8 g_aChangedEquipStateYX[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥信uint8 g_aChangedEquipStateYC_R[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型)uint8 g_aChangedEquipStateYC_R_T[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型 带时标)uint8 g_aChangedEquipStateYC_R_EN[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(浮点型 电量)uint8 g_aChangedEquipStateYC_STR[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//遥测(字符串)//任务上报设备类型与设备编号uint8 g_aReportTaskState[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];uint8 g_aReportTaskStateYX[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//未使用uint8 g_aReportTaskStateYC_R[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//未使用uint8 g_aReportTaskStateYC_STR[MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM][MAX_REPORT_TASK_NUM];//未使用//所有参数召唤附带的公共地址(设备类型+设备组号+设备序号)	uint16 g_nAllParaCallPubAddrZhj = 0;   //所有参数召唤附带的公共地址(设备类型+设备组号+设备序号)	uint16 g_nAllParaCallAreaIdZhj = 0;   //所有参数召唤定值区号uint8 g_aAllParaEquipState[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//部分参数召唤附带的公共地址(设备类型+设备组号+设备序号)	uint16 g_nSomeParaCallPubAddrZhj = 0;   //部分参数召唤附带的公共地址(设备类型+设备组号+设备序号)uint16 g_nSomeParaCallAreaIdZhj = 0;   //部分参数召唤定值区号uint8 g_nSomeParaCallInfoAddrNum = 0;//部分参数召唤地址数量uint32 g_aSomeParaCallInfoAddr[MAX_PARA_CALL_NUM] = {0};//部分参数召唤地址备份uint8 g_aSomeParaCallEquipState[MAX_EQUIP_TYPE_NUM][MAX_EQUIP_GROUP_NUM][MAX_EQUIP_COUNT_NUM];//时钟同步公共地址(设备类型+设备组号+设备序号)	uint16 g_nTimeSynPubAddrZhj = 0;   //时钟同步附带的公共地址(设备类型+设备组号+设备序号)//104任务执行流程全局变量(周期冻结与上报专用)TASK_RUN_STEP_T g_sTimingTaskRunStep = {0};/******************************************************************************** 函数名称: get_next_equip_attr_zhj* 函数功能: 查找下一个设备类型、组别、序号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_equip_attr_zhj(uint16 curTyIndex, uint16 curGrIndex, uint16 curSeqIndex, uint16 *nexTyIndex, uint16 *nexGrIndex, uint16 *nexSeqIndex){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = curTyIndex;    uint16 nowEqGroupIndex = curGrIndex;    uint16 nowEqNoIndex = curSeqIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)        {            for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)            {                if((i!=curTyIndex) || (z!=curGrIndex) || (j!=curSeqIndex))                {                    *nexTyIndex = i;                    *nexGrIndex = z;                    *nexSeqIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }                nowEqGroupIndex = 0;    }    return -1;}/*********************************************************************
 功能描述：普通采集方案记录列选择初始化(弃用)
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int scheme_coload_init_zhj(){    int index = 0;    int equipType = 0;    int equipGroup = 0;        //智能电容器 4    index = 0;    equipType = E_EQUIP_CAPACITOR;    equipGroup = 0;//组号从0开始    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x2A000200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x260A0200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20000200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20010200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20040200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20050200;    //剩余电流动作保护器 9    index = 0;    equipType = E_EQUIP_RESIDUALCURRENT;    equipGroup = 0;//组号从0开始    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20000200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20010200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20040200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x200A0200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x200F0200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x20010500;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x00100200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x00200200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x00300200;    g_aSchemeColOAD[equipType-1][equipGroup][index++] = 0x00400200;    return 1;}/******************************************************************************** 函数名称: query_yx_type_config_zhj* 函数功能: 查询遥信类型* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yx_type_config_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -2;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -3;    }        int i = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYxDataIndexZhj[eqtypeIndex][eqgroupIndex][eqnoIndex];    for(i=0; i<g_nConfigYxNumZhj[eqtypeIndex][eqgroupIndex][eqnoIndex]; i++)    {        if(InfoAddr == g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            return g_aYxDataConfigZhj[ArrIdx+i].nSignalType;        }    }    return -4;}/******************************************************************************** 函数名称: query_yx_index_config_zhj* 函数功能: 根据信息体地址查询点表数组索引* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yx_index_config_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -1;    }        int i = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYxDataIndexZhj[eqtypeIndex][eqgroupIndex][eqnoIndex];    for(i=0; i<g_nConfigYxNumZhj[eqtypeIndex][eqgroupIndex][eqnoIndex]; i++)    {        if(InfoAddr == g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            return i;        }    }    return -1;}/******************************************************************************** 函数名称: query_yc_type_config_zhj* 函数功能: 查询遥测类型* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yc_type_config_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -2;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -3;    }        int i = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqtypeIndex][eqgroupIndex][eqnoIndex];    for(i=0; i<g_nConfigYcNumZhj[eqtypeIndex][eqgroupIndex][eqnoIndex]; i++)    {        if(InfoAddr == g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            return g_aYcDataConfigZhj[ArrIdx+i].nSignalType;        }    }    return -4;}/******************************************************************************** 函数名称: query_yc_index_config_zhj* 函数功能: 根据信息体地址查询点表数组索引* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yc_index_config_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -1;    }        int i = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqtypeIndex][eqgroupIndex][eqnoIndex];    for(i=0; i<g_nConfigYcNumZhj[eqtypeIndex][eqgroupIndex][eqnoIndex]; i++)    {        if(InfoAddr == g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            return i;        }    }    return -1;}/******************************************************************************** 函数名称: query_para_index_config_zhj* 函数功能: 根据信息体地址查询点表数组索引* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_para_index_config_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint16 areaIndex, uint32 InfoAddr){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -1;    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aParaValueIndexZhj[eqtypeIndex][eqgroupIndex][eqnoIndex];        int i = 0;    for(i=0; i<g_nConfigParaNumZhj[eqtypeIndex][eqgroupIndex][eqnoIndex]; i++)    {        if(InfoAddr == g_aParaSetValueZhj[areaIndex][ArrIdx+i].nObjAddrU32)        {            return i;        }    }    return -1;}/******************************************************************************** 函数名称: task_pubaddr_statistics_zhj* 函数功能: 上报任务中的公共地址统计* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int task_pubaddr_statistics_zhj(uint16 eqgroupIndex, uint16 eqnoIndex, uint16 taskIndex, uint16 PubAddr){    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -1;    }    //判断任务序号是否合法    if(taskIndex >= MAX_REPORT_TASK_NUM)    {        return -1;    }        BOOL bExisted = FALSE;//该公共地址是否已经存在    int i = 0;    uint16 count = g_aReportTaskPubAddrNum[eqgroupIndex][eqnoIndex][taskIndex];//当前已有数量        for(i=0; i<count; i++)    {        if(PubAddr == g_aReportTaskPubAddr[eqgroupIndex][eqnoIndex][taskIndex][i])        {            bExisted = TRUE;            break;        }    }    if(bExisted)    {        return -1;    }    else    {        if(g_aReportTaskPubAddrNum[eqgroupIndex][eqnoIndex][taskIndex] >= MAX_INFO_ITEM_NUM)        {            return -1;        }        else        {            g_aReportTaskPubAddr[eqgroupIndex][eqnoIndex][taskIndex][count] = PubAddr;            g_aReportTaskPubAddrNum[eqgroupIndex][eqnoIndex][taskIndex] += 1;        }    }    return 1;}/*********************************************************************
 功能描述：根据点表内容生成上报任务
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int timing_task_create_zhj(){    int z = 0;//设备组号    int i = 0;//设备编号    int j = 0;//点表序号    int k = 0;//信息元素序号    int count = 0;//任务累计数量    int index = 0;//偏移量    uint64 nReportLabel = 0;    int y = 0;//任务中不同的公共地址统计索引    uint16 nAreaID = 0;//定值区号    uint16 nPubAddr = 0;  //设备公共地址(原始任务配置)    uint16 equipType = 0;//设备类型 从1开始(原始任务配置)    uint16 equipGroup = 0;//设备组号 从0开始(原始任务配置)    uint16 equipNo = 0;//组内偏移地址 从1开始(原始任务配置)	uint32 nInfoAddr = 0;  //信息体地址    uint16 m = 0;//累计信息体个数(当组别为7或设备序号为255时)    int xx = 0;//设备组号    int yy = 0;//设备编号    uint32 nRealPubAddr = 0;  //公共地址    uint16 nRealEquipType = 0;//设备类型 从1开始(处理之后)    uint16 nRealEquipGroup = 0;//设备组号 从0开始(处理之后)    uint16 nRealEquipNo = 0;//组内偏移地址 从1开始(处理之后)    int ret = -1;    uint32 ArrIdx = 0;//一维数组索引(起始)    uint32 TaskArrIdx = 0;//一维数组索引(起始)    FRAME104_FMT_DEBUG("**timing_task_create_zhj() 根据点表生成周期冻结与上报任务开始** \n", count);    memset(g_aReportTaskPubAddrNum, 0x00, sizeof(g_aReportTaskPubAddrNum));    memset(g_aReportTaskPubAddr, 0x00, sizeof(g_aReportTaskPubAddr));        for(z=0; z<g_aGroupCountZhj[E_EQUIP_POWERTERMINAL-1]; z++)//组别    {        for(i=0; i<g_aEquipCountZhj[E_EQUIP_POWERTERMINAL-1][z]; i++)//组内偏移地址        {            nAreaID = g_nFixedAreaIdZhj[E_EQUIP_POWERTERMINAL-1][z][i];            ArrIdx = g_aParaValueIndexZhj[E_EQUIP_POWERTERMINAL-1][z][i];//一维数组索引(起始)            FRAME104_FMT_DEBUG("终端 组别下标z=%d, 序号下标i=%d, 定值区号=%d, 一维索引(定值参数)=%u 开始... \n", z, i, nAreaID, ArrIdx);            TaskArrIdx += count;//计算当前终端事件起始索引            g_aReportTaskIndex[z][i] = TaskArrIdx;//记录当前终端事件起始索引            FRAME104_FMT_DEBUG("记录一维索引(配置任务)=%u \n", g_aReportTaskIndex[z][i]);            count = 0;            nReportLabel = 0;            for(j=0; j<g_nConfigParaNumZhj[E_EQUIP_POWERTERMINAL-1][z][i]; j++)            {                if(g_aParaSetValueZhj[nAreaID][ArrIdx+j].nObjAddrU32 == 0x0000806C)//任务有效标识                {                    memcpy(&nReportLabel, g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue, 8);                    break;                }            }                        for(j=0; j<g_nConfigParaNumZhj[E_EQUIP_POWERTERMINAL-1][z][i]; j++)            {                if(g_aParaSetValueZhj[nAreaID][ArrIdx+j].nObjAddrU32 < 0x00008041)                {                    continue;                }                else if(g_aParaSetValueZhj[nAreaID][ArrIdx+j].nObjAddrU32 > 0x0000806B)                {                    break;                }                else                {                    FRAME104_FMT_DEBUG("----终端 组别z=%d, 序号i=%d, 任务count=%d, 详细信息---- \n", z, i, count);                    //单个任务上报信息体数量清零                    m = 0;                                        //默认所有参数配置正确                    g_aReportTaskConfig[TaskArrIdx+count].bIsCorrect = 1;                                        index = 0;                    g_aReportTaskConfig[TaskArrIdx+count].nTaskNo = count + 1;//任务号 从1开始                    memcpy(g_aReportTaskConfig[TaskArrIdx+count].aFrozenBaseTime, &g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index], 7);//冻结基准时间                    cp56time2a_to_ooptm(g_aReportTaskConfig[TaskArrIdx+count].aFrozenBaseTime, &g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime);                    ooptm_to_systm(g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime, &g_aReportTaskConfig[TaskArrIdx+count].tFrozenBaseTime);                    index += 7;                    g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodValue = g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index];//冻结周期 数值                    index += 1;                    g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodUnit = g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index];//冻结周期 单位                    index += 1;                    if(0 == g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodValue)                    {                        //冻结周期为0 表示上送实时数据                        g_aReportTaskConfig[TaskArrIdx+count].nReportDataType = TASK_DATA_REALTIME;                    }                    else if( (g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodUnit >= 2)                        && (g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodUnit <= 5) )                    {                        //冻结周期单位限于 0x02 分; 0x03 小时; 0x04 日; 0x05 月;                        g_aReportTaskConfig[TaskArrIdx+count].nReportDataType = TASK_DATA_FROZEN;                    }                    else                    {                        //参数配置错误                        g_aReportTaskConfig[TaskArrIdx+count].nReportDataType = TASK_DATA_NULL;                        g_aReportTaskConfig[TaskArrIdx+count].bIsCorrect = 0;                        FRAME104_FMT_DEBUG("冻结周期单位配置错误! \n");                    }                    memcpy(g_aReportTaskConfig[TaskArrIdx+count].aReportBaseTime, &g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index], 7);//上送基准时间                    cp56time2a_to_ooptm(g_aReportTaskConfig[TaskArrIdx+count].aReportBaseTime, &g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime);                    ooptm_to_systm(g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime, &g_aReportTaskConfig[TaskArrIdx+count].tReportBaseTime);                    index += 7;                    g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodValue = g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index];//上送周期                    index += 1;                    if(0 == g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodValue)                    {                        //上送周期不可为0                        g_aReportTaskConfig[TaskArrIdx+count].bIsCorrect = 0;                        FRAME104_FMT_DEBUG("上送周期数值配置错误! \n");                    }                    g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodUnit = g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index];//上送周期 单位                    index += 1;                    if( (g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodUnit >= 2)                        && (g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodUnit <= 5) )                    {                        //上送周期单位限于 0x02 分; 0x03 小时; 0x04 日; 0x05 月;                    }                    else                    {                        //参数配置错误                        g_aReportTaskConfig[TaskArrIdx+count].bIsCorrect = 0;                        FRAME104_FMT_DEBUG("上送周期单位配置错误! \n");                    }                    g_aReportTaskConfig[TaskArrIdx+count].nSelectRatio = g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index];//数据抽取倍率                    index += 1;                    g_aReportTaskConfig[TaskArrIdx+count].nInfoItemNum = g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index];//信息元素数量                    index += 1;                    FRAME104_FMT_DEBUG("冻结基准时间 %d-%d-%d %d:%d:%d, 冻结周期 %d, 周期单位 %d \n", g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime.year, g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime.month,                         g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime.day, g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime.hour, g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime.minute,                         g_aReportTaskConfig[TaskArrIdx+count].stFrozenBaseTime.second, g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodValue, g_aReportTaskConfig[TaskArrIdx+count].nFrozenPeriodUnit);                    FRAME104_FMT_DEBUG("上报基准时间 %d-%d-%d %d:%d:%d, 上报周期 %d, 周期单位:%d \n", g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime.year, g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime.month,                         g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime.day, g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime.hour, g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime.minute,                         g_aReportTaskConfig[TaskArrIdx+count].stReportBaseTime.second, g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodValue, g_aReportTaskConfig[TaskArrIdx+count].nReportPeriodUnit);                    FRAME104_FMT_DEBUG("上送数据类型:%d(0未知,1实时,2冻结), 数据抽取倍率 %d, 信息元素数量 %d \n", g_aReportTaskConfig[TaskArrIdx+count].nReportDataType, g_aReportTaskConfig[TaskArrIdx+count].nSelectRatio,                         g_aReportTaskConfig[TaskArrIdx+count].nInfoItemNum);                                        for(k=0; k<g_aReportTaskConfig[TaskArrIdx+count].nInfoItemNum; k++)                    {                        //假设每个任务只针对单一设备类型                        memcpy(&nPubAddr, &g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index], 2);//公共地址                        equipType = (nPubAddr >> 11) & 0x1f;  //设备类型(原始任务配置)	                    equipGroup = (nPubAddr >> 8) & 0x07;  //设备组别(原始任务配置)	                    equipNo = nPubAddr & 0xff;  //设备序号(原始任务配置)                        index += 2;                                                memcpy(&nInfoAddr, &g_aParaSetValueZhj[nAreaID][ArrIdx+j].aArrValue[index], 3);//信息体地址                        index += 3;                        FRAME104_FMT_DEBUG("原始配置 第%d个元素: 公共地址 %04x, nEquipType=%d, nEquipGroup=%d, nEquipNo=%d, 信息体地址 %08x \n", k, nPubAddr, equipType,                             equipGroup, equipNo, nInfoAddr);                                                if(0x07 == equipGroup)//所有组别                        {                            if(0xff == equipNo)//所有设备                            {                                for(xx=0; xx<g_aGroupCountZhj[equipType-1]; xx++)                                {                                    for(yy=0; yy<g_aEquipCountZhj[equipType-1][xx]; yy++)                                    {                                        nRealEquipType = equipType;//设备类型 从1开始(处理之后)                                        nRealEquipGroup = xx;//设备组号 从0开始(处理之后)                                        nRealEquipNo = yy + 1;//组内偏移地址 从1开始(处理之后)                                        nRealPubAddr = (uint16)((uint16)(nRealEquipType) << 11) + (uint16)((uint16)(nRealEquipGroup) << 8) + (nRealEquipNo);                                                                            memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], &nRealPubAddr, 2);//公共地址                                        task_pubaddr_statistics_zhj(z, i, count, nRealPubAddr);                                        g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m] = nRealEquipType;                                        g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m] = nRealEquipGroup;                                        g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m] = nRealEquipNo;                                                                                memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], &nInfoAddr, 4);//信息体地址                                        ret = check_info_addr_type_zhj(g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                        FRAME104_FMT_DEBUG("check_info_addr_type_zhj() ret = %d \n", ret);                                        if(INFO_ADDR_TYPE_YX == ret)                                        {                                            ret = query_yx_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                                 g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                            if(ret < 0)                                            {                                                FRAME104_FMT_DEBUG("query_yx_type_config_zhj() 失败! ret = %d \n", ret);                                            }                                            else                                            {                                                g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                            }                                        }                                        else if(INFO_ADDR_TYPE_YC == ret)                                        {                                            ret = query_yc_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                                 g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                            if(ret < 0)                                            {                                                FRAME104_FMT_DEBUG("query_yc_type_config_zhj() 失败! ret = %d \n", ret);                                            }                                            else                                            {                                                g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                            }                                        }                                        FRAME104_FMT_DEBUG("实际 累计第%d个元素: 公共地址 %04x, aEquipType=%d, aEquipGroup=%d, aEquipNo=%d, 信息体地址 %08x, 数据标识=%d \n", m, g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m],                                             g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m], g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m]);                                        m++;                                    }                                }                            }                            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))                            {                                for(xx=0; xx<g_aGroupCountZhj[equipType-1]; xx++)                                {                                    nRealEquipType = equipType;//设备类型 从1开始(处理之后)                                    nRealEquipGroup = xx;//设备组号 从0开始(处理之后)                                    nRealEquipNo = equipNo;//组内偏移地址 从1开始(处理之后)                                    nRealPubAddr = (uint16)((uint16)(nRealEquipType) << 11) + (uint16)((uint16)(nRealEquipGroup) << 8) + (nRealEquipNo);                                                                        memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], &nRealPubAddr, 2);//公共地址                                    task_pubaddr_statistics_zhj(z, i, count, nRealPubAddr);                                    g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m] = nRealEquipType;                                    g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m] = nRealEquipGroup;                                    g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m] = nRealEquipNo;                                                                        memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], &nInfoAddr, 4);//信息体地址                                    ret = check_info_addr_type_zhj(g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                    FRAME104_FMT_DEBUG("check_info_addr_type_zhj() ret = %d \n", ret);                                    if(INFO_ADDR_TYPE_YX == ret)                                    {                                        ret = query_yx_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                             g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                        if(ret < 0)                                        {                                            FRAME104_FMT_DEBUG("query_yx_type_config_zhj() 失败! ret = %d \n", ret);                                        }                                        else                                        {                                            g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                        }                                    }                                    else if(INFO_ADDR_TYPE_YC == ret)                                    {                                        ret = query_yc_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                             g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                        if(ret < 0)                                        {                                            FRAME104_FMT_DEBUG("query_yc_type_config_zhj() 失败! ret = %d \n", ret);                                        }                                        else                                        {                                            g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                        }                                    }                                    FRAME104_FMT_DEBUG("实际 累计第%d个元素: 公共地址 %04x, aEquipType=%d, aEquipGroup=%d, aEquipNo=%d, 信息体地址 %08x, 数据标识=%d \n", m, g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m],                                         g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m], g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m]);                                    m++;                                }                            }                        }                        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别                        {                            if(0xff == equipNo)//所有设备                            {                                for(yy=0; yy<g_aEquipCountZhj[equipType-1][equipGroup]; yy++)                                {                                    nRealEquipType = equipType;//设备类型 从1开始(处理之后)                                    nRealEquipGroup = equipGroup;//设备组号 从0开始(处理之后)                                    nRealEquipNo = yy + 1;//组内偏移地址 从1开始(处理之后)                                    nRealPubAddr = (uint16)((uint16)(nRealEquipType) << 11) + (uint16)((uint16)(nRealEquipGroup) << 8) + (nRealEquipNo);                                                                        memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], &nRealPubAddr, 2);//公共地址                                    task_pubaddr_statistics_zhj(z, i, count, nRealPubAddr);                                    g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m] = nRealEquipType;                                    g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m] = nRealEquipGroup;                                    g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m] = nRealEquipNo;                                                                        memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], &nInfoAddr, 4);//信息体地址                                    ret = check_info_addr_type_zhj(g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                    FRAME104_FMT_DEBUG("check_info_addr_type_zhj() ret = %d \n", ret);                                    if(INFO_ADDR_TYPE_YX == ret)                                    {                                        ret = query_yx_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                             g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                        if(ret < 0)                                        {                                            FRAME104_FMT_DEBUG("query_yx_type_config_zhj() 失败! ret = %d \n", ret);                                        }                                        else                                        {                                            g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                        }                                    }                                    else if(INFO_ADDR_TYPE_YC == ret)                                    {                                        ret = query_yc_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                             g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                        if(ret < 0)                                        {                                            FRAME104_FMT_DEBUG("query_yc_type_config_zhj() 失败! ret = %d \n", ret);                                        }                                        else                                        {                                            g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                        }                                    }                                    FRAME104_FMT_DEBUG("实际 累计第%d个元素: 公共地址 %04x, aEquipType=%d, aEquipGroup=%d, aEquipNo=%d, 信息体地址 %08x, 数据标识=%d \n", m, g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m],                                         g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m], g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m]);                                    m++;                                }                            }                            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))                            {                                nRealEquipType = equipType;//设备类型 从1开始(处理之后)                                nRealEquipGroup = equipGroup;//设备组号 从0开始(处理之后)                                nRealEquipNo = equipNo;//组内偏移地址 从1开始(处理之后)                                nRealPubAddr = (uint16)((uint16)(nRealEquipType) << 11) + (uint16)((uint16)(nRealEquipGroup) << 8) + (nRealEquipNo);                                                                memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], &nRealPubAddr, 2);//公共地址                                task_pubaddr_statistics_zhj(z, i, count, nRealPubAddr);                                g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m] = nRealEquipType;                                g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m] = nRealEquipGroup;                                g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m] = nRealEquipNo;                                                                memcpy(&g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], &nInfoAddr, 4);//信息体地址                                ret = check_info_addr_type_zhj(g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                FRAME104_FMT_DEBUG("check_info_addr_type_zhj() ret = %d \n", ret);                                if(INFO_ADDR_TYPE_YX == ret)                                {                                    ret = query_yx_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                         g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                    if(ret < 0)                                    {                                        FRAME104_FMT_DEBUG("query_yx_type_config_zhj() 失败! ret = %d \n", ret);                                    }                                    else                                    {                                        g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                    }                                }                                else if(INFO_ADDR_TYPE_YC == ret)                                {                                    ret = query_yc_type_config_zhj(g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m]-1, g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m]-1,                                         g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m]);                                    if(ret < 0)                                    {                                        FRAME104_FMT_DEBUG("query_yc_type_config_zhj() 失败! ret = %d \n", ret);                                    }                                    else                                    {                                        g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m] = ret;                                    }                                }                                FRAME104_FMT_DEBUG("实际 累计第%d个元素: 公共地址 %04x, aEquipType=%d, aEquipGroup=%d, aEquipNo=%d, 信息体地址 %08x, 数据标识=%d \n", m, g_aReportTaskConfig[TaskArrIdx+count].aPublicAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipType[m],                                 g_aReportTaskConfig[TaskArrIdx+count].aEquipGroup[m], g_aReportTaskConfig[TaskArrIdx+count].aEquipNo[m], g_aReportTaskConfig[TaskArrIdx+count].aInfoItemAddr[m], g_aReportTaskConfig[TaskArrIdx+count].aSignalType[m]);                                m++;                            }                        }	                                            }                    g_aReportTaskConfig[TaskArrIdx+count].nRealInfoItemNum = m;//实际信息体个数                    if(0x80014101 == g_aParaSetValueZhj[nAreaID][ArrIdx+j].nDealType)//遥信                    {                        g_aReportTaskConfig[TaskArrIdx+count].nReportTaskType = REPORT_TASK_YX;                    }                    else if(0x80014102 == g_aParaSetValueZhj[nAreaID][ArrIdx+j].nDealType)//遥测                    {                        g_aReportTaskConfig[TaskArrIdx+count].nReportTaskType = REPORT_TASK_YC;                    }                    g_aReportTaskConfig[TaskArrIdx+count].bIsValid = (nReportLabel >> count) & 0x0000000000000001;//上报有效标志                    FRAME104_FMT_DEBUG("上报任务类型 %d(0未知 1遥信 2遥测), 上送状态标记 %d, 配置正确标志 %d, 实际信息体个数 %d \n",                         g_aReportTaskConfig[TaskArrIdx+count].nReportTaskType, g_aReportTaskConfig[TaskArrIdx+count].bIsValid, g_aReportTaskConfig[TaskArrIdx+count].bIsCorrect, g_aReportTaskConfig[TaskArrIdx+count].nRealInfoItemNum);                    FRAME104_FMT_DEBUG("该任务中共有%d个不同的公共地址, 分别为: \n", g_aReportTaskPubAddrNum[z][i][count]);                    for(y=0; y<g_aReportTaskPubAddrNum[z][i][count]; y++)                    {                        FRAME104_FMT_DEBUG("%04x \n", g_aReportTaskPubAddr[z][i][count][y]);                    }                    count++;                }            }            g_aReportTaskNum[z][i] = count;            FRAME104_FMT_DEBUG("终端 组别z=%d, 序号i=%d 结束, 周期冻结与上报任务共计 %d 个. \n", z, i, count);        }    }            FRAME104_FMT_DEBUG("**timing_task_create_zhj() 根据点表生成周期冻结与上报任务结束** \n", count);    return 1;}/******************************************************************************** 函数名称: scheme_coload_statistics_zhj* 函数功能: 外接设备采集方案关联OAD统计* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int scheme_coload_statistics_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint32 oad){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }        //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -1;    }        BOOL bExisted = FALSE;//该公共地址是否已经存在    int i = 0;    uint16 count = g_aSchemeColOADNum[eqtypeIndex][eqgroupIndex];//当前已有数量        for(i=0; i<count; i++)    {        if(oad == g_aSchemeColOAD[eqtypeIndex][eqgroupIndex][i])        {            bExisted = TRUE;            break;        }    }    if(bExisted)    {        return -1;    }    else    {        if( (g_aSchemeColOADNum[eqtypeIndex][eqgroupIndex] >= MAX_YC_NUM)             || (g_aSchemeColOADNum[eqtypeIndex][eqgroupIndex] >= OOP_MAX_CSDS))        {            return -1;        }        else        {            g_aSchemeColOAD[eqtypeIndex][eqgroupIndex][count] = oad;            g_aSchemeColOADNum[eqtypeIndex][eqgroupIndex] += 1;        }    }    return 1;}/*********************************************************************
 功能描述：根据点表内容生成设备需要采集的OAD存入数据中心
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int scheme_coload_save_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//设备序号    int k = 0;//点表序号    int ret = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)    FRAME104_FMT_DEBUG("****scheme_coload_save_zhj() 根据遥测点表生成采集方案关联OAD 开始**** \n");    for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)    {        //目前仅处理智能电容器和剩余电流保护器        if(((i+1) != E_EQUIP_CAPACITOR) && ((i+1) != E_EQUIP_RESIDUALCURRENT))        {            continue;        }        for(z=0; z<g_aGroupCountZhj[i]; z++)//组别        {            for(j=0; j<g_aEquipCountZhj[i][z]; j++)//组内偏移地址            {                ArrIdx = g_aYcDataIndexZhj[i][z][j];                for(k=0; k<g_nConfigYcNumZhj[i][z][j]; k++)//点表序号                {                    if( (g_aYcDataConfigZhj[ArrIdx+k].nOadColsNum == 0)                        || (g_aYcDataConfigZhj[ArrIdx+k].aOadCols[0] == 0) )                    {                        continue;                    }                    ret = scheme_coload_statistics_zhj(i, z, g_aYcDataConfigZhj[ArrIdx+k].aOadCols[0]);                    if(ret > 0)                    {                        FRAME104_FMT_DEBUG("类型=%d, 组别=%d, 新增方案OAD=0x%08x, 来自设备序号=%d, 点号=0x%08x, 当前OAD数量=%d \n",                             i+1, z, g_aYcDataConfigZhj[ArrIdx+k].aOadCols[0], j+1, g_aYcDataConfigZhj[ArrIdx+k].nObjAddrU32,                             g_aSchemeColOADNum[i][z]);                    }                }            }        }    }    FRAME104_FMT_DEBUG("****scheme_coload_save_zhj() 根据遥测点表生成采集方案关联OAD 结束**** \n");    return 1;}/*********************************************************************
 功能描述：根据点表内容生成设备档案
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int equip_files_create_zhj(uint16 equipType, uint16 equipGroup, uint16 equipNo, OOP_METER_T *newOopMeter){    int i = 0;    //int j = 0;    uint16 nIndex = 0;    uint32 factBoud = 0;//实际波特率    uint8 nBoud = 0;//698波特率代号    uint16 nAreaID = 0;//定值区号    uint32 ArrIdx = 0;//一维数组索引(起始)    nAreaID = g_nFixedAreaIdZhj[equipType-1][equipGroup][equipNo-1];    ArrIdx = g_aParaValueIndexZhj[equipType-1][equipGroup][equipNo-1];        /**< 配置序号	*/    nIndex = (uint16)((equipType << 11) & 0xf800) + (uint16)((equipGroup << 8) & 0x0700) + equipNo;    //最高位是否作为设备有效标志(?)    newOopMeter->nIndex = nIndex;    /**< 基本信息	*/    //表计地址    for(i=0; i<g_nConfigParaNumZhj[equipType-1][equipGroup][equipNo-1]; i++)    {        if(g_aParaSetValueZhj[nAreaID][ArrIdx+i].nObjAddrU32 == 0x00008003)        {            newOopMeter->basic.tsa.len = g_aParaSetValueZhj[nAreaID][ArrIdx+i].nArrLen -1;            memcpy(newOopMeter->basic.tsa.add, g_aParaSetValueZhj[nAreaID][ArrIdx+i].aArrValue,                 g_aParaSetValueZhj[nAreaID][ArrIdx+i].nArrLen);            break;        }    }    //波特率    for(i=0; i<g_nConfigParaNumZhj[equipType-1][equipGroup][equipNo-1]; i++)    {        if(g_aParaSetValueZhj[nAreaID][ArrIdx+i].nObjAddrU32 == 0x00008005)        {            factBoud = g_aParaSetValueZhj[nAreaID][ArrIdx+i].aArrValue[0]*300;            break;        }    }    switch(factBoud)    {        case 300:            nBoud = 0;            break;        case 600:            nBoud = 1;            break;        case 1200:            nBoud = 2;            break;        case 2400:            nBoud = 3;            break;        case 4800:            nBoud = 4;            break;        case 7200:            nBoud = 5;            break;        case 9600:            nBoud = 6;            break;        case 19200:            nBoud = 7;            break;        case 38400:            nBoud = 8;            break;        case 57600:            nBoud = 9;            break;        case 115200:            nBoud = 10;            break;        default:            nBoud = 255;            break;    }    newOopMeter->basic.baud = nBoud;    //规约类型    for(i=0; i<g_nConfigParaNumZhj[equipType-1][equipGroup][equipNo-1]; i++)    {        if(g_aParaSetValueZhj[nAreaID][ArrIdx+i].nObjAddrU32 == 0x00008006)        {            newOopMeter->basic.protocol  = g_aParaSetValueZhj[nAreaID][ArrIdx+i].nDefaultValueI64;            break;        }    }    //端口    uint8 nPort = 1;    for(i=0; i<g_nConfigParaNumZhj[equipType-1][equipGroup][equipNo-1]; i++)    {        if(g_aParaSetValueZhj[nAreaID][ArrIdx+i].nObjAddrU32 == 0x00008004)        {            if(g_aParaSetValueZhj[nAreaID][ArrIdx+i].nDefaultValueI64 > 0 &&                 g_aParaSetValueZhj[nAreaID][ArrIdx+i].nDefaultValueI64 < 5)            {                memcpy(&nPort, &g_aParaSetValueZhj[nAreaID][ArrIdx+i].aArrValue[0], 1);                newOopMeter->basic.port.value  = 0xf2010200 + nPort;                FRAME104_FMT_DEBUG("nPort=%d \n", nPort);            }            else            {                newOopMeter->basic.port.value  = 0xf2010201;            }                        break;        }    }    //通信密码    //费率个数    newOopMeter->basic.rateNum = 4;    //用户类型(设备类型)    newOopMeter->basic.userType = equipType;    //接线方式    newOopMeter->basic.pwrType = 3;//0未知 1单相 2 三相三线 3三相四线    //额定电压    newOopMeter->basic.stVolt = 2200;    //额定电流    newOopMeter->basic.stAmp = 50;    /**< 扩展信息	*/    /**< 附属信息	*/    return 1;}/************************************************************************ @brief：      清除指定电能表的数据* @param[in]： fd  数据中心句柄* @param[in]： oldMeter   老电表档案数据* @return：     =0, 成功 <0 失败**********************************************************************/int meter_data_clear_zhj(DB_CLIENT fd, uint16 infoNum){    int ret = ERR_OK;    CLEAR_DATA_T clear;    MEMZERO(&clear, sizeof(clear));    clear.recordOAD.logicId = 7;    clear.bClassTag = TRUE;    clear.recordOAD.infoNum = infoNum;    clear.recordOAD.classtag = CLASS_DATA_COLLEC;        ret = db_clear_oad_data(fd, &clear);    FRAME104_FMT_DEBUG("meter_data_clear_zhj() 清除所有档案 ret(%d), infoNum(%d or 0x%04x), classtag(%d)\n",         ret, clear.recordOAD.infoNum, clear.recordOAD.infoNum, clear.recordOAD.classtag);         return ret;}/*********************************************************************
 功能描述：根据点表内容生成设备档案存入数据中心
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int equip_files_save_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//设备序号    OOP_METER_T newOopMeter;    OOP_METER_T oldOopMeter;    NOMAL_OAD_T nomalOad = {0};    int ret = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)    FRAME104_FMT_DEBUG("****equip_files_save_zhj() 根据设备信息生成档案 开始**** \n");    for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)    {        //目前仅处理智能电容器和剩余电流保护器        if(((i+1) != E_EQUIP_CAPACITOR) && ((i+1) != E_EQUIP_RESIDUALCURRENT))        {            continue;        }        for(z=0; z<g_aGroupCountZhj[i]; z++)//组别        {            for(j=0; j<g_aEquipCountZhj[i][z]; j++)//组内偏移地址            {                memset(&newOopMeter, 0x00, sizeof(OOP_METER_T));                memset(&oldOopMeter, 0x00, sizeof(OOP_METER_T));                g_aEquipFilesIndex[i][z][j] = ArrIdx;                //组装新设备档案                equip_files_create_zhj(i+1, z, j+1, &newOopMeter);                g_aAllEquipFiles[ArrIdx].nEqType = i+1;                g_aAllEquipFiles[ArrIdx].nEqGroup = z;                g_aAllEquipFiles[ArrIdx].nEquipNo = j+1;                memcpy(&g_aAllEquipFiles[ArrIdx].stMeterFile, &newOopMeter, sizeof(OOP_METER_T));                FRAME104_FMT_DEBUG("----设备类型i=%d, 设备组别z=%d, 设备序号j=%d, 一维索引ArrIdx=%u, 档案信息----\n", i, z, j, ArrIdx);                FRAME104_FMT_DEBUG("档案: tsa.len=%d, tsa.add=%02x %02x %02x %02x %02x %02x, baud=%d, protocol=%d, port=%08x, userType=%d \n",                         newOopMeter.basic.tsa.len, newOopMeter.basic.tsa.add[0], newOopMeter.basic.tsa.add[1], newOopMeter.basic.tsa.add[2],                         newOopMeter.basic.tsa.add[3], newOopMeter.basic.tsa.add[4], newOopMeter.basic.tsa.add[5], newOopMeter.basic.baud,                         newOopMeter.basic.protocol, newOopMeter.basic.port.value, newOopMeter.basic.userType);                //清除该测量点号的旧档案                meter_data_clear_zhj(g_sDataCenterClient, newOopMeter.nIndex);                //将新档案存入数据中心                nomalOad.logicId = 7;                nomalOad.infoNum = newOopMeter.nIndex;                nomalOad.oad.value = 0x60000200;                nomalOad.classtag = CLASS_DATA_INIT;                ret = db_write_nomal(g_sDataCenterClient, &nomalOad, (uint8*)&newOopMeter, sizeof(OOP_METER_T));                FRAME104_FMT_DEBUG("保存档案至数据中心 db_write_nomal() i=%d, j=%d, ret(%d), logicId(%d), infoNum(%d or 0x%04x), oad(0x%08x)\n",                        i, j, ret, nomalOad.logicId, nomalOad.infoNum, nomalOad.infoNum, nomalOad.oad.value);                ArrIdx++;            }        }    }    FRAME104_FMT_DEBUG("****equip_files_save_zhj() 根据设备信息生成档案 结束**** \n");    return 1;}/*********************************************************************
 功能描述：清除所有普通采集方案
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int clear_all_scheme_zhj(DB_CLIENT fd){    int ret = 0;    CLEAR_DATA_T RecordDel;            MEMZERO(&RecordDel, sizeof(RecordDel));    //删除存储的临时数据    RecordDel.recordOAD.logicId = 7;    RecordDel.recordOAD.infoNum = 0xffff;    RecordDel.recordOAD.optional = 0;	RecordDel.recordOAD.classtag = CLASS_DATA_INIT;
    RecordDel.recordOAD.road.oadMain.value = 0;    RecordDel.recordOAD.road.oadCols.nNum = 1;    RecordDel.recordOAD.road.oadCols.oad[0].value = 0x60140200;    RecordDel.bClassTag = FALSE;    FRAME104_FMT_DEBUG("clear_all_scheme_zhj() 删除全部普通采集方案数据\n");    ret = db_clear_oad_data(fd, &RecordDel);    if(ret == 0)    {        FRAME104_FMT_DEBUG("clear_all_scheme_zhj() 删除全部普通采集方案成功！\n");    }else    {        FRAME104_FMT_DEBUG("clear_all_scheme_zhj() 删除全部普通采集方案失败！ret = %d\n", ret);    }    return 1;}/*********************************************************************
 功能描述：将事件采集方案存入数据中心
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int equip_event_scheme_save_zhj(uint8 nEqType, uint8 *pSchemeNo){    FRAME104_FMT_DEBUG("******equip_event_scheme_save_zhj() 事件采集方案 开始****** \n");    if(nEqType != E_EQUIP_RESIDUALCURRENT)//目前仅支持漏保事件采集    {        return -1;    }        int ret = 0;    NOMAL_OAD_T NormalOad;    OOP_PLAN_EVENT_T PlanEvent;    uint8 nSchemeNo = *pSchemeNo;//方案编号 从1开始    int index = 0;    int j = 0;    memset(&NormalOad, 0x00, sizeof(NOMAL_OAD_T));    memset(&PlanEvent, 0x00, sizeof(OOP_PLAN_EVENT_T));    NormalOad.logicId = 7;    NormalOad.infoNum = 0;    NormalOad.oad.value =0x60160200;//事件采集方案集    NormalOad.classtag = CLASS_DATA_INIT;    /**< 方案编号       */    PlanEvent.planID = (uint8)(nEqType<<3) + nSchemeNo;//设备类型+方案序号    NormalOad.infoNum = PlanEvent.planID;    /**< 上报标识 */    PlanEvent.bReport = 1;//TRUE 立即上报    /**< 存储深度       */    PlanEvent.nDepth = 255;    /**< 采集方式       */    //采集类型(采集内容为NULL)    PlanEvent.nType = 0x00;//周期采集事件数据    FRAME104_FMT_DEBUG("----设备类型nEqType=%d, 采集方案信息----\n", nEqType);    FRAME104_FMT_DEBUG("方案编号=%d(0x%02x), 上报标识=%d, 存储深度=%d, 采集方式=%d. \n",         PlanEvent.planID, PlanEvent.planID, PlanEvent.bReport, PlanEvent.nDepth, PlanEvent.nType);    /**< 记录列选择        */    PlanEvent.events.cols[index].oadMain.value = 0x31BB0200;    PlanEvent.events.cols[index].oadCols.oad[j++].value = 0x201F0800;    PlanEvent.events.cols[index].oadCols.nNum = j;    index++;    PlanEvent.events.nNum = index;//列OAD数量    FRAME104_FMT_DEBUG("PlanEvent.events.nNum=%d, cols[0].oadCols.nNum=%d \n",         PlanEvent.events.nNum, PlanEvent.events.cols[index].oadCols.nNum);    /**< 电表集合       */    PlanEvent.ms.choice = 2;//一组用户类型    PlanEvent.ms.mst.size = 1;//一组用户    PlanEvent.ms.mst.type[0] = nEqType;//设备类型    FRAME104_FMT_DEBUG("电表集合 ms.choice=%d, ms.mst.size=%d, PlanNormal.ms.mst.type[0]=%d \n",         PlanEvent.ms.choice, PlanEvent.ms.mst.size, PlanEvent.ms.mst.type[0]);    //将方案存入数据中心    ret = db_write_nomal(g_sDataCenterClient, &NormalOad, (uint8*)&PlanEvent, sizeof(OOP_PLAN_EVENT_T));    FRAME104_FMT_DEBUG("存储采集方案至数据中心 db_write_nomal(). ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",            ret, NormalOad.logicId, NormalOad.infoNum, NormalOad.oad.value);    //单类型方案编号累加    //*pSchemeNo ++;        FRAME104_FMT_DEBUG("******equip_event_scheme_save_zhj() 事件采集方案 结束****** \n");    return 1;}/*********************************************************************
 功能描述：根据点表内容生成采集方案存入数据中心
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int equip_scheme_save_zhj(){    FRAME104_FMT_DEBUG("******equip_scheme_save_zhj() 根据点表生成采集方案 开始****** \n");        int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//设备序号    int ret = 0;    NOMAL_OAD_T NormalOad;    OOP_PLAN_NORMAL_T PlanNormal;    uint8 nSchemeNo = 1;//方案编号 从1开始    memset(&NormalOad, 0x00, sizeof(NOMAL_OAD_T));    memset(&PlanNormal, 0x00, sizeof(OOP_PLAN_NORMAL_T));    NormalOad.logicId = 7;    NormalOad.infoNum = 0;    NormalOad.oad.value =0x60140200;    NormalOad.classtag = CLASS_DATA_INIT;    //首先清除所有普通采集方案    clear_all_scheme_zhj(g_sDataCenterClient);    for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)    {        nSchemeNo = 1;//方案编号 每种类型从1开始, 与类型组合                //目前仅处理智能电容器和剩余电流保护器        if(((i+1) != E_EQUIP_CAPACITOR) && ((i+1) != E_EQUIP_RESIDUALCURRENT))        {            continue;        }        z = 0;//第0组没有设备，则认为该类型没有设备        if(0 == g_aEquipCountZhj[i][z])        {            continue;        }        j = 0;        memset(&PlanNormal, 0x00, sizeof(OOP_PLAN_NORMAL_T));        /**< 方案编号		*/        PlanNormal.planID = i + 1;//设备类型        NormalOad.infoNum = PlanNormal.planID;        /**< 存储深度		*/        PlanNormal.memDepth = 255;        /**< 采集方式		*/        //采集类型(采集内容为NULL)        PlanNormal.recdRow.choice = 0x00;//采集当前数据        FRAME104_FMT_DEBUG("----设备类型i=%d, 采集方案信息----\n", i);        FRAME104_FMT_DEBUG("方案编号=%d, 存储深度=%d, 采集方式=%d. \n",             PlanNormal.planID, PlanNormal.memDepth, PlanNormal.recdRow.choice);        /**< 记录列选择		*/        while(j < MAX_YC_NUM)        {            if(0 == g_aSchemeColOAD[i][z][j])            {                break;            }            PlanNormal.recdCol.csd[j].choice = 0;//OAD            PlanNormal.recdCol.csd[j].oad.value = g_aSchemeColOAD[i][z][j];            FRAME104_FMT_DEBUG("记录列选择j=%d, csd[j].choice=%d, csd[j].oad=%08x \n",                 j, PlanNormal.recdCol.csd[j].choice, PlanNormal.recdCol.csd[j].oad.value);            j++;        }        PlanNormal.recdCol.num = j;//列OAD数量        /**< 电表集合		*/        PlanNormal.ms.choice = 2;//一组用户类型        PlanNormal.ms.mst.size = 1;//一组用户        PlanNormal.ms.mst.type[0] = i + 1;//设备类型        /**< 存储时标选择	*/        PlanNormal.tmFlag = 1;//任务开始时间        FRAME104_FMT_DEBUG("列OAD共计%d个, 电表集合 ms.choice=%d, ms.mst.size=%d, PlanNormal.ms.mst.type[0]=%d, 存储时标tmFlag=%d \n",             j, PlanNormal.ms.choice, PlanNormal.ms.mst.size, PlanNormal.ms.mst.type[0], PlanNormal.tmFlag);        //将方案存入数据中心        ret = db_write_nomal(g_sDataCenterClient, &NormalOad, (uint8*)&PlanNormal, sizeof(OOP_PLAN_NORMAL_T));        FRAME104_FMT_DEBUG("存储采集方案至数据中心 db_write_nomal(). ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",                ret, NormalOad.logicId, NormalOad.infoNum, NormalOad.oad.value);        if((i+1) == E_EQUIP_RESIDUALCURRENT)        {            //如果是漏保设备, 还需要添加事件采集方案            equip_event_scheme_save_zhj((i+1), &nSchemeNo);        }    }    FRAME104_FMT_DEBUG("******equip_scheme_save_zhj() 根据点表生成采集方案 结束****** \n");    return 1;}/*********************************************************************
 功能描述：清除所有普通采集任务
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int clear_all_task_zhj(DB_CLIENT fd){    int ret = 0;    CLEAR_DATA_T RecordDel;    MEMZERO(&RecordDel, sizeof(RecordDel));    //删除存储的临时数据    RecordDel.recordOAD.logicId = 7;    RecordDel.recordOAD.infoNum = 0xffff;//删除所有任务    RecordDel.recordOAD.classtag = CLASS_DATA_INIT;    RecordDel.recordOAD.road.oadMain.value = 0;    RecordDel.recordOAD.road.oadCols.nNum = 1;    RecordDel.recordOAD.road.oadCols.oad[0].value = 0x60120200;    RecordDel.bClassTag = FALSE;    ret = db_clear_oad_data(fd, &RecordDel);    if(ret == 0)    {        FRAME104_FMT_DEBUG("clear_all_task_zhj() infoNum = 0xffff 普通采集任务清除成功！\n");    }    else    {        FRAME104_FMT_DEBUG("clear_all_task_zhj() infoNum = 0xffff 普通采集任务清除失败！\n");    }    return 1;}/*********************************************************************
 功能描述：根据点表内容生成采集任务存入数据中心
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int equip_event_task_save_zhj(uint8 nEqType, uint8 *pTaskNo){    FRAME104_FMT_DEBUG("********equip_event_task_save_zhj() 事件采集任务开始********\n");    if(nEqType != E_EQUIP_RESIDUALCURRENT)//目前仅支持漏保事件采集    {        return -1;    }        int ret = 0;    NOMAL_OAD_T NormalOad;    OOP_TASK_T TaskNormal;    uint8 nTaskNo = *pTaskNo;//任务编号 从1开始    memset(&NormalOad, 0x00, sizeof(NOMAL_OAD_T));    memset(&TaskNormal, 0x00, sizeof(OOP_TASK_T));    NormalOad.logicId = 7;    NormalOad.infoNum = 0;    NormalOad.oad.value =0x60120200;    NormalOad.classtag = CLASS_DATA_INIT;    /**< 任务ID */    TaskNormal.id = (uint8)(nEqType<<3) + nTaskNo;//设备类型+任务序号    NormalOad.infoNum =TaskNormal.id;    /**< 执行频率 */    TaskNormal.acqFreq.unit = 1;//分钟    TaskNormal.acqFreq.value = 1;    /**< 方案类型 */    TaskNormal.planType = 2;//事件采集方案    /**< 方案编号 */    TaskNormal.planID = (uint8)(nEqType<<3) + nTaskNo;//设备类型+方案序号    /**< 开始时间(任务第一次开始执行时间)    */    TaskNormal.startTime.year = 2020;    TaskNormal.startTime.month = 1;    TaskNormal.startTime.day = 1;    TaskNormal.startTime.hour = 0;    TaskNormal.startTime.minute = 0;    TaskNormal.startTime.second = 0;        /**< 结束时间(可以为空) */    TaskNormal.endTime.year = 2099;    TaskNormal.endTime.month = 1;    TaskNormal.endTime.day = 1;    TaskNormal.endTime.hour = 0;    TaskNormal.endTime.minute = 0;    TaskNormal.endTime.second = 0;    /**< 延时 */    TaskNormal.acqDelay.unit = 1;//分钟    TaskNormal.acqDelay.value = 0;    /**< 执行优先级 */    TaskNormal.priority = 1;    /**< 状态1:正常,2:停用 */    TaskNormal.state = 1;    /**< 任务开始前脚本ID */    /**< 任务结束后脚本ID */    /**< 任务运行时段 */    FRAME104_FMT_DEBUG("----设备类型nEqType=%d, 普通采集任务信息----\n", nEqType);    FRAME104_FMT_DEBUG("任务ID=%d, 执行频率 单位=%d, 值=%d, 方案类型=%d, 方案编号=%d, 优先级=%d, 状态=%d \n",         TaskNormal.id, TaskNormal.acqFreq.unit, TaskNormal.acqFreq.value, TaskNormal.planType, TaskNormal.planID,         TaskNormal.priority, TaskNormal.state);    FRAME104_FMT_DEBUG("开始时间 %d-%d-%d %d:%d:%d, 结束时间 %d-%d-%d %d:%d:%d, 延时 单位=%d, 值=%d \n",         TaskNormal.startTime.year, TaskNormal.startTime.month, TaskNormal.startTime.day, TaskNormal.startTime.hour,         TaskNormal.startTime.minute, TaskNormal.startTime.second,         TaskNormal.endTime.year, TaskNormal.endTime.month, TaskNormal.endTime.day, TaskNormal.endTime.hour,         TaskNormal.endTime.minute, TaskNormal.endTime.second, TaskNormal.acqDelay.unit, TaskNormal.acqDelay.value);    //将方案存入数据中心    ret = db_write_nomal(g_sDataCenterClient, &NormalOad, (uint8*)&TaskNormal, sizeof(OOP_TASK_T));    FRAME104_FMT_DEBUG("存储事件采集任务 db_write_nomal(). ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",            ret, NormalOad.logicId, NormalOad.infoNum, NormalOad.oad.value);    //单类型任务编号累加    //*pTaskNo ++;    FRAME104_FMT_DEBUG("********equip_event_task_save_zhj() 事件采集任务结束********\n");    return 1;}/*********************************************************************
 功能描述：根据点表内容生成采集任务存入数据中心
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int equip_task_save_zhj(){    FRAME104_FMT_DEBUG("********equip_task_save_zhj() 根据点表生成普通采集任务开始********\n");        int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//设备序号    int k = 0;    int ret = 0;    NOMAL_OAD_T NormalOad;    OOP_TASK_T TaskNormal;    uint16 nAreaID = 0;//定值区号    uint8 nTaskNo = 1;//任务编号 从1开始    uint32 ArrIdx = 0;//一维数组索引(起始)    memset(&NormalOad, 0x00, sizeof(NOMAL_OAD_T));    memset(&TaskNormal, 0x00, sizeof(OOP_TASK_T));    NormalOad.logicId = 7;    NormalOad.infoNum = 0;    NormalOad.oad.value =0x60120200;    NormalOad.classtag = CLASS_DATA_INIT;    //首先清除所有普通采集任务    clear_all_task_zhj(g_sDataCenterClient);    for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)    {        nTaskNo = 1;//任务编号 每种类型从1开始, 与类型组合                //目前仅处理智能电容器和剩余电流保护器        if(((i+1) != E_EQUIP_CAPACITOR) && ((i+1) != E_EQUIP_RESIDUALCURRENT))        {            continue;        }        z = 0;//第0组没有设备，则认为该类型没有设备        if(0 == g_aEquipCountZhj[i][z])        {            continue;        }        j = 0;//以第一个设备的采集周期作为任务的执行间隔值(临时)        //定值区号        nAreaID = g_nFixedAreaIdZhj[i][z][j];                memset(&TaskNormal, 0x00, sizeof(OOP_TASK_T));        /**< 任务ID */        TaskNormal.id = i + 1;//设备类型        NormalOad.infoNum =TaskNormal.id;        /**< 执行频率 */        TaskNormal.acqFreq.unit = 1;//分钟        ArrIdx = g_aParaValueIndexZhj[i][z][j];        for(k=0; k<g_nConfigParaNumZhj[i][z][j]; k++)        {            if(g_aParaSetValueZhj[nAreaID][ArrIdx+k].nObjAddrU32 == 0x00008007)            {                //以第一个设备的采集周期作为任务的执行间隔值(临时)                TaskNormal.acqFreq.value = g_aParaSetValueZhj[nAreaID][ArrIdx+k].nDefaultValueI64;                break;            }        }        /**< 方案类型 */        TaskNormal.planType = 1;//普通采集方案        /**< 方案编号 */        TaskNormal.planID = i + 1;//设备类型        /**< 开始时间(任务第一次开始执行时间)	*/        TaskNormal.startTime.year = 2020;        TaskNormal.startTime.month = 1;        TaskNormal.startTime.day = 1;        TaskNormal.startTime.hour = 0;        TaskNormal.startTime.minute = 0;        TaskNormal.startTime.second = 0;                /**< 结束时间(可以为空) */        TaskNormal.endTime.year = 2099;        TaskNormal.endTime.month = 1;        TaskNormal.endTime.day = 1;        TaskNormal.endTime.hour = 0;        TaskNormal.endTime.minute = 0;        TaskNormal.endTime.second = 0;        /**< 延时 */        TaskNormal.acqDelay.unit = 1;//分钟        TaskNormal.acqDelay.value = 0;        /**< 执行优先级 */        TaskNormal.priority = 1;        /**< 状态1:正常,2:停用 */        TaskNormal.state = 1;        /**< 任务开始前脚本ID */        /**< 任务结束后脚本ID */        /**< 任务运行时段 */        FRAME104_FMT_DEBUG("----设备类型i=%d, 普通采集任务信息----\n", i);        FRAME104_FMT_DEBUG("任务ID=%d, 执行频率 单位=%d, 值=%d, 方案类型=%d, 方案编号=%d, 优先级=%d, 状态=%d \n",             TaskNormal.id, TaskNormal.acqFreq.unit, TaskNormal.acqFreq.value, TaskNormal.planType, TaskNormal.planID,             TaskNormal.priority, TaskNormal.state);        FRAME104_FMT_DEBUG("开始时间 %d-%d-%d %d:%d:%d, 结束时间 %d-%d-%d %d:%d:%d, 延时 单位=%d, 值=%d \n",             TaskNormal.startTime.year, TaskNormal.startTime.month, TaskNormal.startTime.day, TaskNormal.startTime.hour,             TaskNormal.startTime.minute, TaskNormal.startTime.second,             TaskNormal.endTime.year, TaskNormal.endTime.month, TaskNormal.endTime.day, TaskNormal.endTime.hour,             TaskNormal.endTime.minute, TaskNormal.endTime.second, TaskNormal.acqDelay.unit, TaskNormal.acqDelay.value);        //将方案存入数据中心        ret = db_write_nomal(g_sDataCenterClient, &NormalOad, (uint8*)&TaskNormal, sizeof(OOP_TASK_T));        FRAME104_FMT_DEBUG("存储普通采集任务 db_write_nomal(). ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",                ret, NormalOad.logicId, NormalOad.infoNum, NormalOad.oad.value);        if((i+1) == E_EQUIP_RESIDUALCURRENT)        {            //如果是漏保设备, 还需要添加事件采集任务            equip_event_task_save_zhj((i+1), &nTaskNo);        }    }    FRAME104_FMT_DEBUG("********equip_task_save_zhj() 根据点表生成普通采集任务结束********\n");    return 1;}int i_frame_data_init_end_zhj(uint8 *pOutBuf){    int sendLen = 16;    TOTAL_104_FRAME_T stTotal104Frame;    memset(&stTotal104Frame, 0, sizeof(TOTAL_104_FRAME_T));    stTotal104Frame.nHead= 0x68;    stTotal104Frame.nLength = 0x0e;    stTotal104Frame.sCrtlType12.ibit.fir = 0;    stTotal104Frame.sCrtlType12.ibit.framenum = 0;    stTotal104Frame.sCrtlType34.rbit.fir = 0;    stTotal104Frame.sCrtlType34.rbit.framenum = 0;    stTotal104Frame.nDataType = 0x46; /* 初始化结束 */    stTotal104Frame.nVSQ = 0x01;    stTotal104Frame.nTransCauseL = 0x04;    stTotal104Frame.nTransCauseH = 0x00;    stTotal104Frame.nPubAddrL = 0x01;    stTotal104Frame.nPubAddrH = 0x08;    /* 对象地址 */    stTotal104Frame.aObjData[0] = 0x00;    stTotal104Frame.aObjData[1] = 0x00;    stTotal104Frame.aObjData[2] = 0x00;    /* 初始化原因COI */    stTotal104Frame.aObjData[3] = 0x00;    memcpy(pOutBuf, &stTotal104Frame, sendLen);    return sendLen;}/*********************************************************************所属功能单元：GB104规约处理模块功能描述	：I帧打包输入参数：nTI-数据标识, nVSQ-可变结构限定词, nCOT-传送原因             *pInObjBuff-信息对象内容，nInObjLen-信息对象长度			输出参数	：*pOutBuf-发送缓冲区地址			  函数返回值	：正数表示返回数据的长度，-1表示需要断连*******************************************************************/int i_frame_data_update_zhj(TOTAL_104_FRAME_T stTotal104Frame, uint8 *pOutBuf){	uint8 bStep = 0;    union s_num_union sCrtlType12;    union r_num_union sCrtlType34;    uint8 len = 0;    	g_nNoneActIFramTimes++;	g_nIFrameT1Count = MAX_FRAMCOM_DELAY_T1;    pOutBuf[bStep++] = 0x68;    len = stTotal104Frame.nLength;    pOutBuf[bStep++] = len;        sCrtlType12.ibit.fir = 0;	sCrtlType12.ibit.framenum = g_nIFramSendTimes;	sCrtlType34.rbit.fir = 0;	sCrtlType34.rbit.framenum = g_nIFramRecvTimes;    pOutBuf[bStep++] = sCrtlType12.crtltype12[0];    pOutBuf[bStep++] = sCrtlType12.crtltype12[1];    pOutBuf[bStep++] = sCrtlType34.crtltype34[0];    pOutBuf[bStep++] = sCrtlType34.crtltype34[1];    pOutBuf[bStep++] = stTotal104Frame.nDataType;    pOutBuf[bStep++] = stTotal104Frame.nVSQ;    pOutBuf[bStep++] = stTotal104Frame.nTransCauseL;    pOutBuf[bStep++] = stTotal104Frame.nTransCauseH;	pOutBuf[bStep++] = stTotal104Frame.nPubAddrL;    pOutBuf[bStep++] = stTotal104Frame.nPubAddrH;    memcpy(&pOutBuf[bStep], stTotal104Frame.aObjData, len-CTRL_UNIT_LABEL_LEN); //数据移到信息体位置	if(g_nIFramSendTimes <32767)		g_nIFramSendTimes++;	else		g_nIFramSendTimes = 0;    	return len+2;}/*********************************************************************所属功能单元：GB104规约处理模块功能描述	：I帧打包输入参数：nTI-数据标识, nVSQ-可变结构限定词, nCOT-传送原因             *pInObjBuff-信息对象内容，nInObjLen-信息对象长度			输出参数	：*pOutBuf-发送缓冲区地址			  函数返回值	：正数表示返回数据的长度，-1表示需要断连*******************************************************************/int i_frame_data_pack_zhj(uint8 nTI, uint8 nVSQ, uint16 nCOT, uint16 nPubAddr, uint8 *pInObjBuff, uint8 nInObjLen, uint8 *pOutBuf){	uint8 bStep = 0;    union s_num_union sCrtlType12;    union r_num_union sCrtlType34;    uint8 len = 0;    	g_nNoneActIFramTimes++;	g_nIFrameT1Count = MAX_FRAMCOM_DELAY_T1;    pOutBuf[bStep++] = 0x68;    len = CTRL_UNIT_LABEL_LEN + nInObjLen;    pOutBuf[bStep++] = len;        sCrtlType12.ibit.fir = 0;	sCrtlType12.ibit.framenum = g_nIFramSendTimes;	sCrtlType34.rbit.fir = 0;	sCrtlType34.rbit.framenum = g_nIFramRecvTimes;    pOutBuf[bStep++] = sCrtlType12.crtltype12[0];    pOutBuf[bStep++] = sCrtlType12.crtltype12[1];    pOutBuf[bStep++] = sCrtlType34.crtltype34[0];    pOutBuf[bStep++] = sCrtlType34.crtltype34[1];    pOutBuf[bStep++] = nTI;    pOutBuf[bStep++] = nVSQ;    pOutBuf[bStep++] = nCOT&0xff;    pOutBuf[bStep++] = nCOT>>8;	pOutBuf[bStep++] = nPubAddr&0xff;    pOutBuf[bStep++] = nPubAddr>>8;    memcpy(&pOutBuf[bStep], pInObjBuff, nInObjLen); //数据移到信息体位置	if(g_nIFramSendTimes <32767)		g_nIFramSendTimes++;	else		g_nIFramSendTimes = 0;    	return len+2;}/*********************************************************************
 功能描述：检查总召地址是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_all_addr_zhj(uint16 PubAddr){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nAllCallPubAddrZhj = PubAddr;//总召唤公共地址    memset(g_aAllCallEquipState, 0x00, sizeof(g_aAllCallEquipState));    memset(g_aAllCallEquipStateYC_R, 0x00, sizeof(g_aAllCallEquipStateYC_R));    memset(g_aAllCallEquipStateYC_R_T, 0x00, sizeof(g_aAllCallEquipStateYC_R_T));    memset(g_aAllCallEquipStateYX, 0x00, sizeof(g_aAllCallEquipStateYX));    memset(g_aAllCallEquipStateYC_STR, 0x00, sizeof(g_aAllCallEquipStateYC_STR));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_call_all_addr_zhj()总召唤检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nAllCallPubAddrZhj, equipType, equipGroup, equipNo);    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                memset(g_aAllCallEquipState, 0x01, sizeof(g_aAllCallEquipState));                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                    {                        g_aAllCallEquipState[i][j][equipNo-1] = 1;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aAllCallEquipState[i][equipGroup][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_aAllCallEquipState[i][equipGroup][equipNo-1] = 1;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aAllCallEquipState[equipType-1][j][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    g_aAllCallEquipState[equipType-1][j][equipNo-1] = 1;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aAllCallEquipState[equipType-1][equipGroup][k] = 1;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_aAllCallEquipState[equipType-1][equipGroup][equipNo-1] = 1;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_call_all_addr_zhj()总召唤检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        g_bAllDataCallFlag = 0;        return -1;    }    memcpy(g_aAllCallEquipStateYC_R, g_aAllCallEquipState, sizeof(g_aAllCallEquipState));    memcpy(g_aAllCallEquipStateYC_R_T, g_aAllCallEquipState, sizeof(g_aAllCallEquipState));    memcpy(g_aAllCallEquipStateYX, g_aAllCallEquipState, sizeof(g_aAllCallEquipState));    memcpy(g_aAllCallEquipStateYC_STR, g_aAllCallEquipState, sizeof(g_aAllCallEquipState));    return 1;}/*********************************************************************
 功能描述：检查电量召唤地址是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_energy_addr_zhj(uint16 PubAddr){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nEnergyCallPubAddrZhj = PubAddr;//总召唤公共地址    memset(g_aEnergyCallEquipState, 0x00, sizeof(g_aEnergyCallEquipState));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_call_energy_addr_zhj()电量召唤检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nEnergyCallPubAddrZhj, equipType, equipGroup, equipNo);    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                memset(g_aEnergyCallEquipState, 0x01, sizeof(g_aEnergyCallEquipState));                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                    {                        g_aEnergyCallEquipState[i][j][equipNo-1] = 1;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aEnergyCallEquipState[i][equipGroup][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_aEnergyCallEquipState[i][equipGroup][equipNo-1] = 1;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aEnergyCallEquipState[equipType-1][j][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    g_aEnergyCallEquipState[equipType-1][j][equipNo-1] = 1;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aEnergyCallEquipState[equipType-1][equipGroup][k] = 1;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_aEnergyCallEquipState[equipType-1][equipGroup][equipNo-1] = 1;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_call_energy_addr_zhj()电量召唤检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        g_nElecDataCallFlag = 0;        return -1;    }    return 1;}/*********************************************************************
 功能描述：检查点召唤地址是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_point_addr_zhj(uint16 PubAddr){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nPointCallPubAddrZhj = PubAddr;//点召唤公共地址    memset(g_aPointCallEquipState, 0x00, sizeof(g_aPointCallEquipState));    memset(g_aPointCallEquipStateYC_R, 0x00, sizeof(g_aPointCallEquipStateYC_R));    memset(g_aPointCallEquipStateYC_R_T, 0x00, sizeof(g_aPointCallEquipStateYC_R_T));    memset(g_aPointCallEquipStateYC_R_EN, 0x00, sizeof(g_aPointCallEquipStateYC_R_EN));    memset(g_aPointCallEquipStateYX, 0x00, sizeof(g_aPointCallEquipStateYX));    memset(g_aPointCallEquipStateYC_STR, 0x00, sizeof(g_aPointCallEquipStateYC_STR));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_call_point_addr_zhj()点召唤检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nPointCallPubAddrZhj, equipType, equipGroup, equipNo);    //解析公共地址    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                memset(g_aPointCallEquipState, 0x01, sizeof(g_aPointCallEquipState));                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                    {                        g_aPointCallEquipState[i][j][equipNo-1] = 1;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aPointCallEquipState[i][equipGroup][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_aPointCallEquipState[i][equipGroup][equipNo-1] = 1;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aPointCallEquipState[equipType-1][j][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    g_aPointCallEquipState[equipType-1][j][equipNo-1] = 1;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aPointCallEquipState[equipType-1][equipGroup][k] = 1;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_aPointCallEquipState[equipType-1][equipGroup][equipNo-1] = 1;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_call_point_addr_zhj()点召唤检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        g_bPointCallFlag = 0;        return -1;    }    memcpy(g_aPointCallEquipStateYC_R, g_aPointCallEquipState, sizeof(g_aPointCallEquipState));    memcpy(g_aPointCallEquipStateYC_R_T, g_aPointCallEquipState, sizeof(g_aPointCallEquipState));    memcpy(g_aPointCallEquipStateYC_R_EN, g_aPointCallEquipState, sizeof(g_aPointCallEquipState));    memcpy(g_aPointCallEquipStateYX, g_aPointCallEquipState, sizeof(g_aPointCallEquipState));    memcpy(g_aPointCallEquipStateYC_STR, g_aPointCallEquipState, sizeof(g_aPointCallEquipState));    return 1;}/*********************************************************************
 功能描述：检查点召信息体内容是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_point_info_zhj(uint8* pInfo, uint8 nInfoLen){    int i = 0;    int count = 0;//信息体统计个数    FRAME104_FMT_TRACE("check_call_point_info_zhj() 点召唤地址信息体总长度nInfoLen=%d \n", nInfoLen);    if(nInfoLen < 3)    {        FRAME104_FMT_TRACE("check_call_point_info_zhj()点召唤检查 信息体地址长度错误! nInfoLen=%d \n", nInfoLen);        g_bPointCallFlag = 0;        return -1;    }    FRAME104_BUF_TRACE(pInfo, nInfoLen, "信息体内容:");    memset(g_aPointCallInfoAddr, 0x00, sizeof(g_aPointCallInfoAddr));    while(i<nInfoLen)    {        memcpy((uint8 *)&g_aPointCallInfoAddr[count], &pInfo[i], 3);//信息体地址为3个字节，前低后高        FRAME104_FMT_TRACE("点召唤地址g_aPointCallInfoAddr[%d]=%08x \n", count, g_aPointCallInfoAddr[count]);        i += 3;        count += 1;    }    g_nPointCallInfoAddrNum = count;    FRAME104_FMT_TRACE("check_call_point_info_zhj() 点召唤地址总数量count=%d \n", count);    return 1;}/*********************************************************************
 功能描述：检查任务召唤地址是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_task_addr_zhj(uint16 PubAddr, uint8* pInfo, uint8 nInfoLen){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    uint32 infoAddr = 0;//信息对象地址    uint16 taskNo = 0;//任务编号 从1开始    int index = 0;    //int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nTaskCallPubAddrZhj = PubAddr;//点召唤公共地址    memset(g_aTaskCallEquipState, 0x00, sizeof(g_aTaskCallEquipState));    memset(g_aTaskCallEquipStateYC_R, 0x00, sizeof(g_aTaskCallEquipStateYC_R));    memset(g_aTaskCallEquipStateYX, 0x00, sizeof(g_aTaskCallEquipStateYX));    memset(g_aTaskCallEquipStateYC_STR, 0x00, sizeof(g_aTaskCallEquipStateYC_STR));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_call_task_addr_zhj()任务召唤检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nTaskCallPubAddrZhj, equipType, equipGroup, equipNo);    /* 加上配变电压器是因为台体测试时使用的是配变电压器 */    if((equipType != E_EQUIP_POWERTERMINAL) && (equipType != E_EQUIP_TRANSFORMER) && (equipType != 31))//任务召唤仅限于终端设备或所有设备类型    {        FRAME104_FMT_TRACE("check_call_task_addr_zhj()任务召唤检查 设备类型不支持! 终端设备的类型编号应为%d! \n", E_EQUIP_POWERTERMINAL);        g_bTaskCallFlag = 0;        return -1;    }    if(nInfoLen < (3+1+7+7))//3信息对象地址+1任务号+7起始时间+7结束时间    {        FRAME104_FMT_TRACE("check_call_task_addr_zhj()任务召唤检查 信息体地址长度错误! nInfoLen=%d \n", nInfoLen);        g_bTaskCallFlag = 0;        return -1;    }    //解析信息体内容    memcpy((uint8 *)&infoAddr, &pInfo[index], 3);//信息体地址    index += 3;    taskNo = pInfo[index];//任务号    g_stTaskCallConfig.nTaskNo = taskNo;    index += 1;    memcpy(g_stTaskCallConfig.aStartTime, &pInfo[index], 7);//开始时间    cp56time2a_to_ooptm(g_stTaskCallConfig.aStartTime, &g_stTaskCallConfig.stStartTime);    ooptm_to_systm(g_stTaskCallConfig.stStartTime, &g_stTaskCallConfig.tStartTime);    index += 7;    memcpy(g_stTaskCallConfig.aEndTime, &pInfo[index], 7);//结束时间    cp56time2a_to_ooptm(g_stTaskCallConfig.aEndTime, &g_stTaskCallConfig.stEndTime);    ooptm_to_systm(g_stTaskCallConfig.stEndTime, &g_stTaskCallConfig.tEndTime);    index += 7;    FRAME104_FMT_TRACE("任务编号 %d \n", taskNo);    FRAME104_FMT_TRACE("起始时间 %d-%d-%d %d:%d:%d, 结束时间 %d-%d-%d %d:%d:%d \n", g_stTaskCallConfig.stStartTime.year, g_stTaskCallConfig.stStartTime.month,                         g_stTaskCallConfig.stStartTime.day, g_stTaskCallConfig.stStartTime.hour, g_stTaskCallConfig.stStartTime.minute,                         g_stTaskCallConfig.stStartTime.second,                         g_stTaskCallConfig.stEndTime.year, g_stTaskCallConfig.stEndTime.month,                         g_stTaskCallConfig.stEndTime.day, g_stTaskCallConfig.stEndTime.hour, g_stTaskCallConfig.stEndTime.minute,                         g_stTaskCallConfig.stEndTime.second);    //解析公共地址(类型参数未使用, 仅考虑组别和设备序号)    if(0x07 == equipGroup)//所有组别    {        if(0xff == equipNo)//所有设备        {            for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aTaskCallEquipState[j][k][taskNo-1] = 1;                    //公共地址上报状态                    memset(&g_aTaskCallPubAddrState[j][k][taskNo-1][0], 0x01, g_aReportTaskPubAddrNum[j][k][taskNo-1]);                }                            }            bValid = TRUE;        }        else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))        {            for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)            {                g_aTaskCallEquipState[j][equipNo-1][taskNo-1] = 1;                //公共地址上报状态                memset(&g_aTaskCallPubAddrState[j][equipNo-1][taskNo-1][0], 0x01, g_aReportTaskPubAddrNum[j][equipNo-1][taskNo-1]);            }            bValid = TRUE;        }    }    else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别    {        if(0xff == equipNo)//所有设备        {            for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)            {                g_aTaskCallEquipState[equipGroup][k][taskNo-1] = 1;                //公共地址上报状态                memset(&g_aTaskCallPubAddrState[equipGroup][k][taskNo-1][0], 0x01, g_aReportTaskPubAddrNum[equipGroup][k][taskNo-1]);            }            bValid = TRUE;        }        else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))        {            g_aTaskCallEquipState[equipGroup][equipNo-1][taskNo-1] = 1;            //公共地址上报状态            memset(&g_aTaskCallPubAddrState[equipGroup][equipNo-1][taskNo-1][0], 0x01, g_aReportTaskPubAddrNum[equipGroup][equipNo-1][taskNo-1]);            bValid = TRUE;        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_call_task_addr_zhj()任务召唤检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        g_bTaskCallFlag = 0;        return -1;    }    memcpy(g_aTaskCallEquipStateYC_R, g_aTaskCallEquipState, sizeof(g_aTaskCallEquipState));    memcpy(g_aTaskCallEquipStateYX, g_aTaskCallEquipState, sizeof(g_aTaskCallEquipState));    memcpy(g_aTaskCallEquipStateYC_STR, g_aTaskCallEquipState, sizeof(g_aTaskCallEquipState));    return 1;}/*********************************************************************
 功能描述：设定定值区号
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_set_area_addr_zhj(uint16 PubAddr, uint16 AreaID){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_set_area_addr_zhj()设定定值区检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", PubAddr, equipType, equipGroup, equipNo);    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<g_aGroupCountZhj[i]; j++)                    {                        for(k=0; k<g_aEquipCountZhj[i][j]; k++)                        {                            g_nFixedAreaIdZhj[i][j][k] = AreaID;                        }                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<g_aGroupCountZhj[i]; j++)                    {                        g_nFixedAreaIdZhj[i][j][equipNo-1] = AreaID;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<g_aEquipCountZhj[i][j]; k++)                    {                        g_nFixedAreaIdZhj[i][equipGroup][k] = AreaID;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_nFixedAreaIdZhj[i][equipGroup][equipNo-1] = AreaID;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<g_aGroupCountZhj[i]; j++)                {                    for(k=0; k<g_aEquipCountZhj[i][j]; k++)                    {                        g_nFixedAreaIdZhj[equipType-1][j][k] = AreaID;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<g_aGroupCountZhj[i]; j++)                {                    g_nFixedAreaIdZhj[equipType-1][j][equipNo-1] = AreaID;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<g_aEquipCountZhj[i][j]; k++)                {                    g_nFixedAreaIdZhj[equipType-1][equipGroup][k] = AreaID;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_nFixedAreaIdZhj[equipType-1][equipGroup][equipNo-1] = AreaID;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_set_area_addr_zhj()设定定值区检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        return -1;    }    return 1;}/*********************************************************************
 功能描述：读取定值区号
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_get_area_addr_zhj(uint16 PubAddr, uint16 *OutAreaID){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    BOOL bValid = FALSE;    uint16 nAreaIdTemp = 0;        equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_get_area_addr_zhj()读取定值区检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", PubAddr, equipType, equipGroup, equipNo);    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                nAreaIdTemp = g_nFixedAreaIdZhj[0][0][0];                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                nAreaIdTemp =  g_nFixedAreaIdZhj[0][0][equipNo-1];                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                nAreaIdTemp = g_nFixedAreaIdZhj[0][equipGroup][0];                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                nAreaIdTemp =  g_nFixedAreaIdZhj[0][equipGroup][equipNo-1];                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                nAreaIdTemp = g_nFixedAreaIdZhj[equipType-1][0][0];                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                nAreaIdTemp = g_nFixedAreaIdZhj[equipType-1][0][equipNo-1];                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                nAreaIdTemp = g_nFixedAreaIdZhj[equipType-1][equipGroup][0];                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                nAreaIdTemp = g_nFixedAreaIdZhj[equipType-1][equipGroup][equipNo-1];                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_get_area_addr_zhj()读取定值区检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        return -1;    }    *OutAreaID = nAreaIdTemp;    return 1;}/*********************************************************************
 功能描述：检查读全部参数地址是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_all_para_addr_zhj(uint16 PubAddr){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nAllParaCallPubAddrZhj = PubAddr;//总召唤公共地址    memset(g_aAllParaEquipState, 0x00, sizeof(g_aAllParaEquipState));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_call_all_para_addr_zhj()所有参数召唤检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nAllCallPubAddrZhj, equipType, equipGroup, equipNo);    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                memset(g_aAllParaEquipState, 0x01, sizeof(g_aAllParaEquipState));                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                    {                        g_aAllParaEquipState[i][j][equipNo-1] = 1;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aAllParaEquipState[i][equipGroup][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_aAllParaEquipState[i][equipGroup][equipNo-1] = 1;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aAllParaEquipState[equipType-1][j][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    g_aAllParaEquipState[equipType-1][j][equipNo-1] = 1;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aAllParaEquipState[equipType-1][equipGroup][k] = 1;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_aAllParaEquipState[equipType-1][equipGroup][equipNo-1] = 1;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_call_all_para_addr_zhj()所有参数召唤检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        g_bAllParaCallFlag = 0;        return -1;    }    return 1;}/*********************************************************************
 功能描述：检查点召唤地址是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_some_para_addr_zhj(uint16 PubAddr){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nSomeParaCallPubAddrZhj = PubAddr;//点召唤公共地址    memset(g_aSomeParaCallEquipState, 0x00, sizeof(g_aSomeParaCallEquipState));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_call_some_para_addr_zhj()部分参数召唤检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nSomeParaCallPubAddrZhj, equipType, equipGroup, equipNo);    //解析公共地址    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                memset(g_aSomeParaCallEquipState, 0x01, sizeof(g_aSomeParaCallEquipState));                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                    {                        g_aSomeParaCallEquipState[i][j][equipNo-1] = 1;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aSomeParaCallEquipState[i][equipGroup][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_aSomeParaCallEquipState[i][equipGroup][equipNo-1] = 1;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aSomeParaCallEquipState[equipType-1][j][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    g_aSomeParaCallEquipState[equipType-1][j][equipNo-1] = 1;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aSomeParaCallEquipState[equipType-1][equipGroup][k] = 1;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_aSomeParaCallEquipState[equipType-1][equipGroup][equipNo-1] = 1;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_call_some_para_addr_zhj()部分参数召唤检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        g_bSomeParaCallFlag = 0;        return -1;    }    return 1;}/*********************************************************************
 功能描述：检查点召信息体内容是否正确
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_call_some_para_info_zhj(uint8* pInfo, uint8 nInfoLen){    int i = 0;    int count = 0;//信息体统计个数    FRAME104_FMT_TRACE("check_call_some_para_info_zhj() 部分参数召唤地址信息体总长度nInfoLen=%d \n", nInfoLen);    if(nInfoLen < 3)    {        FRAME104_FMT_TRACE("check_call_some_para_info_zhj() 部分参数召唤召唤检查 信息体地址长度错误! nInfoLen=%d \n", nInfoLen);        g_bSomeParaCallFlag = 0;        return -1;    }    FRAME104_BUF_TRACE(pInfo, nInfoLen, "信息体内容:");    memset(g_aSomeParaCallInfoAddr, 0x00, sizeof(g_aSomeParaCallInfoAddr));    while(i<nInfoLen)    {        memcpy((uint8 *)&g_aSomeParaCallInfoAddr[count], &pInfo[i], 3);//信息体地址为3个字节，前低后高        FRAME104_FMT_TRACE("部分参数召唤地址 g_aSomeParaCallInfoAddr[%d]=%08x \n", count, g_aSomeParaCallInfoAddr[count]);        i += 3;        count += 1;    }    g_nSomeParaCallInfoAddrNum = count;    FRAME104_FMT_TRACE("check_call_some_para_info_zhj() 部分参数召唤地址总数量count=%d \n", count);    return 1;}/******************************************************************************** 函数名称: move_to_next_call_task_zhj* 函数功能: 获取任务召测的下一个冻结任务(数组下标)* 输入参数: nType 上报数据类型 1实时 2冻结* 输出参数: 无* 返 回 值: 无*******************************************************************************/int move_to_next_call_task_zhj(uint8 nType){    int x = 0;    int i = 0;    int j = 0;    uint16 nowEqCountIndex = g_sTaskRunStep.nEquipGroupIndex;//终端设备组别    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;//终端设备编号    uint16 nowEqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;//任务下标    uint32 ArrIdx = 0;//一维数组索引(起始)    for(x=nowEqCountIndex; i<MAX_EQUIP_GROUP_NUM; i++)    {        for(i=nowEqNoIndex; i<MAX_EQUIP_COUNT_NUM; i++)        {            ArrIdx = g_aReportTaskIndex[x][i];            for(j=nowEqTaskNoIndex; j<MAX_REPORT_TASK_NUM; j++)            {                //任务有效，并且需要上报                if(g_aReportTaskConfig[ArrIdx+j].bIsValid == 1 &&                     g_aReportTaskConfig[ArrIdx+j].bIsCorrect == 1 &&                     g_aTaskCallEquipState[x][i][j] == 1)                {                    //上报数据类型 1实时 2冻结                    if(g_aReportTaskConfig[ArrIdx+j].nReportDataType == nType)                    {                        g_sTaskRunStep.nEquipGroupIndex = x;                        g_sTaskRunStep.nEquipNoIndex = i;                        g_sTaskRunStep.nEqTaskNoIndex = j;                        return 1;                    }                }            }            nowEqTaskNoIndex = 0;        }        nowEqNoIndex = 0;    }    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    g_sTaskRunStep.nEqTaskNoIndex = 0;    return -1;}/*********************************************************************
 功能描述： 检查写参数时的公共地址是否合法
 输入参数：
 输出参数：无
 函数返回值：无********************************************************************/int check_para_oper_addr_zhj(uint16 PubAddr){    uint16 equipType = 0;//设备类型 从1开始    uint16 equipGroup = 0;//设备组号 从0开始    uint16 equipNo = 0;//组内偏移地址 从1开始    int i = 0;    int j = 0;    int k = 0;    BOOL bValid = FALSE;        g_nFixedValuePubAddrZhj = PubAddr;//总召唤公共地址    memset(g_aFixedValueStateZhj, 0x00, sizeof(g_aFixedValueStateZhj));    equipType = (PubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    equipGroup = (PubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    equipNo = PubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    FRAME104_FMT_TRACE("check_para_oper_addr_zhj()写参数检查 公共地址=%04x, 设备类型=%d, 设备组别=%d, 设备序号=%d \n", g_nFixedValuePubAddrZhj, equipType, equipGroup, equipNo);    if(0x1f == equipType)//所有类型    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                memset(g_aFixedValueStateZhj, 0x01, sizeof(g_aFixedValueStateZhj));                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                    {                        g_aFixedValueStateZhj[i][j][equipNo-1] = 1;                    }                                    }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aFixedValueStateZhj[i][equipGroup][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)                {                    g_aFixedValueStateZhj[i][equipGroup][equipNo-1] = 1;                }                bValid = TRUE;            }        }    }    else if((equipType > 0) && (equipType <= MAX_EQUIP_TYPE_NUM))    {        if(0x07 == equipGroup)//所有组别        {            if(0xff == equipNo)//所有设备            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                    {                        g_aFixedValueStateZhj[equipType-1][j][k] = 1;                    }                                    }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                for(j=0; j<MAX_EQUIP_GROUP_NUM; j++)                {                    g_aFixedValueStateZhj[equipType-1][j][equipNo-1] = 1;                }                bValid = TRUE;            }        }        else if(/*(equipGroup > 0) && */(equipGroup < MAX_EQUIP_GROUP_NUM))//指定组别        {            if(0xff == equipNo)//所有设备            {                for(k=0; k<MAX_EQUIP_COUNT_NUM; k++)                {                    g_aFixedValueStateZhj[equipType-1][equipGroup][k] = 1;                }                bValid = TRUE;            }            else if((equipNo > 0) && (equipNo <= MAX_EQUIP_COUNT_NUM))            {                g_aFixedValueStateZhj[equipType-1][equipGroup][equipNo-1] = 1;                bValid = TRUE;            }        }    }    if(!bValid)    {        FRAME104_FMT_TRACE("check_para_oper_addr_zhj()写参数检查 公共地址不支持! 设备类型最大值=%d, 设备组别最大值=%d, 设备序号最大值=%d \n", MAX_EQUIP_TYPE_NUM, MAX_EQUIP_GROUP_NUM, MAX_EQUIP_COUNT_NUM);        return -1;    }    return 1;}/******************************************************************************** 函数名称: change_report_task_zhj* 函数功能: 判断下发的参数是否与上报任务相关* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int change_report_task_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr){    int ret = -1;    //终端的设备类型为1, 数组下标为0    if(E_EQUIP_POWERTERMINAL == (eqtypeIndex+1))    {        if((InfoAddr >= 0x00008040) && (InfoAddr <= 0x0000806C))        {            ret = 1;        }    }    return ret;}/******************************************************************************** 函数名称: change_equip_files_zhj* 函数功能: 判断下发的参数是否与设备档案相关* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int change_equip_files_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr){    int ret = -1;    //判断设备类型    if(E_EQUIP_CAPACITOR == (eqtypeIndex+1))//智能电容器的设备类型为4, 数组下标为3    {        if( (InfoAddr == 0x00008001) ||            ((InfoAddr >= 0x00008003) && (InfoAddr <= 0x00008008)) )        {            ret = 1;        }    }    else if(E_EQUIP_RESIDUALCURRENT == (eqtypeIndex+1))//剩余电流保护器的设备类型为9, 数组下标为8    {        if( (InfoAddr == 0x00008001) ||            ((InfoAddr >= 0x00008003) && (InfoAddr <= 0x00008008)) )        {            ret = 1;        }    }    return ret;}/*********************************************************************所属功能单元：GB104规约处理模块功能描述	：更新定值参数全局变量输入参数	：输出参数	：函数返回值：*******************************************************************/int para_data_update_zhj(uint16 nEqTypeIndex, uint16 nEqGroupIndex, uint16 nEqIdIndex, uint16 nFixArea, PARA_SET_VALUE_T sParaSetValue){	int i = 0;    int x = nEqTypeIndex;//设备类型    int y = nEqGroupIndex;//设备组别    int z = nEqIdIndex;//组内序号    int ret = -1;    	if(nFixArea >= MAX_FIXED_AREA_NUM)	{		FRAME104_FMT_TRACE("para_data_write_zhj() if(nFixArea > MAX_FIXED_AREA_NUM) ... \n");		return -1;	}    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aParaValueIndexZhj[x][y][z];    for(i=0; i<g_nConfigParaNumZhj[x][y][z]; i++)	{		if(sParaSetValue.nObjAddrU32 == g_aParaSetValueZhj[nFixArea][ArrIdx+i].nObjAddrU32)		{            if (x == 8 && sParaSetValue.nObjAddrU32 == 0x00008003) /* 漏保的设备地址翻转 */            {                int begin = 0;                int end = sParaSetValue.nArrLen - 1;                uint8 tmp;                while (begin < end)                {                    tmp = sParaSetValue.aArrValue[begin];                    sParaSetValue.aArrValue[begin] = sParaSetValue.aArrValue[end];                    sParaSetValue.aArrValue[end] = tmp;                    begin++;                    end--;                }            }		    //测试(放开所有参数可写)		    g_aParaSetValueZhj[nFixArea][ArrIdx+i].bModifiable = TRUE;            //判断参数是否可写		    if(TRUE == g_aParaSetValueZhj[nFixArea][ArrIdx+i].bModifiable)            {                g_aParaSetValueZhj[nFixArea][ArrIdx+i].nTagType = sParaSetValue.nTagType;    			g_aParaSetValueZhj[nFixArea][ArrIdx+i].nDataLen = sParaSetValue.nDataLen;    			memcpy(&g_aParaSetValueZhj[nFixArea][ArrIdx+i].unValue, &sParaSetValue.unValue, sParaSetValue.nDataLen);                g_aParaSetValueZhj[nFixArea][ArrIdx+i].nArrLen = sParaSetValue.nArrLen;    			memcpy(&g_aParaSetValueZhj[nFixArea][ArrIdx+i].aArrValue, &sParaSetValue.aArrValue, sParaSetValue.nArrLen);    			g_aParaSetValueZhj[nFixArea][ArrIdx+i].bValid = TRUE;                g_bFixedChangeFlagZhj[x][y][z][nFixArea] = TRUE;                ret = 1;                FRAME104_FMT_TRACE("para_data_write_zhj() 需要更新定值参数私有文件! \n");                break;            }			else            {                FRAME104_FMT_TRACE("para_data_write_zhj() 该参数不可修改! \n");            }		}	}		return ret;}/*           主站下发的tag格式类型，具体如下名称		类型	标记（TAG）  长度(LENGTH)	 值（VALUE） 布尔		Boolean 	1			1			1:true,0:false 小整形		Tiny		43			 1			-128…127 无符号小整形 UTiny	32	           1			 0…255 短整形		Short		33			2			 -32768…32767 无符号短整形 UShort 	45			2			0…65535 整形		Int 		2			4			 -2147483648…2147483648 无符号整形	Uint		35			4			 0…4294967295 长整形		Long		36			8			 -2^64…2^64 无符号长整形 Ulong		37			8			 0…2^128-1 单精度浮点	Float		38			4			 -2^128…2^128 双精度浮点	Double	39			8			 -2^1024…2^1024 八位位串类型 OcterString    4 			可变		OcterString 字符串类型	String		4       可变        一个或者多个ASCII组成,最长64个字节，以'\0'结尾	*//*********************************************************************所属功能单元：GB104规约处理模块功能描述	：参数设置逻辑输入参数	：输出参数	：  函数返回值	：返回FALSE 操作失败*******************************************************************/uint8 para_set_operate_zhj(uint8 infonum, uint8 *pdata, uint8 infolen, uint8 btype){	int i = 0;	uint8  index = 0;	uint8  nObjNum = 0;  //信息体元素个数 	nObjNum = infonum;  //预置：对应信息元素个数；固化/撤销：0x00	uint16 nFixedAreaID = 0;  //定值区号	uint8 nParaIden = 0;  //参数特征标识	int x = 0;//设备类型    int y = 0;//设备组别    int z = 0;//组内序号    BOOL bUpdatePrivateFile = FALSE;//是否需要更新参数私有文件    BOOL bUpdateReportTask = FALSE;//是否需要更新上报任务方案    BOOL bUpdateEquipFiles = FALSE;//是否需要更新设备档案	PARA_SET_VALUE_T  sParaSetValue;   //设置参数结构体	memset(&sParaSetValue, 0, sizeof(PARA_SET_VALUE_T));		//判断当前状态是否可以预置/执行/撤销    uint8 rtn = TRUE;	nFixedAreaID = pdata[index] + (pdata[index+1]<<8);  //定值区号2字节	index += 2;	nParaIden = pdata[index];  //参数特征标识1字节	index += 1;	if(nFixedAreaID >= MAX_FIXED_AREA_NUM)	{		FRAME104_FMT_TRACE("para_set_operate_zhj() 定值区号错误! nFixedAreaID:%d, max=%d \n", nFixedAreaID, MAX_FIXED_AREA_NUM);		return FALSE;	}    for(x=0; x<MAX_EQUIP_TYPE_NUM; x++)    {        for(y=0; y<g_aGroupCountZhj[x]; y++)        {            for(z=0; z<g_aEquipCountZhj[x][y];z++)            {                uint32 IdenArrIdx = 0;//定值区标识一维数组索引(起始)                IdenArrIdx = g_aFixedAreaIndexZhj[nFixedAreaID][x][y][z];                    if(g_aFixedValueStateZhj[x][y][z] == 1)                {                    FRAME104_FMT_TRACE("para_set_operate_zhj() 设备类型下标=%d, 组别下标=%d, 序号下标=%d \n", x, y, z);                    switch(btype)                    {                        case PARA_SELECT://-参数预置-                        {                            rtn =  TRUE;                			g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].unParaIdentify.nParaIden = nParaIden;                			g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState = 0x55;                			g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[0] = 0x55;                			g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[1] = nObjNum;                			memcpy(&g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[2], &pdata[3], infolen-3);                			FRAME104_FMT_TRACE("para_set_operate_zhj() 参数预置接受! 定值区号nFixedAreaID=%d, 参数标识nParaIden=%02x, 当前状态nSetState=%02x 参数个数nObjNum:%d 参数报文: \n",                 				nFixedAreaID, nParaIden, g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState, nObjNum);                			FRAME104_BUF_TRACE(&g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[2], infolen-3, "报文: ");                            break;                        }                        case PARA_RUN://-参数固化-                        {                            if(g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState != 0x55)//-未预置，返回失败-                            {                                rtn =  FALSE;                				FRAME104_FMT_TRACE("para_set_operate_zhj() 参数固化拒绝!请先预置! 定值区号nFixedAreaID=%d, 参数标识nParaIden=%02x, 当前状态nSetState=%02x \n",                 					nFixedAreaID, nParaIden, g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState);                            }                            else                            {                            	nObjNum = g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[1];                				index = 2;                				for(i=0; i<nObjNum; i++)                				{                					memset(&sParaSetValue, 0, sizeof(PARA_SET_VALUE_T));                                    memcpy((uint8 *)&sParaSetValue.nObjAddrU32, &g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[index], 3);//信息体地址                					index += 3;  //信息体3字节，最高字节为0，index当前位置是tag                					sParaSetValue.nTagType = g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[index];                					index += 1;  //tag 1字节                					if(4 == sParaSetValue.nTagType || 8 == sParaSetValue.nTagType)//八位位串或字符串类型                                    {                                        sParaSetValue.nArrLen = g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[index];                					    index += 1;  //长度 1字节                                        memcpy(&sParaSetValue.aArrValue, &g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[index], sParaSetValue.nArrLen);                                        index += sParaSetValue.nArrLen;  //数据内容 sParaSetValue.nDataLen个字节                                    }                                    else                                    {                                        sParaSetValue.nDataLen = g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[index];                					    index += 1;  //长度 1字节                                        memcpy(&sParaSetValue.unValue, &g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].aSetPara[index], sParaSetValue.nDataLen);                                        index += sParaSetValue.nDataLen;  //数据内容 sParaSetValue.nDataLen个字节                                    }                					FRAME104_FMT_TRACE("para_set_operate_zhj() 参数固化解析 nObjNum:%d, i=%d, nObjAddr:%08x, nTagType=%d, nDataLen=%d, nArrLen=%d \n",                 						nObjNum, i, sParaSetValue.nObjAddrU32, sParaSetValue.nTagType, sParaSetValue.nDataLen, sParaSetValue.nArrLen);                					FRAME104_BUF_TRACE(&sParaSetValue.unValue.arrayV[0], sParaSetValue.nDataLen, "unValue 报文: ");                                    FRAME104_BUF_TRACE(&sParaSetValue.aArrValue[0], sParaSetValue.nArrLen, "aArrValue 报文: ");                                    //更新定值参数全局变量                                    if(para_data_update_zhj(x, y, z, nFixedAreaID, sParaSetValue) > 0)                                    {                                        bUpdatePrivateFile = TRUE;                                    }                                    //判断下发的参数是否与上报任务相关                                    if(change_report_task_zhj(x, y, z, sParaSetValue.nObjAddrU32) > 0)                                    {                                        bUpdateReportTask = TRUE;                                    }                                    //判断下发的参数是否与设备档案相关                                    if(change_equip_files_zhj(x, y, z, sParaSetValue.nObjAddrU32) > 0)                                    {                                        bUpdateEquipFiles = TRUE;                                    }                				}                				                            	g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].unParaIdentify.nParaIden = nParaIden;                                g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState = 0xaa;                				g_nParaFixedFlagZhj[x][y][z][nFixedAreaID] = 1;                                rtn =  TRUE;                				FRAME104_FMT_TRACE("para_set_operate_zhj() 参数固化接受! 定值区号nFixedAreaID=%d, 参数标识nParaIden=%02x, 当前状态nSetState=%02x \n",                 					nFixedAreaID, nParaIden, g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState);                            }                            break;                        }                        case PARA_STOP://-参数预置撤销-                        {                            if(g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState != 0x55)//-未预置，返回失败-                            {                                rtn =  FALSE;                				FRAME104_FMT_TRACE("para_set_operate_zhj() 参数取消预置拒绝!请先预置! 定值区号nFixedAreaID=%d, 参数标识nParaIden=%02x, 当前状态nSetState=%02x \n",                 					nFixedAreaID, nParaIden, g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState);                            }                            else                            {                            	g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].unParaIdentify.nParaIden = nParaIden;                                g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState = 0xaa;                                rtn = TRUE;                				FRAME104_FMT_TRACE("para_set_operate_zhj() 参数取消预置接受! 定值区号nFixedAreaID=%d, 参数标识nParaIden=%02x, 当前状态nSetState=%02x \n",                 					nFixedAreaID, nParaIden, g_aFixedValueAreaZhj[nFixedAreaID][IdenArrIdx].nSetState);                            }                            break;                        }                        default:                            rtn = FALSE;                            break;                    }                }            }        }    }    if(bUpdatePrivateFile)    {        //跑配电误差台体有设置参数，但是没有设回默认值，导致重新跑的时候读取默认值参数不过，可以删除参数文件        int ret = -1;        FRAME104_FMT_TRACE("para_set_operate_zhj() 参数变更, 重新保存私有文件! \n");        ret = fixed_para_value_write_zhj(nFixedAreaID, (char *)&g_aParaSetValueZhj[nFixedAreaID][0], sizeof(g_aParaSetValueZhj[nFixedAreaID]));        FRAME104_FMT_DEBUG("重写本地定值参数 定值区号=%d, MaxLen=%u, 结果ret=%d \n", nFixedAreaID, sizeof(g_aParaSetValueZhj[nFixedAreaID]), ret);    }    if(bUpdateReportTask)    {        FRAME104_FMT_TRACE("para_set_operate_zhj() 参数变更, 导致更新上报方案和任务! \n");        timing_task_create_zhj();    }    if(bUpdateEquipFiles)    {        FRAME104_FMT_TRACE("para_set_operate_zhj() 参数变更, 导致更新设备档案! \n");        equip_files_save_zhj();    }        return rtn;}/******************************************************************************** 函数名称: datetime_s_to_buf_zhj* 函数功能: 时间转为BCD码格式* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/void datetime_s_to_buf_zhj(OOP_DATETIME_S_T tmVal, uint32 *offset, uint8 *apduValue){    apduValue[(*offset)++] = (tmVal.year>>8)&0xff;    apduValue[(*offset)++] = tmVal.year&0xff;    apduValue[(*offset)++] = tmVal.month;    apduValue[(*offset)++] = tmVal.day;    apduValue[(*offset)++] = tmVal.hour;    apduValue[(*offset)++] = tmVal.minute;    apduValue[(*offset)++] = tmVal.second;    return;}/*********************************************************************** @name      : systime_set_to_smiOS* @brief     ：向系统管理器发送对时命令* @param[in] ：* @return    ：* @Date      ：2020-3-18* @Update    :**********************************************************************/int systime_set_to_smiOS_zhj(DateTimeHex_t *pDateTime){    uint8  sendbuf[100] = {0};    uint8  recvbuf[32] = {0};    uint16 recLen = 0;    uint16 offset = 0;    int    ret = 0;    int    nRet = 0;    struct tm systime;    struct  timeval tv;    struct  timezone tz;    uint16  year;    uint16  msec;    sendbuf[offset++] = pDateTime->year_h;    sendbuf[offset++] = pDateTime->year_l;    sendbuf[offset++] = pDateTime->month;    sendbuf[offset++] = pDateTime->day;    sendbuf[offset++] = 0;    sendbuf[offset++] = pDateTime->hour;    sendbuf[offset++] = pDateTime->min;    sendbuf[offset++] = pDateTime->sec;    sendbuf[offset++] = 0;    sendbuf[offset++] = 0;    gettimeofday(&tv, &tz);    FastSecondToDate(&tv, &tz, &systime);        year = systime.tm_year + 1900;    MEMCPY_R(sendbuf + offset, &year, 2);    offset += 2;    sendbuf[offset++] = systime.tm_mon + 1;    sendbuf[offset++] = systime.tm_mday;    sendbuf[offset++] = systime.tm_wday;    sendbuf[offset++] = systime.tm_hour;    sendbuf[offset++] = systime.tm_min;    sendbuf[offset++] = systime.tm_sec;    msec = tv.tv_usec / 1000;    MEMCPY_R(sendbuf + offset, &msec, 2);    offset += 2;    FRAME104_BUF_DEBUG(sendbuf, offset, "systime_set_to_smiOS_zhj() 对时内容:");    ret = appPd_send_syncmsg(MSG_APPAMIN_RCT, sendbuf, offset, recvbuf, 32, &recLen);    if ((ret != ERR_OK) || (recLen != 1) || (recvbuf[0] != 1))    {        FRAME104_FMT_DEBUG("appPd_send_syncmsg() err! ret = %d, recLen = %d, recvbuf[0] = %x\n", ret, recLen, recvbuf[0]);        nRet = ERR_NORMAL;    }    else    {        nRet = ERR_OK;    }        return nRet;}/************************************************************************ @brief：     设置系统时间* @param[in]： pDateTime:      DateTime_s格式时间入口地址* @param[out]：* @return：    =TRUE            - 成功               =FLASE           - 错误码**********************************************************************/BOOL systime_set_zhj(DateTimeHex_t *pDateTime){    int iRet = 0;    int year = 0;    year = (uint16)pDateTime->year_l + (uint16)(pDateTime->year_h<<8);    FRAME104_FMT_DEBUG("systime_set_zhj() start set time modify time: %d-%d-%d %d:%d:%d\n",        year, pDateTime->month, pDateTime->day, pDateTime->hour, pDateTime->min, pDateTime->sec);    iRet = systime_set_to_smiOS_zhj(pDateTime);    if (iRet != ERR_OK)    {        FRAME104_FMT_DEBUG("systime_set_zhj() set time err\n");        return FALSE;    }    FRAME104_FMT_DEBUG("systime_set_zhj() set time ok\n");    return TRUE;}/******************************************************************************** 函数名称: i_frame_data_unpack* 函数功能: 104完整报文详细解帧* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int i_frame_data_unpack_zhj(uint16 nFrameLen, uint8 *pFrameBuff, uint8 *pOutBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	int result = 0;		//uint8 nSendTI = 0;	//uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nSendPubAddr = 0;	uint8 nBackInObjLen = 0;//用于备份    uint8 nSendInObjLen = 0;//用于组发送报文	uint8 pBackInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于备份	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文	TOTAL_104_FRAME_T stTotal104Frame;	memset(&stTotal104Frame, 0, sizeof(TOTAL_104_FRAME_T));	memcpy(&stTotal104Frame, pFrameBuff, nFrameLen);	*pAppType = APP_TYPE_NOMMAL;	if(stTotal104Frame.nLength < CTRL_UNIT_LABEL_LEN)	{		FRAME104_FMT_TRACE("i_frame_data_unpack() if(stTotal104Frame.nLength < CTRL_UNIT_LABEL_LEN) nFrameLen:%d \n", stTotal104Frame.nLength);		return -1;	}    nBackInObjLen = stTotal104Frame.nLength - CTRL_UNIT_LABEL_LEN;  //信息体长度	nSendInObjLen = stTotal104Frame.nLength - CTRL_UNIT_LABEL_LEN;  //信息体长度	memcpy(pBackInObjBuff, &pFrameBuff[APCI_UNIT_LABEL_LEN], nBackInObjLen);  //拷贝信息体内容	memcpy(pSendInObjBuff, &pFrameBuff[APCI_UNIT_LABEL_LEN], OBJ_ADDR_LEN);  //拷贝信息体地址内容	switch (stTotal104Frame.nDataType)	{	    case C_IC_NA_1://总召唤 100,激活或停止激活		{		    if(stTotal104Frame.nTransCauseL == CAUSE_ACT)			{				nSendCOT = CAUSE_ACTCON;				pSendInObjBuff[OBJ_ADDR_LEN] = 0x14;				nSendInObjLen = OBJ_ADDR_LEN + 1;			}			else if(stTotal104Frame.nTransCauseL == CAUSE_DEACT)			{				nSendCOT = CAUSE_DEACTCON;				pSendInObjBuff[OBJ_ADDR_LEN] = 0x14;				nSendInObjLen = OBJ_ADDR_LEN + 1;				g_bAllDataCallFlag = 0;//总召唤结束			}			else 			{				nSendCOT  =  ERROR_CAUSE|0x40;			}            nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);			nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			if(nOutbufLen > 0)			{				g_bAllDataCallFlag = ((nSendCOT&0xff) == CAUSE_ACTCON ? 1 : 0);//总召唤激活				if(g_bAllDataCallFlag == 1)                {                    check_call_all_addr_zhj(nSendPubAddr);                }			}			g_sTaskReportPipe.nAllDataCallPipe = g_nGlobalPipe;			break;		}	    case C_CI_NA_1://电能量召唤命令 101		{			pSendInObjBuff[OBJ_ADDR_LEN] = 0x05;   //累计量召唤限定词			nSendInObjLen = OBJ_ADDR_LEN + 1;			if(stTotal104Frame.nTransCauseL == CAUSE_ACT)			{				nSendCOT = CAUSE_ACTCON;			}			else 			{				//返回未知的传送原因				nSendCOT = ERROR_CAUSE|0x0040;			}            nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);			nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			if((nOutbufLen > 0)&&((nSendCOT&0xff) == CAUSE_ACTCON))			{				g_nElecDataCallFlag = 1;                if(g_nElecDataCallFlag == 1)                {                    check_call_energy_addr_zhj(nSendPubAddr);                }			}			g_sTaskReportPipe.nEnDataCallPipe = g_nGlobalPipe;			break;		}        case C_CS_NA_1://时钟同步 103		{			/*			struct tm			 {			   int tm_sec;           //Seconds. [0-60] (1 leap second)			   int tm_min;           //Minutes. [0-59]			   int tm_hour;          //Hours.   [0-23]			   int tm_mday;          //Day.     [1-31]			   int tm_mon;           //Month.   [0-11]			   int tm_year;          //Year - 1900.			   int tm_wday;          //Day of week. [0-6]			   int tm_yday;          //Days in year.[0-365]			   int tm_isdst;         //DST.     [-1/0/1]			}			*/			uint8 bfgTimeErr = 0;			int nSetResult = 0;            uint32 offset = 0;            uint8 aTime[7] = {0};            OOP_DATETIME_S_T stSetTime = {0};            DateTimeHex_t dateHex = {0};            //公共地址            nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);            			if(stTotal104Frame.nTransCauseL == CAUSE_ACT)			{				bfgTimeErr = time_check(&pBackInObjBuff[OBJ_ADDR_LEN + 2]);//时钟有效性判断				if(bfgTimeErr)//时钟格式正确				{					memcpy(aTime, &pBackInObjBuff[OBJ_ADDR_LEN], 7);//上送基准时间                    cp56time2a_to_ooptm(aTime, &stSetTime);                    FRAME104_FMT_DEBUG("时钟同步 %d-%d-%d %d:%d:%d \n", stSetTime.year, stSetTime.month,                                             stSetTime.day, stSetTime.hour, stSetTime.minute,                                             stSetTime.second);                    datetime_s_to_buf_zhj(stSetTime, &offset, (uint8 *)&dateHex);                    FRAME104_FMT_DEBUG("dateHex.year = 0x%02x\n", dateHex.year_h);                    FRAME104_FMT_DEBUG("dateHex.year = 0x%02x\n", dateHex.year_l);                    FRAME104_FMT_DEBUG("dateHex.month = %d\n", dateHex.month);                    FRAME104_FMT_DEBUG("dateHex.day = %d\n", dateHex.day);                    FRAME104_FMT_DEBUG("dateHex.hour = %d\n", dateHex.hour);                    FRAME104_FMT_DEBUG("dateHex.minute = %d\n", dateHex.min);                    FRAME104_FMT_DEBUG("dateHex.second = %d\n", dateHex.sec);                    if ((dateHex.month > 12)                     ||(dateHex.day > 31)                    ||(dateHex.month == 2 && dateHex.day > 29)                    ||(dateHex.hour > 23)                    ||(dateHex.min > 59)                    ||(dateHex.sec > 59))                    {                        FRAME104_FMT_DEBUG("dateHex 错误! \n");                    }                    else                    {                        nSetResult = systime_set_zhj((DateTimeHex_t*)&dateHex);                        FRAME104_FMT_DEBUG("systime_set_zhj() nSetResult=%d \n", nSetResult);                    }                                        nSendCOT = CAUSE_ACTCON;                    g_nTimeSynPubAddrZhj = nSendPubAddr;//时钟同步公共地址					g_bTimerSynFlag = 1; //已时钟同步标志					memcpy(pSendInObjBuff, pBackInObjBuff, nSendInObjLen);					nSendInObjLen = OBJ_ADDR_LEN + 7;				}				else				{					nSendCOT = CAUSE_ACTCON|0x40;				}							}            else if(stTotal104Frame.nTransCauseL == CAUSE_REQ)//请求或被请求            {                //返回当前时间                nSendCOT = CAUSE_REQ;                system_time_get(&pSendInObjBuff[OBJ_ADDR_LEN]);                cp56time2a_to_ooptm(&pSendInObjBuff[OBJ_ADDR_LEN], &stSetTime);                FRAME104_FMT_DEBUG("当前时间 %d-%d-%d %d:%d:%d \n", stSetTime.year, stSetTime.month,                                         stSetTime.day, stSetTime.hour, stSetTime.minute,                                         stSetTime.second);                nSendInObjLen = OBJ_ADDR_LEN + 7;            }			else 			{				//返回未知的传送原因				nSendCOT = ERROR_CAUSE|0x0040;			}			nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			g_sTaskReportPipe.nTimeSynPipe = g_nGlobalPipe;			break;		}        case C_SR_NA_1: //200，网最新实施细则参数切换定值区号类型标识		{ 		    //这里暂时没有考虑后续的参数切换过程及应用		    uint16 AreaID = 0;		    nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);			if((stTotal104Frame.nTransCauseL&0xff) == CAUSE_ACT)			{   				nSendCOT = CAUSE_ACTCON;                memcpy(&AreaID, &pBackInObjBuff[3], 2);//切换之后的定值区号				if(AreaID >= MAX_FIXED_AREA_NUM)				{					nSendCOT = nSendCOT|0x0040;				}					else				{				    if(check_set_area_addr_zhj(nSendPubAddr, pBackInObjBuff[4]) < 0)                    {                        nSendCOT = nSendCOT|0x0040;                    }				}			}			else 			{				//返回未知的传送原因				nSendCOT = ERROR_CAUSE|0x0040;			}		    nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			break;		}        case C_RR_NA_1://201,最新实施细则参数读定值区号类型标识		{ 		    //这里暂时没有考虑根据公共地址查询定值区号		    uint16 CurrAreaID = 0;            uint16 MinAreaID = 0;            uint16 MaxAreaID = MAX_AREA_NUM_ZHJ-1;			nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);			if((stTotal104Frame.nTransCauseL&0xff) == CAUSE_ACT)			{			    if(check_get_area_addr_zhj(nSendPubAddr, &CurrAreaID) > 0)                {                    nSendCOT = CAUSE_ACTCON;    				memset((char *)pSendInObjBuff, 0, 3); //信息体地址为0    				memcpy(&pSendInObjBuff[3], &CurrAreaID, 2);//当前定值区号    				memcpy(&pSendInObjBuff[5], &MinAreaID, 2);//最小定值区号    				memcpy(&pSendInObjBuff[7], &MaxAreaID, 2);//最大定值区号    				nSendInObjLen = 9;                }                else                {                    //返回未知的传送原因				    nSendCOT = ERROR_CAUSE|0x0040;                }			}			else 			{				//返回未知的传送原因				nSendCOT = ERROR_CAUSE|0x0040;			}		    nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			break;		}        case C_RS_NA_1://202,最新实施细则读单个或多个定值/参数		{ 		    int ret = -1;			nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);			if((stTotal104Frame.nTransCauseL&0xff) == CAUSE_ACT)			{			    if(stTotal104Frame.nVSQ > 0)//读多个参数和定值                {                    nSendCOT = CAUSE_ACTCON;                    g_bSomeParaCallFlag = 1;                    memcpy(&g_nSomeParaCallAreaIdZhj, pBackInObjBuff, 2);//没有信息体地址                    if(g_nSomeParaCallAreaIdZhj >= MAX_FIXED_AREA_NUM)                    {                        ret = -1;                    }                    else                    {                        FRAME104_FMT_DEBUG("部分参数召测 定值区号=%d \n", g_nSomeParaCallAreaIdZhj);                        ret = check_call_some_para_addr_zhj(nSendPubAddr);                        if(ret > 0)                        {                            ret = check_call_some_para_info_zhj(&pBackInObjBuff[2], nBackInObjLen-2);                        }                    }                }                else//读全部参数和定值                {                    nSendCOT = CAUSE_ACTCON;                    g_bAllParaCallFlag = 1;                    memcpy(&g_nAllParaCallAreaIdZhj, pBackInObjBuff, 2);//没有信息体地址                    if(g_nAllParaCallAreaIdZhj >= MAX_FIXED_AREA_NUM)                    {                        ret = -1;                    }                    else                    {                        FRAME104_FMT_DEBUG("所有参数召测 定值区号=%d \n", g_nAllParaCallAreaIdZhj);                        ret = check_call_all_para_addr_zhj(nSendPubAddr);                    }                }                			    if(ret < 0)                {                    //返回未知的传送原因				    nSendCOT = ERROR_CAUSE|0x0040;                }			}			else 			{				//返回未知的传送原因				nSendCOT = ERROR_CAUSE|0x0040;			}		    //nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			break;		}        case C_WS_NA_1:  //203,最新实施细则写单个或多个定值/参数类型标识		{			uint8  nObjNum = 0;  //信息体元素个数			FIXED_AREA_IDEN_T sFixedAreaIden;  //定值区特征标识结构体			PARA_SET_VALUE_T  sParaSetValue;   //设置参数结构体			memset(&sFixedAreaIden, 0, sizeof(FIXED_AREA_IDEN_T));			memset(&sParaSetValue, 0, sizeof(PARA_SET_VALUE_T));			memcpy(pSendInObjBuff, pBackInObjBuff, nSendInObjLen);  //定值区号2字节，参数标识1字节，后面是信息体内容            nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);						if((stTotal104Frame.nTransCauseL&0xff) == CAUSE_ACT)//参数预置/固化			{				if(pSendInObjBuff[2]&0x80)//预置				{				    check_para_oper_addr_zhj(nSendPubAddr);					nObjNum = stTotal104Frame.nVSQ;  //预置：对应信息元素个数；固化/撤销：0x00					result = para_set_operate_zhj(nObjNum, pBackInObjBuff, nSendInObjLen, PARA_SELECT);					*pAppType = APP_TYPE_CTRL_SELECT_ACK;//参数预置确认				}				else//固化				{				    check_para_oper_addr_zhj(nSendPubAddr);					nObjNum = stTotal104Frame.nVSQ;  //预置：对应信息元素个数；固化/撤销：0x00					result = para_set_operate_zhj(nObjNum, pBackInObjBuff, nSendInObjLen, PARA_RUN);				}				if(TRUE == result)				{					nSendCOT = CAUSE_ACTCON;				}				else				{					nSendCOT = CAUSE_ACTCON|0x40;				}			}			else if((stTotal104Frame.nTransCauseL&0xff) == CAUSE_DEACT)//参数预置撤销			{				if(pSendInObjBuff[2]&0x40)//取消预置				{				    check_para_oper_addr_zhj(nSendPubAddr);					nObjNum = stTotal104Frame.nVSQ;  //预置：对应信息元素个数；固化/撤销：0x00					result = para_set_operate_zhj(nObjNum, pBackInObjBuff, nSendInObjLen, PARA_STOP);				}				if(result == TRUE)                {					nSendCOT = CAUSE_DEACTCON;				}                else                {					nSendCOT = CAUSE_DEACTCON|0x40;				}			}			else//未知的COT			{				nSendCOT  =  ERROR_CAUSE|0x40;			}					    nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			break;		}        case C_TC_NA_ZHJ_1://任务召唤 204,激活或停止激活		{		    if(stTotal104Frame.nTransCauseL == CAUSE_ACT)			{				nSendCOT = CAUSE_ACTCON;                g_bTaskCallFlag = 1;//激活任务召测			}			else if(stTotal104Frame.nTransCauseL == CAUSE_DEACT)			{				nSendCOT = CAUSE_DEACTCON;				g_bTaskCallFlag = 0;//任务召唤结束			}			else 			{				nSendCOT  =  ERROR_CAUSE|0x40;			}            nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);            memcpy(pSendInObjBuff, pBackInObjBuff, nBackInObjLen);  //拷贝信息体地址内容            nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			g_sTaskReportPipe.nTaskCallPipe = g_nGlobalPipe;			check_call_task_addr_zhj(nSendPubAddr, pBackInObjBuff, nBackInObjLen);			break;		}        case C_PC_NA_ZHJ_1://点召唤 205,激活或停止激活		{		    if(stTotal104Frame.nTransCauseL == CAUSE_ACT)			{				nSendCOT = CAUSE_ACTCON;				nSendInObjLen = OBJ_ADDR_LEN;                memset(pSendInObjBuff, 0x00, nSendInObjLen);			}			else if(stTotal104Frame.nTransCauseL == CAUSE_DEACT)			{				nSendCOT = CAUSE_DEACTCON;				nSendInObjLen = OBJ_ADDR_LEN;				g_bPointCallFlag = 0;//点召唤结束			}			else 			{				nSendCOT  =  ERROR_CAUSE|0x40;			}            nSendPubAddr = stTotal104Frame.nPubAddrL + (uint16)((stTotal104Frame.nPubAddrH << 8) & 0xff00);			nOutbufLen = i_frame_data_pack_zhj(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, nSendPubAddr, pSendInObjBuff, nSendInObjLen, pOutBuf);			if(nOutbufLen > 0)			{				g_bPointCallFlag =  ((nSendCOT&0xff) == CAUSE_ACTCON ? 1 : 0);//点召唤激活				if(g_bPointCallFlag == 1)                {                    check_call_point_addr_zhj(nSendPubAddr);                    check_call_point_info_zhj(pBackInObjBuff, nBackInObjLen);                }			}			g_sTaskReportPipe.nPointCallPipe = g_nGlobalPipe;			break;		}		default:		{			nSendCOT  =  ERROR_TYPE|0x40;//未知的数据标识，且是否认回答			nOutbufLen = i_frame_data_pack(stTotal104Frame.nDataType, stTotal104Frame.nVSQ, nSendCOT, pSendInObjBuff, nSendInObjLen, pOutBuf);			break;		}	}	return nOutbufLen;}/******************************************************************************** 函数名称: report_task_create* 函数功能: 创建上报任务* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int report_task_create_zhj(){	//FRAME104_FMT_TRACE("report_task_create() 创建上报任务... \n");		if(g_nNetWorkFlag != PRO_DATA_TRANSMIT)	{		//通信控制变量初始化        g_bDataSendFlag        = 0;		//全局可以发送数据的标志		g_bNetTestFlag 	       = 0;		//链路测试使能		g_nIFrameT1Count	   = 0;		/*帧未收到确认回答的最大延时时间*/			g_nIFrameT2Count	   = 0;		//链路测试最大间隔时间		g_nNoneActIFramTimes   = 0;		/*发送I帧未收到确认帧的次数*/		g_nIFramRecvTimes	   = 0;		/*收到I帧的帧数量*/ 			g_nIFramSendTimes	   = 0;		/*I帧发送帧数量*/		g_bAllDataCallFlag	   = 0;		/*清总召唤使能标志*/        g_bPointCallFlag	   = 0;		/*清点召唤使能标志*/        g_bTaskCallFlag	       = 0;		/*清任务召唤使能标志*/        g_bAllParaCallFlag	   = 0;		/*清全部参数召唤使能标志*/        g_bSomeParaCallFlag	   = 0;		/*清部分参数召唤使能标志*/		g_nElecDataCallFlag	   = 0;		/*电能召唤标志位*/		g_bYCYXChangeSendFlag  = 0;	    /*遥测数据变化上报使能标志,在连接成功且上报过总召唤后打开*/		g_bTimerSynFlag		   = 0;		/*时钟同步标志，在主站发生时钟同步后置位*/		g_nRtuResetFlag		   = 0;		/*进程初始化标志*/		g_sTaskRunStep.nTaskStep			  = STEP_CONT_DEFAULT;	/*任务进程控制标志*/		return -1;	}	//过秒检测	if(g_unPastTimeFlag.BitSect.Second == TRUE)	{		//遥控预置标志置位，如果超过60秒未执行遥控执行，取消预置		yk_state_cyc_check();		//三个超时参数t1_t2_t3循环检测		t1_t2_t3_cyc_check();	}	//接收到主站允许通讯发送应用层数据后开始检验以下流程	if(1)//if(g_bDataSendFlag == 2)    {		if(g_sTaskRunStep.nTaskStep == STEP_CONT_DEFAULT)//首先判断当前任务是否空闲        {            if(g_sTaskRunStep.bFirstRun == 1 )            {                g_sTaskRunStep.bFirstRun = 0;				            }            else if(g_nRtuResetFlag)            {            	//system("reboot");            	g_nRtuResetFlag = 0;                FRAME104_FMT_TRACE("report_task_create() 终端复位 reboot... \n");            }            else if (g_aCtrlReSendBuff[0] == 0x55)//遥控命令应答报文            {                g_sTaskRunStep.nTaskStep = STEP_REMOTE_CTRL_ACK;                g_aCtrlReSendBuff[0] = 0xaa;            }            else if (g_bYxChanged /*&& g_bYCYXChangeSendFlag*/)//是否有soe事件上报            {                g_sTaskRunStep.nTaskStep = STEP_SOE_CHANGE_SEND;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                next_changed_yx_eq_zhj();//获取第一个变化遥信主动上报的设备            }			else if (g_bFaultChanged /*&& g_bYCYXChangeSendFlag*/)//是否有故障信息事件上报			{				g_sTaskRunStep.nTaskStep = STEP_FAULT_CHANGE_SEND;				g_bFaultChanged = 0;			}            else if(g_bTimerSynFlag == 1)//时钟同步            {                g_bTimerSynFlag = 2;                g_sTaskRunStep.nTaskStep = STEP_TIMER_SYN;            }            else if(g_nDataReadFlagOrAddr)//读数据            {                g_sTaskRunStep.nTaskStep = STEP_DATA_READ;            }            else if(g_bAllDataCallFlag)//是否有总召唤            {            	g_sTaskRunStep.nTaskStep = STEP_ALL_DATA_CALL_ALL;                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YX;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                get_next_equip_yx_zhj();//获取第一个总召唤上报遥信的设备            }            else if(g_bPointCallFlag)//是否有点召唤            {            	g_sTaskRunStep.nTaskStep = STEP_POINT_DATA_CALL;                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YX;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                get_next_point_equip_yx_zhj();//获取第一个总召唤上报遥信的设备            }            else if(g_bTaskCallFlag)//是否有任务召唤            {            	g_sTaskRunStep.nTaskStep = STEP_TASK_DATA_CALL;                g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                g_sTaskRunStep.nFinishFlag = 0;                move_to_next_call_task_zhj(TASK_DATA_FROZEN);//获取第一个任务召唤上报遥信的设备            }            /*            else if(g_bYcChanged && g_bYCYXChangeSendFlag)//是否有变化遥测数据上报            {                g_sTaskRunStep.nTaskStep = STEP_YC_CHANGE_SEND;				g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_R;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R);//获取第一个变化遥测主动上报的设备            }            */            else if(g_nElecDataCallFlag)//电能召唤标志位            {                g_sTaskRunStep.nTaskStep = STEP_ENN_DATA_CALL_ALL;                g_sTaskRunStep.nDataCallStep = ENDATA_STEP_SEND_AC;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                get_next_equip_en_zhj();//获取第一个电量召唤上报的设备            }            else if(g_bAllParaCallFlag)//所有参数召唤标志位            {                g_sTaskRunStep.nTaskStep = STEP_ALL_PARA_CALL;                g_sTaskRunStep.nDataCallStep = PARA_DATA_STEP_SEND;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                get_next_equip_all_para_zhj();//获取第一个参数召唤上报的设备            }            else if(g_bSomeParaCallFlag)//部分参数召唤标志位            {                g_sTaskRunStep.nTaskStep = STEP_SOME_PARA_CALL;                g_sTaskRunStep.nDataCallStep = PARA_DATA_STEP_SEND;                g_sTaskRunStep.nEquipTypeIndex = 0;                g_sTaskRunStep.nEquipGroupIndex = 0;                g_sTaskRunStep.nEquipNoIndex = 0;                get_next_equip_some_para_zhj();//获取第一个参数召唤上报的设备            }			else if(g_nParaDataStep)//参数上送			{				g_sTaskRunStep.nTaskStep = STEP_PARA_RES_ACK0;				g_nParaDataStep = 0;			}			else if (g_nParaGetFlag)//参数读取后续处理            {                g_sTaskRunStep.nTaskStep =  STEP_NEW_PARA_CALL_ACK;            }			else if(g_bAckRecvFlag == 1)//链路接收应答s帧发送标志			{				g_sTaskRunStep.nTaskStep = STEP_IDEL_ACK_SEND;				g_bAckRecvFlag = 0;			}	            else            {            	g_bNetTestFlag = 1;            }        }		else		{			g_bNetTestFlag = 0;		}    }	else if (g_bDataSendFlag == 1)	{		g_bDataSendFlag        = 2 ;	//全局可以发送数据的标志		g_bNetTestFlag 	       = 0;		//链路测试使能		g_nIFrameT1Count	   = 0;		/*帧未收到确认回答的最大延时时间*/			g_nIFrameT2Count	   = 0;		//链路测试最大间隔时间		g_nNoneActIFramTimes   = 0;		/*发送I帧未收到确认帧的次数*/		g_nIFramRecvTimes	   = 0;		/*收到I帧的帧数量*/ 			g_nIFramSendTimes	   = 0;		/*I帧发送帧数量*/		g_bAllDataCallFlag	   = 0;		/*清总召唤使能标志*/        g_bPointCallFlag	   = 0;		/*清点召唤使能标志*/        g_bTaskCallFlag	       = 0;		/*清任务召唤使能标志*/        g_bAllParaCallFlag	   = 0;		/*清全部参数召唤使能标志*/        g_bSomeParaCallFlag	   = 0;		/*清部分参数召唤使能标志*/		g_nElecDataCallFlag	   = 0;		/*电能召唤标志位*/		g_bYCYXChangeSendFlag  = 0;	    /*遥测数据变化上报使能标志,在连接成功且上报过总召唤后打开*/		g_bTimerSynFlag		   = 0;		/*时钟同步标志，在主站发生时钟同步后置位*/		g_nRtuResetFlag		   = 0;		/*进程初始化标志*/		g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;	/*任务进程控制标志*/	}    else    {        g_sTaskRunStep.nTaskStep   = STEP_CONT_DEFAULT;    }	return 1;}/******************************************************************************** 函数名称: get_next_equip_yx_zhj* 函数功能: 获取下一个需要上报总召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_equip_yx_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)        {            for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)            {                if(g_aAllCallEquipStateYX[i][z][j] == 1)                {                    g_sTaskRunStep.nEquipTypeIndex = i;                    g_sTaskRunStep.nEquipGroupIndex = z;                    g_sTaskRunStep.nEquipNoIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }                nowEqGroupIndex = 0;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: get_next_equip_en_zhj* 函数功能: 获取下一个需要上报电量召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_equip_en_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)        {            for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)            {                if(g_aEnergyCallEquipState[i][z][j] == 1)                {                    g_sTaskRunStep.nEquipTypeIndex = i;                    g_sTaskRunStep.nEquipGroupIndex = z;                    g_sTaskRunStep.nEquipNoIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }                nowEqGroupIndex = 0;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: get_next_equip_all_para_zhj* 函数功能: 获取下一个需要上报所有参数召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_equip_all_para_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)        {            for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)            {                if(g_aAllParaEquipState[i][z][j] == 1)                {                    g_sTaskRunStep.nEquipTypeIndex = i;                    g_sTaskRunStep.nEquipGroupIndex = z;                    g_sTaskRunStep.nEquipNoIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }                nowEqGroupIndex = 0;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: get_next_equip_some_para_zhj* 函数功能: 获取下一个需要上报部分参数召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_equip_some_para_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)        {            for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)            {                if(g_aSomeParaCallEquipState[i][z][j] == 1)                {                    g_sTaskRunStep.nEquipTypeIndex = i;                    g_sTaskRunStep.nEquipGroupIndex = z;                    g_sTaskRunStep.nEquipNoIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }                nowEqGroupIndex = 0;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: get_next_equip_yc_zhj* 函数功能: 获取下一个需要上报总召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_equip_yc_zhj(uint8 yctype){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;    switch(yctype)    {        case ALLDATA_STEP_SEND_R:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aAllCallEquipStateYC_R[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;        case ALLDATA_STEP_SEND_R_T:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aAllCallEquipStateYC_R_T[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;                case ALLDATA_STEP_SEND_STR:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aAllCallEquipStateYC_STR[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;                default:            break;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: get_next_point_equip_yx_zhj* 函数功能: 获取下一个需要上报点召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_point_equip_yx_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)        {            for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)            {                if(g_aPointCallEquipStateYX[i][z][j] == 1)                {                    g_sTaskRunStep.nEquipTypeIndex = i;                    g_sTaskRunStep.nEquipGroupIndex = z;                    g_sTaskRunStep.nEquipNoIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }                nowEqGroupIndex = 0;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: get_next_point_equip_yc_zhj* 函数功能: 获取下一个需要上报点召唤数据的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int get_next_point_equip_yc_zhj(uint8 yctype){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;    switch(yctype)    {        case ALLDATA_STEP_SEND_R:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aPointCallEquipStateYC_R[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;        case ALLDATA_STEP_SEND_R_T:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aPointCallEquipStateYC_R_T[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;        case ALLDATA_STEP_SEND_R_EN:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aPointCallEquipStateYC_R_EN[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;                case ALLDATA_STEP_SEND_STR:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<g_aGroupCountZhj[i]; z++)                {                    for(j=nowEqNoIndex; j<g_aEquipCountZhj[i][z];j++)                    {                        if(g_aPointCallEquipStateYC_STR[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;                default:            break;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/*********************************************************************所属功能单元：yx_total_get功能描述	：获取总招测时的遥信数据输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yx_total_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 bStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum = 0;	uint8 bgetnum = 0;	uint8 len = 0;	uint8 index = 0;    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYxDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum = bStartNum;	bgetnum = *pGetNum;	*pGetNum = 0; 	if(startnum>= g_nConfigYxNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum; i<g_nConfigYxNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		//信息体地址		memcpy(addr, &g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);		pData[index++] = addr[0];		pData[index++] = addr[1];		if(bAdulen == 3)		{			pData[index++] = addr[2];		}		//单点遥信数值		pData[index++] = g_aYxDataSendZhj[ArrIdx+i].nNewValue;		//修改发送状态		g_aYxDataSendZhj[ArrIdx+i].nHisValue = g_aYxDataSendZhj[ArrIdx+i].nNewValue;		g_aYxDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;		g_aYxDataSendZhj[ArrIdx+i].bSendFlag = TRUE;		FRAME104_FMT_TRACE("总召唤 yx_total_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, g_aYxDataSend[%d]: nNewValue=%d, nHisValue=%d, bChangeFlag=%d, bSendFlag=%d, 全局g_bYxChanged=%d \n", 			g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32, 			i, g_aYxDataSendZhj[ArrIdx+i].nNewValue, g_aYxDataSendZhj[ArrIdx+i].nHisValue, 			g_aYxDataSendZhj[ArrIdx+i].bChangeFlag, g_aYxDataSendZhj[ArrIdx+i].bSendFlag, g_bYxChanged);		        j++;		*pGetNum = j;		if(j >= bgetnum)			break;	}		len = index;	return len;}/*********************************************************************所属功能单元：yc_total_nva_get功能描述	：总召获取遥测量数据（归一化值）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_total_nva_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_nva_get() 总召获取遥测量数据（归一化值） \n");		int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数	float32 fNvaValue = 0;  //浮点型归一化值	int16 nValueNVA = 0;  //转换之后的归一化值    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType == M_ME_NA_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//归一化数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			fNvaValue = fConvertValue/g_aYcDataConfigZhj[ArrIdx+i].fFullValue;  //实际值除以满码值			//溢出检查			if(fNvaValue > (1-pow(2, -15)))			{				fNvaValue = 1-pow(2, -15);			}			else if(fNvaValue < (-1+pow(2, -15)))			{				fNvaValue = -1+pow(2, -15);			}			if(fNvaValue >= 0)			{				nValueNVA = (int16)(fNvaValue*pow(2, 15));			}			else			{				nValueNVA = (int16)(fNvaValue*pow(2, 15)*(-1));				nValueNVA = (int16)(nValueNVA*(-1));			}			memcpy((void *)&pData[index], (void *)&nValueNVA, sizeof(int16));			index += sizeof(int16);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("总召唤 遥测(归一化值)yc_total_nva_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_total_sva_get功能描述	：总召获取遥测量数据（标度化值）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_total_sva_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_sva_get() 总召获取遥测量数据（标度化值） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数	int16 nValueSVA;  //转换之后的标度化值    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType == M_ME_NB_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//标度化数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			//溢出检查			if(fConvertValue > 32767)			{				nValueSVA = 32767;			}			else if(fConvertValue < (-32768))			{				nValueSVA = (-32768);			}			else			{				nValueSVA = (int16)fConvertValue;			}			memcpy((void *)&pData[index], (void *)&nValueSVA, sizeof(int16));			index += sizeof(int16);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("总召唤 遥测(标度化值)yc_total_sva_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_total_r_get功能描述	：总召获取遥测量数据（短浮点数）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_total_r_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType == M_ME_NC_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+i].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("总召唤 遥测(短浮点数)yc_total_r_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_total_r_t_get_zhj功能描述	：总召获取遥测量数据（短浮点数 带时标）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_total_r_t_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType == M_ME_TF_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+i].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            //带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("总召唤 遥测(短浮点数 带时标)yc_total_r_t_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_total_str_get_zhj功能描述	：总召获取遥测量数据（比特串）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_total_str_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType == M_VBO_TB_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}            //比特串长度            pData[index++] = g_aYcDataConfigZhj[ArrIdx+i].nArrLen;            //比特串内容            memcpy(&pData[index], g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen);			index += g_aYcDataConfigZhj[ArrIdx+i].nArrLen;			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            //时标            system_time_get(&pData[index]);            index += 7;			//修改变化状态和发送状态			memcpy(g_aYcDataSendZhj[ArrIdx+i].aHisArrValue, g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen);			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("总召唤 遥测(比特串)yc_total_str_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, g_aYcDataSendZhj[ArrIdx+i].bSendFlag);            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen, "aNewArrValue:");            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+i].aHisArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen, "aHisArrValue:");            //判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_total_get功能描述	：获取总招测时的遥测数据输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_total_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	//int    result = 0;	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	//uint8 pBackInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于备份	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;	switch (g_sTaskRunStep.nSubDataCallSetp)	{		case ALLDATA_STEP_SEND_R://上报所有遥测信息（短浮点数）        {            nSendTI = M_ME_NC_1;            nSendCOT = CAUSE_INTROGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 25;  //单次上送信号的最大个数(255-12)/(3+4+1)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_total_r_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("总召上报所有遥测信息(短浮点数)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aAllCallEquipStateYC_R[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_all_equip_zhj(ALLDATA_STEP_SEND_R);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aAllCallEquipStateYC_R[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_all_equip_zhj(ALLDATA_STEP_SEND_R);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case ALLDATA_STEP_SEND_R_T://上报所有遥测信息（短浮点数 带时标）        {            nSendTI = M_ME_TF_1;            nSendCOT = CAUSE_INTROGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_total_r_t_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("总召上报所有遥测信息(短浮点数 带时标)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aAllCallEquipStateYC_R_T[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_all_equip_zhj(ALLDATA_STEP_SEND_R_T);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aAllCallEquipStateYC_R_T[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_all_equip_zhj(ALLDATA_STEP_SEND_R_T);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case ALLDATA_STEP_SEND_STR://上报所有遥测信息（比特串）        {            nSendTI = M_VBO_TB_1;            nSendCOT = CAUSE_INTROGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 10;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_total_str_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("总召上报所有遥测信息(比特串)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aAllCallEquipStateYC_STR[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_all_equip_zhj(ALLDATA_STEP_SEND_STR);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aAllCallEquipStateYC_STR[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_all_equip_zhj(ALLDATA_STEP_SEND_STR);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        default:            g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_STOP;            break;	}	*pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}/*********************************************************************所属功能单元： en_total_r_get_zhj功能描述	：电量召唤 获取电量数据（短浮点数）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 en_total_r_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType == M_IT_NB_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+i].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("电量召唤 遥测(短浮点数)en_total_r_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： en_total_get_zhj功能描述	：获取电量召测时的数据输入参数	：输出参数	：函数返回值	：*******************************************************************/int en_total_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	//int    result = 0;	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	//uint8 pBackInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于备份	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;    //组装电量报文	nSendTI  = M_IT_NB_1;    nSendCOT = CAUSE_REQCOGEN;    nPubAddr =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);    switch(g_sTaskRunStep.nDataCallStep)    {        case ENDATA_STEP_SEND_AC:        {            uint8 nSendNumMax = 25;  //单次上送信号的最大个数(255-12)/(3+4+1)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = en_total_r_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("电量召唤 上报所有电量信息(短浮点数)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aEnergyCallEquipState[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(get_next_equip_en_zhj() < 0)                {                    //-没有更多数据需要上报-                    //g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    //g_nElecDataCallFlag = 0;                    g_sTaskRunStep.nDataCallStep = ENDATA_STEP_SEND_STOP;                }            }            else if(bgetnum < nSendNumMax)            {                 g_aEnergyCallEquipState[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(get_next_equip_en_zhj() < 0)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-                    //g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    //g_nElecDataCallFlag = 0;                    g_sTaskRunStep.nDataCallStep = ENDATA_STEP_SEND_STOP;                }            }            else            {                //-数据未读取完，还要继续读取-                g_sTaskRunStep.nStartNum = nStartIndex;            }            nSendVSQ =  bgetnum;            break;        }        case ENDATA_STEP_SEND_STOP:        {            nSendVSQ = 1;            nSendTI = C_CI_NA_1;            nSendCOT = CAUSE_ACTTERM;            nSendInObjLen = 4;            memset(pSendInObjBuff, 0x00, MAX_INFO_OBJ_DATA_LEN);            pSendInObjBuff[3] = 0x05;   //累计召唤限定词            g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            g_nElecDataCallFlag = 0;            break;        }        default:        {            g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            g_nElecDataCallFlag = 0;            break;        }    }    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);    *pPipeIndex = nPipeIndex;    memcpy(pReportBuf, pOutBuff, nOutbufLen);    return nOutbufLen;}/*********************************************************************所属功能单元： para_total_all_get_zhj功能描述	：所有参数召唤 获取参数数据输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 para_total_all_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 len = 0;	uint8 index = 0;    uint8 tempBuff[250] = {0};//缓存参数    uint8 outIndex = 0;//返回区索引    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 nAreaId = g_nAllParaCallAreaIdZhj;    uint8 addr[4] = {0};//信息体地址    uint32 IdenArrIdx = 0;//定值区标识一维数组索引(起始)    IdenArrIdx = g_aFixedAreaIndexZhj[nAreaId][eqTpIndex][eqGroupIndex][eqNoIndex];    uint32 ParaArrIdx = 0;//定值参数一维数组索引(起始)    ParaArrIdx = g_aParaValueIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigParaNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}    //将数据填写返回区(定值区号+特征标识)    memcpy(&pData[outIndex], &g_nAllParaCallAreaIdZhj, 2);//定值区号    outIndex += 2;    pData[outIndex] = g_aFixedValueAreaZhj[nAreaId][IdenArrIdx].unParaIdentify.nParaIden;//参数特征标识    outIndex += 1;	//将数据填写返回区(信息体)	for(i=startnum_bk; i<g_nConfigParaNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		//信息体地址		memcpy(addr, &g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nObjAddrU32, 4);		tempBuff[index++] = addr[0];		tempBuff[index++] = addr[1];		if(bAdulen == 3)		{			tempBuff[index++] = addr[2];		}                //tag类型        tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType;        //数据长度(TAG_STRING 4和TAG_OCTSTRING 8, 浙江地区不一样)        if(TAG_STRING == g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType)        {            tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen+1;            //参数值            memcpy(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            index += g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen;            tempBuff[index++] = 0;//停止符        }        else if(TAG_OCTSTRING_ZHJ == g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType)        {            tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen;            //参数值            if(0x00008003 == g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nObjAddrU32)            {                //设备地址需要翻转上送                memcpy_r(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            }            else            {                memcpy(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            }                        index += g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen;        }        else        {            tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen;            //参数值            memcpy(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].unValue.arrayV,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen);            index += g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen;        }        		if( (outIndex+index) >= (250 - APCI_UNIT_LABEL_LEN))        {            i--;//回退一个            break;        }        else        {            FRAME104_FMT_TRACE("所有参数召唤 参数 para_total_all_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, tag=%d, datalen=%d, arrlen=%d \n", 			g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nObjAddrU32, 			i, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType, 			g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            FRAME104_BUF_TRACE(g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].unValue.arrayV, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen, "unValue.arrayV:");            FRAME104_BUF_TRACE(g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen, "aArrValue:");            //拷贝数据            memcpy(&pData[outIndex], &tempBuff[0], index);            outIndex += index;            index = 0;                		//信息体个数累计    		j++;            *pGetNum = j;        }			}	//计算下一次的起始位置	*pStartNum = i+1;		len = outIndex;	return len;}/*********************************************************************所属功能单元： en_total_get_zhj功能描述	：获取电量召测时的数据输入参数	：输出参数	：函数返回值	：*******************************************************************/int para_total_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;    //组装参数报文	nSendTI = C_RS_NA_1;    nSendCOT = CAUSE_ACTCON;    nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);	uint8 nSendNumMax = 25;  //单次上送信号的最大个数(255-12)/(3+4+1)    uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号    bgetnum = nSendNumMax;  //单次上送信号的最大个数    nSendInObjLen  = para_total_all_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);    FRAME104_FMT_TRACE("所有参数召唤 上报所有参数信息，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d, nStartIndex=%d \n",        g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum, nStartIndex);    if(bgetnum == 0)    {        g_aAllParaEquipState[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;        g_sTaskRunStep.nStartNum = 0;        if(get_next_equip_all_para_zhj() < 0)        {            //-没有更多数据需要上报-            g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            g_bAllParaCallFlag = 0;        }        return 0;    }	else	{		//-数据未读取完，还要继续读取-		g_sTaskRunStep.nStartNum = nStartIndex;	}    //nSendVSQ =  bgetnum;    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);    *pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}/*********************************************************************所属功能单元： para_total_all_get_zhj功能描述	：所有参数召唤 获取参数数据输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 para_some_all_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;//位于参数点表中的索引	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 len = 0;	uint8 index = 0;    uint8 tempBuff[250] = {0};//缓存参数    uint8 outIndex = 0;//返回区索引    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 nAreaId = g_nSomeParaCallAreaIdZhj;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//位于部分参数召唤的所有地址中索引    uint32 IdenArrIdx = 0;//定值区标识一维数组索引(起始)    IdenArrIdx = g_aFixedAreaIndexZhj[nAreaId][eqTpIndex][eqGroupIndex][eqNoIndex];    uint32 ParaArrIdx = 0;//定值参数一维数组索引(起始)    ParaArrIdx = g_aParaValueIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigParaNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}    //将数据填写返回区(定值区号+特征标识)    memcpy(&pData[outIndex], &g_nSomeParaCallAreaIdZhj, 2);//定值区号    outIndex += 2;    pData[outIndex] = g_aFixedValueAreaZhj[nAreaId][IdenArrIdx].unParaIdentify.nParaIden;//参数特征标识    outIndex += 1;    	for(addrIndex=startnum_bk; addrIndex<g_nSomeParaCallInfoAddrNum; addrIndex++)	{	    i = query_para_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, nAreaId, g_aSomeParaCallInfoAddr[addrIndex]);        {            if(i < 0)            {                continue;            }        }        		//信息体地址		memcpy(addr, &g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nObjAddrU32, 4);		tempBuff[index++] = addr[0];		tempBuff[index++] = addr[1];		if(bAdulen == 3)		{			tempBuff[index++] = addr[2];		}                //tag类型        tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType;        //数据长度(TAG_STRING和TAG_OCTSTRING的值均为4, 只用判断一个即可)        if(TAG_STRING == g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType)        {            tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen+1;            //参数值            memcpy(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            index += g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen;            tempBuff[index++] = 0;//停止符        }        else if(TAG_OCTSTRING_ZHJ == g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType)        {            tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen;            //参数值            if(0x00008003 == g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nObjAddrU32)            {                //设备地址需要翻转上送                memcpy_r(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            }            else            {                memcpy(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            }                        index += g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen;        }        else        {            tempBuff[index++] = g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen;            //参数值            memcpy(&tempBuff[index], g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].unValue.arrayV,                         g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen);            index += g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen;        }        		if( (outIndex+index) >= (250 - APCI_UNIT_LABEL_LEN))        {            addrIndex--;//回退一个            break;        }        else        {            FRAME104_FMT_TRACE("部分参数召唤 参数 para_some_all_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, tag=%d, datalen=%d, arrlen=%d \n", 			g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nObjAddrU32, 			i, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nTagType, 			g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen);            FRAME104_BUF_TRACE(g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].unValue.arrayV, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nDataLen, "unValue.arrayV:");            FRAME104_BUF_TRACE(g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].aArrValue, g_aParaSetValueZhj[nAreaId][ParaArrIdx+i].nArrLen, "aArrValue:");            //拷贝数据            memcpy(&pData[outIndex], &tempBuff[0], index);            outIndex += index;            index = 0;                		//信息体个数累计    		j++;            *pGetNum = j;        }			}	//计算下一次的起始位置	*pStartNum = addrIndex+1;		len = outIndex;	return len;}/*********************************************************************所属功能单元： en_total_get_zhj功能描述	：获取电量召测时的数据输入参数	：输出参数	：函数返回值	：*******************************************************************/int para_some_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = g_nSomeParaCallInfoAddrNum;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;    //组装参数报文	nSendTI = C_RS_NA_1;    nSendCOT = CAUSE_ACTCON;    nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);	uint8 nSendNumMax = 25;  //单次上送信号的最大个数(255-12)/(3+4+1)    uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号    bgetnum = nSendNumMax;  //单次上送信号的最大个数    nSendInObjLen  = para_some_all_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);    FRAME104_FMT_TRACE("部分参数召唤 上报所有参数信息，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d, nStartIndex=%d \n",        g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum, nStartIndex);    if(bgetnum == 0)    {        g_aSomeParaCallEquipState[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;        g_sTaskRunStep.nStartNum = 0;        if(get_next_equip_some_para_zhj() < 0)        {            //-没有更多数据需要上报-            g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            g_bSomeParaCallFlag = 0;        }        return 0;    }	else	{		//-数据未读取完，还要继续读取-		g_sTaskRunStep.nStartNum = nStartIndex;	}    //nSendVSQ =  bgetnum;    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);    *pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}/*********************************************************************所属功能单元： yx_point_get_zhj功能描述	：获取点召测时的遥信数据输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yx_point_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 bStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum = 0;	uint8 bgetnum = 0;	uint8 len = 0;	uint8 index = 0;    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYxDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum = bStartNum;	bgetnum = *pGetNum;	*pGetNum = 0; 	if(startnum>= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥信	    if(INFO_ADDR_TYPE_YX == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yx_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yx_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);                if(M_SP_NA_1 == nSignalType)                {                    //单点遥信, 继续执行                }                else                {                    continue;                }            }            else            {                continue;            }        }        else        {            continue;        }        		//信息体地址		memcpy(addr, &g_aYxDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);		pData[index++] = addr[0];		pData[index++] = addr[1];		if(bAdulen == 3)		{			pData[index++] = addr[2];		}		//单点遥信数值		pData[index++] = g_aYxDataSendZhj[ArrIdx+addrIndex].nNewValue;		//修改发送状态		g_aYxDataSendZhj[ArrIdx+addrIndex].nHisValue = g_aYxDataSendZhj[ArrIdx+addrIndex].nNewValue;		g_aYxDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;		g_aYxDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;		FRAME104_FMT_TRACE("点召唤 遥信yx_point_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, 点召地址序号i=%d, g_aYxDataSend[%d]: nNewValue=%d, nHisValue=%d, bChangeFlag=%d, bSendFlag=%d, 全局g_bYxChanged=%d \n", 			g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYxDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 			i, addrIndex, g_aYxDataSendZhj[ArrIdx+addrIndex].nNewValue, g_aYxDataSendZhj[ArrIdx+addrIndex].nHisValue, 			g_aYxDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYxDataSendZhj[ArrIdx+addrIndex].bSendFlag, g_bYxChanged);		        j++;		*pGetNum = j;		if(j >= bgetnum)			break;	}		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_nva_get_zhj功能描述	：点召获取遥测量数据（归一化值）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_point_nva_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_nva_get() 总召获取遥测量数据（归一化值） \n");		int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数	float32 fNvaValue = 0;  //浮点型归一化值	int16 nValueNVA = 0;  //转换之后的归一化值    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥测	    if(INFO_ADDR_TYPE_YC == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yc_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yc_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            }            else            {                continue;            }        }        else        {            continue;        }        		if(nSignalType == M_ME_NA_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//归一化数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+addrIndex].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue*fRatio;			fNvaValue = fConvertValue/g_aYcDataConfigZhj[ArrIdx+addrIndex].fFullValue;  //实际值除以满码值			//溢出检查			if(fNvaValue > (1-pow(2, -15)))			{				fNvaValue = 1-pow(2, -15);			}			else if(fNvaValue < (-1+pow(2, -15)))			{				fNvaValue = -1+pow(2, -15);			}			if(fNvaValue >= 0)			{				nValueNVA = (int16)(fNvaValue*pow(2, 15));			}			else			{				nValueNVA = (int16)(fNvaValue*pow(2, 15)*(-1));				nValueNVA = (int16)(nValueNVA*(-1));			}			memcpy((void *)&pData[index], (void *)&nValueNVA, sizeof(int16));			index += sizeof(int16);			//品质			if(g_aYcDataSendZhj[ArrIdx+addrIndex].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue;			g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;			FRAME104_FMT_TRACE("点召唤 遥测(归一化值)yc_total_nva_get() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_sva_get_zhj功能描述	：点召获取遥测量数据（标度化值）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_point_sva_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_sva_get() 总召获取遥测量数据（标度化值） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数	int16 nValueSVA;  //转换之后的标度化值    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥测	    if(INFO_ADDR_TYPE_YC == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yc_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yc_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            }            else            {                continue;            }        }        else        {            continue;        }        		if(nSignalType == M_ME_NB_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//标度化数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+addrIndex].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue*fRatio;			//溢出检查			if(fConvertValue > 32767)			{				nValueSVA = 32767;			}			else if(fConvertValue < (-32768))			{				nValueSVA = (-32768);			}			else			{				nValueSVA = (int16)fConvertValue;			}			memcpy((void *)&pData[index], (void *)&nValueSVA, sizeof(int16));			index += sizeof(int16);			//品质			if(g_aYcDataSendZhj[ArrIdx+addrIndex].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue;			g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;			FRAME104_FMT_TRACE("点召唤 遥测(标度化值)yc_total_sva_get() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_r_get_zhj功能描述	：点召获取遥测量数据（短浮点数）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_point_r_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥测	    if(INFO_ADDR_TYPE_YC == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yc_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yc_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            }            else            {                continue;            }        }        else        {            continue;        }        		if(nSignalType == M_ME_NC_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+addrIndex].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+addrIndex].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue;			g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;			FRAME104_FMT_TRACE("点召唤 遥测(短浮点数)yc_total_r_get() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_r_t_get_zhj功能描述	：点召获取遥测量数据（短浮点数 带时标）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_point_r_t_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥测	    if(INFO_ADDR_TYPE_YC == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yc_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yc_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            }            else            {                continue;            }        }        else        {            continue;        }        		if(nSignalType == M_ME_TF_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+addrIndex].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+addrIndex].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            //带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue;			g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;			FRAME104_FMT_TRACE("点召唤 遥测(短浮点数 带时标)yc_point_r_t_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_r_en_get_zhj功能描述	：点召获取遥测量数据（短浮点数 电量）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_point_r_en_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥测	    if(INFO_ADDR_TYPE_YC == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yc_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yc_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            }            else            {                continue;            }        }        else        {            continue;        }        		if(nSignalType == M_IT_NB_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+addrIndex].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+addrIndex].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue = g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue;			g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;			FRAME104_FMT_TRACE("点召唤 遥测(短浮点数 电量)yc_point_r_en_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].fNewValue, g_aYcDataSendZhj[ArrIdx+addrIndex].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_str_get_zhj功能描述	：点召获取遥测量数据（比特串）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_point_str_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	//FRAME104_FMT_TRACE("yc_total_r_get() 总召获取遥测量数据（短浮点数） \n");	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    int addrIndex = 0;//根据信息体地址查询点表配置数组索引    int nSignalType = 0;//类型标识    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nPointCallInfoAddrNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nPointCallInfoAddrNum; i++)	{	    //判断点召信号是否为遥测	    if(INFO_ADDR_TYPE_YC == check_info_addr_type_zhj(g_aPointCallInfoAddr[i]))        {            addrIndex = query_yc_index_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            if(addrIndex >= 0)            {                nSignalType = query_yc_type_config_zhj(eqTpIndex, eqGroupIndex, eqNoIndex, g_aPointCallInfoAddr[i]);            }            else            {                continue;            }        }        else        {            continue;        }        		if(nSignalType == M_VBO_TB_1)		{			//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}            //比特串长度            pData[index++] = g_aYcDataConfigZhj[ArrIdx+addrIndex].nArrLen;            //比特串内容            memcpy(&pData[index], g_aYcDataSendZhj[ArrIdx+addrIndex].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+addrIndex].nArrLen);			index += g_aYcDataConfigZhj[ArrIdx+addrIndex].nArrLen;			//品质			if(g_aYcDataSendZhj[ArrIdx+addrIndex].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            //时标            system_time_get(&pData[index]);            index += 7;			//修改变化状态和发送状态			memcpy(g_aYcDataSendZhj[ArrIdx+addrIndex].aHisArrValue, g_aYcDataSendZhj[ArrIdx+addrIndex].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+addrIndex].nArrLen);			g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag = TRUE;			FRAME104_FMT_TRACE("点召唤 遥测(比特串)yc_total_str_get_zhj() nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+addrIndex].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+addrIndex].bChangeFlag, g_aYcDataSendZhj[ArrIdx+addrIndex].bSendFlag);            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+addrIndex].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+addrIndex].nArrLen, "aNewArrValue:");            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+addrIndex].aHisArrValue, g_aYcDataConfigZhj[ArrIdx+addrIndex].nArrLen, "aHisArrValue:");            //判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_point_get_zhj功能描述	：获取点召测时的遥测数据输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_point_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	//int    result = 0;	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	//uint8 pBackInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于备份	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;	switch (g_sTaskRunStep.nSubDataCallSetp)	{		case ALLDATA_STEP_SEND_R://上报所有遥测信息（短浮点数）        {            nSendTI = M_ME_NC_1;            nSendCOT = CAUSE_PTCALLGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 25;  //单次上送信号的最大个数(255-12)/(3+4+1)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_point_r_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("点召唤 上报所有遥测信息(短浮点数)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aPointCallEquipStateYC_R[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_point_equip_zhj(ALLDATA_STEP_SEND_R);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aPointCallEquipStateYC_R[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_point_equip_zhj(ALLDATA_STEP_SEND_R);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case ALLDATA_STEP_SEND_R_T://上报所有遥测信息（短浮点数 带时标）        {            nSendTI = M_ME_TF_1;            nSendCOT = CAUSE_PTCALLGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_point_r_t_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("点召唤 上报所有遥测信息(短浮点数 带时标)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aPointCallEquipStateYC_R_T[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_point_equip_zhj(ALLDATA_STEP_SEND_R_T);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aPointCallEquipStateYC_R_T[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_point_equip_zhj(ALLDATA_STEP_SEND_R_T);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case ALLDATA_STEP_SEND_R_EN://上报所有遥测信息（短浮点数 电量）        {            nSendTI = M_IT_NB_1;            nSendCOT = CAUSE_PTCALLGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 25;  //单次上送信号的最大个数(255-12)/(3+4+1)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_point_r_en_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("点召唤 上报所有遥测信息(短浮点数 电量)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aPointCallEquipStateYC_R_EN[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_point_equip_zhj(ALLDATA_STEP_SEND_R_EN);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aPointCallEquipStateYC_R_EN[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_point_equip_zhj(ALLDATA_STEP_SEND_R_EN);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case ALLDATA_STEP_SEND_STR://上报所有遥测信息（比特串）        {            nSendTI = M_VBO_TB_1;            nSendCOT = CAUSE_PTCALLGEN;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 10;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_point_str_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("点召唤 上报所有遥测信息(比特串)，nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);            if(bgetnum == 0)            {                g_aPointCallEquipStateYC_STR[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                next_call_point_equip_zhj(ALLDATA_STEP_SEND_STR);                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aPointCallEquipStateYC_STR[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;			    next_call_point_equip_zhj(ALLDATA_STEP_SEND_STR);			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        default:            g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_STOP;            break;	}	*pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}/******************************************************************************** 函数名称: changed_yx_left_zhj* 函数功能: 判断是否含有未上报的变化遥信* 输入参数: 无* 输出参数: 无* 返 回 值: 1 有 -1 无*******************************************************************************/int changed_yx_left_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号        for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=0; z<g_aGroupCountZhj[i]; z++)        {            for(j=0; j<g_aEquipCountZhj[i][z]; j++)            {                if(1 == g_aChangedEquipStateYX[i][z][j])                {                    return 1;                }            }        }            }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: changed_yc_left_zhj* 函数功能: 判断是否含有未上报的变化遥测* 输入参数: 无* 输出参数: 无* 返 回 值: 1 有 -1 无*******************************************************************************/int changed_yc_left_zhj(uint8 yctype){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    switch(yctype)    {        case YC_CHANGE_STEP_SEND_R:        {            for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=0; z<g_aGroupCountZhj[i]; z++)                {                    for(j=0; j<g_aEquipCountZhj[i][z]; j++)                    {                        if(1 == g_aChangedEquipStateYC_R[i][z][j])                        {                            return 1;                        }                    }                }                            }        }            break;        case YC_CHANGE_STEP_SEND_R_T:        {            for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=0; z<g_aGroupCountZhj[i]; z++)                {                    for(j=0; j<g_aEquipCountZhj[i][z]; j++)                    {                        if(1 == g_aChangedEquipStateYC_R_T[i][z][j])                        {                            return 1;                        }                    }                }                            }        }            break;        case YC_CHANGE_STEP_SEND_R_EN:        {            for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=0; z<g_aGroupCountZhj[i]; z++)                {                    for(j=0; j<g_aEquipCountZhj[i][z]; j++)                    {                        if(1 == g_aChangedEquipStateYC_R_EN[i][z][j])                        {                            return 1;                        }                    }                }                            }        }            break;                case YC_CHANGE_STEP_SEND_STR:        {            for(i=0; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=0; z<g_aGroupCountZhj[i]; z++)                {                    for(j=0; j<g_aEquipCountZhj[i][z]; j++)                    {                        if(1 == g_aChangedEquipStateYC_STR[i][z][j])                        {                            return 1;                        }                    }                }                            }        }            break;                default:            break;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: next_changed_yx_eq_zhj* 函数功能: 获取下一个变化遥信的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int next_changed_yx_eq_zhj(){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;        for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)    {        for(z=nowEqGroupIndex; z<MAX_EQUIP_GROUP_NUM; z++)        {            for(j=nowEqNoIndex; j<MAX_EQUIP_COUNT_NUM;j++)            {                if(g_aChangedEquipStateYX[i][z][j] == 1)                {                    g_sTaskRunStep.nEquipTypeIndex = i;                    g_sTaskRunStep.nEquipGroupIndex = z;                    g_sTaskRunStep.nEquipNoIndex = j;                    return 1;                }            }            nowEqNoIndex = 0;        }        nowEqGroupIndex = 0;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: next_changed_yc_eq_zhj* 函数功能: 获取下一个变化遥测的设备类型和编号(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int next_changed_yc_eq_zhj(uint8 yctype){    int i = 0;//设备类型    int z = 0;//设备组别    int j = 0;//组内序号    uint16 nowEqTypeIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 nowEqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;    switch(yctype)    {        case YC_CHANGE_STEP_SEND_R:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<MAX_EQUIP_GROUP_NUM; z++)                {                    for(j=nowEqNoIndex; j<MAX_EQUIP_COUNT_NUM;j++)                    {                        if(g_aChangedEquipStateYC_R[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;        case YC_CHANGE_STEP_SEND_R_T:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<MAX_EQUIP_GROUP_NUM; z++)                {                    for(j=nowEqNoIndex; j<MAX_EQUIP_COUNT_NUM;j++)                    {                        if(g_aChangedEquipStateYC_R_T[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;        case YC_CHANGE_STEP_SEND_R_EN:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<MAX_EQUIP_GROUP_NUM; z++)                {                    for(j=nowEqNoIndex; j<MAX_EQUIP_COUNT_NUM;j++)                    {                        if(g_aChangedEquipStateYC_R_EN[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;                case YC_CHANGE_STEP_SEND_STR:        {            for(i=nowEqTypeIndex; i<MAX_EQUIP_TYPE_NUM; i++)            {                for(z=nowEqGroupIndex; z<MAX_EQUIP_GROUP_NUM; z++)                {                    for(j=nowEqNoIndex; j<MAX_EQUIP_COUNT_NUM;j++)                    {                        if(g_aChangedEquipStateYC_STR[i][z][j] == 1)                        {                            g_sTaskRunStep.nEquipTypeIndex = i;                            g_sTaskRunStep.nEquipGroupIndex = z;                            g_sTaskRunStep.nEquipNoIndex = j;                            return 1;                        }                    }                    nowEqNoIndex = 0;                }                nowEqGroupIndex = 0;            }        }            break;                default:            break;    }    g_sTaskRunStep.nEquipTypeIndex = 0;    g_sTaskRunStep.nEquipGroupIndex = 0;    g_sTaskRunStep.nEquipNoIndex = 0;    return -1;}/*********************************************************************所属功能单元：yx_change_get功能描述	：获取遥信SOE数据输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yx_change_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYxDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYxNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYxNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if((g_aYxDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYxDataSendZhj[ArrIdx+i].bSendFlag == FALSE))		{			FRAME104_FMT_TRACE("变化遥信yx_change_get()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d, nNewValue:%d, nHisValue:%d \n",                 g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex,                 i, g_aYxDataSendZhj[ArrIdx+i].bChangeFlag, g_aYxDataSendZhj[ArrIdx+i].bSendFlag, 				g_aYxDataSendZhj[ArrIdx+i].nNewValue, g_aYxDataSendZhj[ArrIdx+i].nHisValue);						//信息体地址    		memcpy(addr, &g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//单点遥信数值			pData[index++] = g_aYxDataSendZhj[ArrIdx+i].nNewValue;			//带时标			memcpy(&pData[index], &g_aYxDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYxDataSendZhj[ArrIdx+i].nHisValue = g_aYxDataSendZhj[ArrIdx+i].nNewValue;			g_aYxDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYxDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥信yx_change_get()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, nNewValue:%d, nHisValue:%d \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYxDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYxDataSendZhj[ArrIdx+i].bSendFlag, g_aYxDataSendZhj[ArrIdx+i].nNewValue, g_aYxDataSendZhj[ArrIdx+i].nHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_change_nva_get功能描述	：变化遥测上报 遥测量数据（归一化值）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_change_nva_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数	float32 fNvaValue = 0;  //浮点型归一化值	int16 nValueNVA = 0;  //转换之后的归一化值    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType != M_ME_NA_1)		{			continue;		}		if((g_aYcDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYcDataSendZhj[ArrIdx+i].bSendFlag == FALSE))		{			FRAME104_FMT_TRACE("变化遥测(归一化值)yc_change_nva_get()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);						//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//归一化数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			fNvaValue = fConvertValue/g_aYcDataConfigZhj[ArrIdx+i].fFullValue;  //实际值除以满码值			//溢出检查			if(fNvaValue > (1-pow(2, -15)))			{				fNvaValue = 1-pow(2, -15);			}			else if(fNvaValue < (-1+pow(2, -15)))			{				fNvaValue = -1+pow(2, -15);			}			if(fNvaValue >= 0)			{				nValueNVA = (int16)(fNvaValue*pow(2, 15));			}			else			{				nValueNVA = (int16)(fNvaValue*pow(2, 15)*(-1));				nValueNVA = (int16)(nValueNVA*(-1));			}			memcpy((void *)&pData[index], (void *)&nValueNVA, sizeof(int16));			index += sizeof(int16);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥测(归一化值)yc_change_nva_get()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_change_sva_get功能描述	：变化遥测上报 遥测量数据（标度化值）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_change_sva_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数	int16 nValueSVA;  //转换之后的标度化值    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType != M_ME_NB_1)		{			continue;		}		if((g_aYcDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYcDataSendZhj[ArrIdx+i].bSendFlag == FALSE))		{			FRAME104_FMT_TRACE("变化遥测(标度化值)yc_change_sva_get()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);						//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//标度化数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			//溢出检查			if(fConvertValue > 32767)			{				nValueSVA = 32767;			}			else if(fConvertValue < (-32768))			{				nValueSVA = (-32768);			}			else			{				nValueSVA = (int16)fConvertValue;			}			memcpy((void *)&pData[index], (void *)&nValueSVA, sizeof(int16));			index += sizeof(int16);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥测(标度化值)yc_change_sva_get()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_change_r_get_zhj功能描述	：变化遥测上报 遥测量数据（短浮点数）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_change_r_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType != M_ME_NC_1)		{			continue;		}		if((g_aYcDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYcDataSendZhj[ArrIdx+i].bSendFlag == FALSE))			{			FRAME104_FMT_TRACE("变化遥测(短浮点数)yc_change_r_get_zhj()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);						//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+i].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥测(短浮点数)yc_change_r_get_zhj()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_change_r_t_get_zhj功能描述	：变化遥测上报 遥测量数据（短浮点数 带时标）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_change_r_t_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType != M_ME_TF_1)		{			continue;		}		if((g_aYcDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYcDataSendZhj[ArrIdx+i].bSendFlag == FALSE))			{			FRAME104_FMT_TRACE("变化遥测(短浮点数 带时标)yc_change_r_t_get_zhj()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);						//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+i].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥测(短浮点数 带时标)yc_change_r_t_get_zhj()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_change_r_en_get_zhj功能描述	：变化遥测上报 遥测量数据（短浮点数 电量）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_change_r_en_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType != M_ME_NC_1)		{			continue;		}		if((g_aYcDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYcDataSendZhj[ArrIdx+i].bSendFlag == FALSE))			{			FRAME104_FMT_TRACE("变化遥测(短浮点数 电量)yc_change_r_en_get_zhj()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);						//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			fRatio = ratio_convert(g_aYcDataConfigZhj[ArrIdx+i].nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, fNewValue=%f, fRatio=%f \n", fConvertValue, g_aYcDataSendZhj[ArrIdx+i].fNewValue, fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			g_aYcDataSendZhj[ArrIdx+i].fHisValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue;			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥测(短浮点数 电量)yc_change_r_en_get_zhj()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag, g_aYcDataSendZhj[ArrIdx+i].fNewValue, g_aYcDataSendZhj[ArrIdx+i].fHisValue);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_change_str_get_zhj功能描述	：变化遥测上报 遥测量数据（比特串）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_change_str_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    uint16 eqTpIndex = g_sTaskRunStep.nEquipTypeIndex;    uint16 eqGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqTpIndex][eqGroupIndex][eqNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex])	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_nConfigYcNumZhj[eqTpIndex][eqGroupIndex][eqNoIndex]; i++)	{		if(g_aYcDataConfigZhj[ArrIdx+i].nSignalType != M_VBO_TB_1)		{			continue;		}		if((g_aYcDataSendZhj[ArrIdx+i].bChangeFlag == TRUE)			&& (g_aYcDataSendZhj[ArrIdx+i].bSendFlag == FALSE))			{			FRAME104_FMT_TRACE("变化遥测(比特串)yc_change_str_get_zhj()前 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, i=%d, bChangeFlag:%d, bSendFlag:%d \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag);            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen, "aNewArrValue:");            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+i].aHisArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen, "aHisArrValue:");						//信息体地址    		memcpy(addr, &g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//比特串长度            pData[index++] = g_aYcDataConfigZhj[ArrIdx+i].nArrLen;            //比特串内容            memcpy(&pData[index], g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen);			index += g_aYcDataConfigZhj[ArrIdx+i].nArrLen;			//品质			if(g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag)            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aYcDataSendZhj[ArrIdx+i].btime[0], 7);			index += 7;			//修改变化状态和发送状态			memcpy(g_aYcDataSendZhj[ArrIdx+i].aHisArrValue, g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen);			g_aYcDataSendZhj[ArrIdx+i].bChangeFlag = FALSE;			g_aYcDataSendZhj[ArrIdx+i].bSendFlag = TRUE;			FRAME104_FMT_TRACE("变化遥测(比特串)yc_change_str_get_zhj()后 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, addr=%08x, i=%d, bChangeFlag:%d, bSendFlag:%d, fNewValue:%f, fHisValue:%f \n", 				g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32, 				i, g_aYcDataSendZhj[ArrIdx+i].bChangeFlag, 				g_aYcDataSendZhj[ArrIdx+i].bSendFlag);            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen, "aNewArrValue:");            FRAME104_BUF_TRACE(g_aYcDataSendZhj[ArrIdx+i].aHisArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen, "aHisArrValue:");			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_change_get功能描述	：变化遥测上报输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_change_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	//int    result = 0;	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	//uint8 pBackInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于备份	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;	switch (g_sTaskRunStep.nDataCallStep)	{		case YC_CHANGE_STEP_SEND_R://上报变化遥测信息（短浮点数）        {            if(changed_yc_left_zhj(YC_CHANGE_STEP_SEND_R) < 0)            {                g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_STR;                break;            }            nSendTI = M_ME_TF_1;            nSendCOT = CAUSE_SPONT;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_change_r_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("上报变化遥测信息（短浮点数），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_aChangedEquipStateYC_R[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R) < 0)                {                    //-没有更多数据需要上报-                    g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_STR;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aChangedEquipStateYC_R[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R) < 0)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_STR;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case YC_CHANGE_STEP_SEND_R_T://上报变化遥测信息（短浮点数 带时标）        {            if(changed_yc_left_zhj(YC_CHANGE_STEP_SEND_R_T) < 0)            {                g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_R_EN;                break;            }            nSendTI = M_ME_TF_1;            nSendCOT = CAUSE_SPONT;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_change_r_t_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("上报变化遥测信息（短浮点数 带时标），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_aChangedEquipStateYC_R_T[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R_T) < 0)                {                    //-没有更多数据需要上报-                    g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_R_EN;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aChangedEquipStateYC_R_T[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R_T) < 0)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_R_EN;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case YC_CHANGE_STEP_SEND_R_EN://上报变化遥测信息（短浮点数 电量）        {            if(changed_yc_left_zhj(YC_CHANGE_STEP_SEND_R_EN) < 0)            {                g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_STR;                break;            }            nSendTI = M_IT_TC_1;            nSendCOT = CAUSE_SPONT;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_change_r_en_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("上报变化遥测信息（短浮点数 电量），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_aChangedEquipStateYC_R_EN[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R_EN) < 0)                {                    //-没有更多数据需要上报-                    g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_STR;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aChangedEquipStateYC_R_EN[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_R_EN) < 0)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nDataCallStep = YC_CHANGE_STEP_SEND_STR;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case YC_CHANGE_STEP_SEND_STR://上报变化遥测信息（比特串）        {            if(changed_yc_left_zhj(YC_CHANGE_STEP_SEND_STR) < 0)            {                g_bYcChanged = FALSE;			    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                break;            }            nSendTI = M_VBO_TB_1;            nSendCOT = CAUSE_SPONT;            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);			uint8 nSendNumMax = 10;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_change_str_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("上报变化遥测信息（比特串），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_aChangedEquipStateYC_STR[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_STR) < 0)                {                    //-没有更多数据需要上报-                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aChangedEquipStateYC_STR[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yc_eq_zhj(YC_CHANGE_STEP_SEND_STR) < 0)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }		default:        {            g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            break;        }	}	*pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}/*********************************************************************所属功能单元： yx_frozen_call_get_zhj功能描述	：任务召测 获取周期冻结与上报的遥信数据输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yx_frozen_call_get_zhj(uint8 bAdulen, uint8 *pData, uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;    //int ret = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位    uint16 eqTmnGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;    uint16 eqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;    uint16 nTaskPubAddrIndex = g_sTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值        //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, fileret);    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_SP_NA_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{            if( (index+3+1) > leftlen )//3地址+1值            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//单点遥信数值			pData[index++] = aHisFrozenData[eqSaveNoIndex].aYxFrozenValue[i];			FRAME104_FMT_TRACE("任务召测 遥信 yx_frozen_call_get_zhj() eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, FrozenValue:%d \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, aHisFrozenData[eqSaveNoIndex].aYxFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}    pData[0] = count;//更新信息体数量    *pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_r_call_get_zhj功能描述	：任务召测 获取周期冻结与上报的遥测数据（短浮点数）输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yc_frozen_r_call_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位	    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;    uint16 eqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;    uint16 nTaskPubAddrIndex = g_sTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值    //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, fileret);    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_ME_NC_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{		    if( (index+3+4+1) > leftlen )//3地址+4值+1品质            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(aHisFrozenData[eqSaveNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			FRAME104_FMT_TRACE("任务召测 遥测(短浮点数) yc_frozen_r_call_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}	pData[0] = count;//更新信息体数量	*pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_r_t_call_get_zhj功能描述	：任务召测 获取周期冻结与上报的遥测数据（短浮点数 带时标）输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yc_frozen_r_t_call_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位	    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;    uint16 eqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;    uint16 nTaskPubAddrIndex = g_sTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值    //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, fileret);    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_ME_TF_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{		    if( (index+3+4+1+7) > leftlen )//3地址+4值+1品质+7时标            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(aHisFrozenData[eqSaveNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &aHisFrozenData[eqSaveNoIndex].aFrozenTime[0], 7);			index += 7;			FRAME104_FMT_TRACE("任务召测 遥测(短浮点数 带时标) yc_frozen_r_t_call_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}	pData[0] = count;//更新信息体数量	*pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_en_call_get_zhj功能描述	：任务召测 获取周期冻结与上报的遥测数据（短浮点数 电量）输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yc_frozen_en_call_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位	    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;    uint16 eqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;    uint16 nTaskPubAddrIndex = g_sTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值    //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, fileret);    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_IT_NB_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{		    if( (index+3+4+1) > leftlen )//3地址+4值+1品质            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(aHisFrozenData[eqSaveNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			FRAME104_FMT_TRACE("任务召测 遥测(短浮点数 电量) yc_frozen_en_call_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, aHisFrozenData[eqSaveNoIndex].aYcFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}	pData[0] = count;//更新信息体数量	*pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_str_call_get_zhj功能描述	：任务召测 获取周期冻结与上报的遥测数据（比特串）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/int yc_frozen_str_call_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){    int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位    uint16 eqTmnGroupIndex = g_sTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;    uint16 eqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;    uint16 nTaskPubAddrIndex = g_sTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址        startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值    //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, fileret);    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];    //将数据填写返回区    for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)    {        if(M_VBO_TB_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))        {            if( (index+3+1+aHisFrozenData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i]+1) > leftlen )//3地址+1长度+变长内容+1品质            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }                        //信息体地址            memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);            pData[index++] = addr[0];            pData[index++] = addr[1];            if(bAdulen == 3)            {                pData[index++] = addr[2];            }            //比特串长度            pData[index++] = aHisFrozenData[eqSaveNoIndex].nFrozenArrLen[i];            //比特串内容            memcpy(&pData[index], aHisFrozenData[eqSaveNoIndex].aFrozenArrValue[i], aHisFrozenData[eqSaveNoIndex].nFrozenArrLen[i]);			index += aHisFrozenData[eqSaveNoIndex].nFrozenArrLen[i];			//品质            if(aHisFrozenData[eqSaveNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            FRAME104_FMT_TRACE("任务召测 遥测(比特串) yc_frozen_str_call_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, nFrozenArrLen:%f \n",                 eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i],                 i, aHisFrozenData[eqSaveNoIndex].nFrozenArrLen[i]);            FRAME104_BUF_TRACE(aHisFrozenData[eqSaveNoIndex].aFrozenArrValue[i], aHisFrozenData[eqSaveNoIndex].nFrozenArrLen[i], "字符串:");            //累计信息体个数			count++;        }        //计算下一次的起始位置	    *pStartNum = i+1;    }    pData[0] = count;//更新信息体数量    *pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_get_zhj功能描述	：任务召测 冻结数据周期上报 遥测输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_frozen_call_get_zhj(uint8 bAdulen, uint8 *pData, uint8 *pCurrLen, uint8 nMaxLen){	int ret = 0;//是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕	uint8 nSendInObjLen = 0;    	switch (g_sTaskRunStep.nSubDataCallSetp)	{		case YC_TIMING_STEP_SEND_R://实时数据周期上报遥测信息（短浮点数）        {            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_r_call_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("任务召测 遥测信息（短浮点数），返回数据长度 nSendInObjLen =%d, nMaxLen = %d \n",*pCurrLen,nMaxLen);            if(ret < 0)			{			    g_sTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R_T;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;                pData[(*pCurrLen)++] = 0x00;//遥测个数(带时标)                pData[(*pCurrLen)++] = 0x00;//遥测个数(电能量 不带时标)                pData[(*pCurrLen)++] = 0x00;//遥测个数(比特串)                g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTaskRunStep.nFinishFlag = 0;                g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_R;			}        }        case YC_TIMING_STEP_SEND_R_T://实时数据周期上报遥测信息（短浮点数 带时标）        {            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_r_t_call_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("任务召测 遥测信息（短浮点数 带时标），返回数据长度 nSendInObjLen =%d, nMaxLen = %d \n",*pCurrLen,nMaxLen);            if(ret < 0)			{			    g_sTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_EN;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;                pData[(*pCurrLen)++] = 0x00;//遥测个数(电能量 不带时标)                pData[(*pCurrLen)++] = 0x00;//遥测个数(比特串)                g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTaskRunStep.nFinishFlag = 0;                g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_R_T;			}        }        case YC_TIMING_STEP_SEND_EN://实时数据周期上报遥测信息（短浮点数 电量）        {            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_en_call_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("任务召测 遥测信息（短浮点数 电量），返回数据长度 nSendInObjLen =%d, nMaxLen = %d \n",*pCurrLen,nMaxLen);            if(ret < 0)			{			    g_sTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_STR;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;                pData[(*pCurrLen)++] = 0x00;//遥测个数(比特串)                g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTaskRunStep.nFinishFlag = 0;                g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_EN;			}        }        case YC_TIMING_STEP_SEND_STR://上报变化遥测信息（比特串）        {            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_str_call_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("任务召测 遥测信息（比特串），返回数据长度 nSendInObjLen =%d, nMaxLen = %d \n",*pCurrLen,nMaxLen);            if(ret < 0)			{			    //该地址全部获取完毕			    g_sTaskRunStep.nTaskPubAddrIndex ++;			    			    if(move_next_task_call_pub_zhj() < 0)//所有公共地址类型均上报                {                    //当前冻结数据所有公共地址上报完毕, 切到下一个冻结数据                    g_sTaskRunStep.nEqSaveNoIndex ++;                                        g_sTaskRunStep.nStartNum = 0;                    if(1)                    {                        //-读取的数量少于要读的数据量，表示本次读取结束-                        g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                        g_sTaskRunStep.nFinishFlag = 0;//这里不判断所有任务完成, 由HEAD检查                        g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                        //g_sTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;                    }                }                else                {                    g_sTaskRunStep.nStartNum = 0;                    g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                    g_sTaskRunStep.nFinishFlag = 0;                    g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                    //g_sTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;                g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTaskRunStep.nFinishFlag = 0;                g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_STR;			}            break;        }		default:        {            g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;            break;        }	}    return 1;}/*********************************************************************所属功能单元： yc_refresh_frozen_zhj功能描述	：冻结数据周期上报 遥测输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_refresh_frozen_call_zhj(uint8 *pData, uint8 *pCurrLen){    uint8 nSendInObjLen = *pCurrLen;        if( (TIMING_STEP_SEND_YC==g_sTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_R==g_sTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0    }    else if( (TIMING_STEP_SEND_YC==g_sTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_R_T==g_sTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数)数量置0    }    else if( (TIMING_STEP_SEND_YC==g_sTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_EN==g_sTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数)数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数 带时标)数量置0    }    else if( (TIMING_STEP_SEND_YC==g_sTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_STR==g_sTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数)数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数 带时标)数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数 电量)数量置0    }    else    {        return -1;    }    *pCurrLen = nSendInObjLen;    return 1;}/******************************************************************************** 函数名称: next_call_all_equip_zhj* 函数功能: 总召唤 判断下一个需要上报的设备类型、组别、序号，以及数据类型* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int next_call_all_equip_zhj(uint8 SigType){    uint8 tempStep = SigType;        switch(tempStep)    {        case ALLDATA_STEP_SEND_YX_SUB://遥信        {            if(get_next_equip_yx_zhj() > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YX;                break;            }            tempStep = ALLDATA_STEP_SEND_R;        }        case ALLDATA_STEP_SEND_R://遥测 短浮点        {            if(get_next_equip_yc_zhj(ALLDATA_STEP_SEND_R) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_R;                break;            }            tempStep = ALLDATA_STEP_SEND_R_T;        }        case ALLDATA_STEP_SEND_R_T://遥测 短浮点 带时标        {            if(get_next_equip_yc_zhj(ALLDATA_STEP_SEND_R_T) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_R_T;                break;            }            tempStep = ALLDATA_STEP_SEND_STR;        }        /*        case ALLDATA_STEP_SEND_R_EN://遥测 短浮点 电量        {        }        */        case ALLDATA_STEP_SEND_STR://遥测 字符串        {            if(get_next_equip_yc_zhj(ALLDATA_STEP_SEND_STR) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_STR;                break;            }            g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_STOP;        }            break;                default:            break;    }    return 1;}/******************************************************************************** 函数名称: next_call_point_equip_zhj* 函数功能: 点召唤 判断下一个需要上报的设备类型、组别、序号，以及数据类型* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int next_call_point_equip_zhj(uint8 SigType){    uint8 tempStep = SigType;    switch(tempStep)    {        case ALLDATA_STEP_SEND_YX_SUB://遥信        {            if(get_next_point_equip_yx_zhj() > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YX;                break;            }            tempStep = ALLDATA_STEP_SEND_R;        }        case ALLDATA_STEP_SEND_R://遥测 短浮点        {            if(get_next_point_equip_yc_zhj(ALLDATA_STEP_SEND_R) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_R;                break;            }            tempStep = ALLDATA_STEP_SEND_R_T;        }        case ALLDATA_STEP_SEND_R_T://遥测 短浮点 带时标        {            if(get_next_point_equip_yc_zhj(ALLDATA_STEP_SEND_R_T) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_R_T;                break;            }            tempStep = ALLDATA_STEP_SEND_R_EN;        }        case ALLDATA_STEP_SEND_R_EN://遥测 短浮点 电量        {            if(get_next_point_equip_yc_zhj(ALLDATA_STEP_SEND_R_EN) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_R_EN;                break;            }            tempStep = ALLDATA_STEP_SEND_STR;        }        case ALLDATA_STEP_SEND_STR://遥测 字符串        {            if(get_next_equip_yc_zhj(ALLDATA_STEP_SEND_STR) > 0)            {                g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_YC;                g_sTaskRunStep.nSubDataCallSetp = ALLDATA_STEP_SEND_STR;                break;            }            g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_STOP;            //g_bPointCallFlag = 0;//点召唤结束        }            break;                default:            break;    }    return 1;}/******************************************************************************** 函数名称: move_next_task_call_pub_zhj* 函数功能: 获取下一个终端设备编号和数据冻结任务召测的公共地址(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int move_next_task_call_pub_zhj(){    int i = 0;    uint16 nowEqCountIndex = g_sTaskRunStep.nEquipGroupIndex;//终端设备组别    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;//终端设备编号    uint16 nowEqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;//任务下标    uint16 nowTaskPubIndex = g_sTaskRunStep.nTaskPubAddrIndex;//公共地址下标    for(i=nowTaskPubIndex; i<g_aReportTaskPubAddrNum[nowEqCountIndex][nowEqNoIndex][nowEqTaskNoIndex]; i++)    {        if(1 == g_aTaskCallPubAddrState[nowEqCountIndex][nowEqNoIndex][nowEqTaskNoIndex][i])        {            g_sTaskRunStep.nTaskPubAddrIndex = i;            return 1;        }    }        g_sTaskRunStep.nTaskPubAddrIndex = 0;    return -1;}/******************************************************************************** 函数名称: move_next_task_call_frozen_zhj* 函数功能: 获取下一个终端设备编号和数据冻结任务召测的冻结数据(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int move_next_task_call_frozen_zhj(){    int i = 0;    uint16 nowEqCountIndex = g_sTaskRunStep.nEquipGroupIndex;//终端设备组别    uint16 nowEqNoIndex = g_sTaskRunStep.nEquipNoIndex;//终端设备编号    uint16 nowEqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;//任务下标    uint16 nowEqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;//存储下标    //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(nowEqCountIndex, nowEqNoIndex, nowEqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             nowEqCountIndex, nowEqNoIndex, nowEqTaskNoIndex, fileret);    }    for(i=nowEqSaveNoIndex; i<FROZEN_SAVE_DEPTH_MAX; i++)    {        if(aHisFrozenData[i].tFrozenTime >= g_stTaskCallConfig.tStartTime             && aHisFrozenData[i].tFrozenTime <= g_stTaskCallConfig.tEndTime)        {            g_sTaskRunStep.nEqSaveNoIndex = i;            return 1;        }    }        g_sTaskRunStep.nEqSaveNoIndex = 0;    return -1;}#ifdef AREA_ZHEJIANG/******************************************************************************** 函数名称: report_task_run* 函数功能: 执行上报任务* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int report_task_run_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	/*	FRAME104_FMT_TRACE("report_task_run() 执行上报任务 g_nNetWorkFlag=%d, nTaskStep=%d, nDataCallStep=%d, nSubDataCallSetp=%d, nStartNum=%d \n", 		g_nNetWorkFlag, g_sTaskRunStep.nTaskStep, g_sTaskRunStep.nDataCallStep, g_sTaskRunStep.nSubDataCallSetp, g_sTaskRunStep.nStartNum);	*/	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint16 nPubAddr = 0;	uint8 nSendInObjLen = 0;	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容    uint16 nTaskPubAddrIndex = 0;//公共地址编号    	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;		if(g_nNetWorkFlag != PRO_DATA_TRANSMIT)	{		return -1;	}		//任务闪转处理	switch(g_sTaskRunStep.nTaskStep)	{        case STEP_ALL_DATA_CALL_ALL://总召唤处理        {        	nPipeIndex = g_sTaskReportPipe.nAllDataCallPipe;            switch(g_sTaskRunStep.nDataCallStep)            {                case ALLDATA_STEP_SEND_YX://上报所有遥信信息                {                    nSendTI        =  M_SP_NA_1;                    nSendCOT       =  CAUSE_INTROGEN;                    nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);					uint8 nSendNumMax = 40;  //单次上送信号的最大个数(255-12)/(3+1)                    bgetnum = nSendNumMax;  //单次上送信号的最大个数                    nSendInObjLen  = yx_total_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, g_sTaskRunStep.nStartNum, &bgetnum);                    FRAME104_FMT_TRACE("总召唤 遥信 数据 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                        g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);                    if(bgetnum == 0)                    {                        g_aAllCallEquipStateYX[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                        g_sTaskRunStep.nStartNum = 0;                        next_call_all_equip_zhj(ALLDATA_STEP_SEND_YX_SUB);                        break;                    }        			else if(bgetnum < nSendNumMax)        			{        			    g_aAllCallEquipStateYX[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                        g_sTaskRunStep.nStartNum = 0;        			    next_call_all_equip_zhj(ALLDATA_STEP_SEND_YX_SUB);        			}        			else        			{        				//-数据未读取完，还要继续读取-        				g_sTaskRunStep.nStartNum += bgetnum ;        			}                    nSendVSQ =  bgetnum;                    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);					break;                }				case ALLDATA_STEP_SEND_YC://上报所有遥测信息				{					//FRAME104_FMT_TRACE("case ALLDATA_STEP_SEND_YC://上报所有遥测信息 \n");					nOutbufLen = yc_total_get_zhj(&nPipeIndex, pOutBuff, pAppType);					break;				}                case ALLDATA_STEP_SEND_STOP://数据上报完毕，总召唤激活终止                {                    pSendInObjBuff[0]  = 0;                    pSendInObjBuff[1]  = 0;                    pSendInObjBuff[2]  = 0;                    pSendInObjBuff[3]  = 20;//总召唤限定词                    nSendInObjLen = 4;                    nSendTI = C_IC_NA_1;                    nSendCOT = CAUSE_ACTTERM;                    nSendVSQ = 1;                    nOutbufLen = i_frame_data_pack(nSendTI,nSendVSQ,nSendCOT,pSendInObjBuff,nSendInObjLen,pOutBuff);                    g_bAllDataCallFlag = 0;                    g_bYCYXChangeSendFlag = 1;//总召过后再打开遥信变化上报允许标志                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_DEFAULT;                    break;                }                default:                {                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    break;                }            }            break;        }        case STEP_POINT_DATA_CALL://点召唤处理        {        	nPipeIndex = g_sTaskReportPipe.nPointCallPipe;            switch(g_sTaskRunStep.nDataCallStep)            {                case ALLDATA_STEP_SEND_YX://上报所有遥信信息                {                    nSendTI        =  M_SP_NA_1;                    nSendCOT       =  CAUSE_PTCALLGEN;                    nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);					uint8 nSendNumMax = 40;  //单次上送信号的最大个数(255-12)/(3+1)                    bgetnum = nSendNumMax;  //单次上送信号的最大个数                    nSendInObjLen  = yx_point_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, g_sTaskRunStep.nStartNum, &bgetnum);                    FRAME104_FMT_TRACE("点召唤 遥信 数据 nEquipTypeIndex=%d, nEquipGroupIndex=%d, nEquipNoIndex=%d, 返回数据长度nSendInObjLen=%d, bgetnum=%d \n",                        g_sTaskRunStep.nEquipTypeIndex, g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, nSendInObjLen, bgetnum);                    if(bgetnum == 0)                    {                        g_aPointCallEquipStateYX[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                        g_sTaskRunStep.nStartNum = 0;                        next_call_point_equip_zhj(ALLDATA_STEP_SEND_YX_SUB);                        break;                    }        			else if(bgetnum < nSendNumMax)        			{        			    g_aPointCallEquipStateYX[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                        g_sTaskRunStep.nStartNum = 0;        			    next_call_point_equip_zhj(ALLDATA_STEP_SEND_YX_SUB);        			}        			else        			{        				//-数据未读取完，还要继续读取-        				g_sTaskRunStep.nStartNum += bgetnum ;        			}                    nSendVSQ =  bgetnum;                    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);					break;                }				case ALLDATA_STEP_SEND_YC://上报所有遥测信息				{					//FRAME104_FMT_TRACE("case ALLDATA_STEP_SEND_YC://上报所有遥测信息 \n");					nOutbufLen = yc_point_get_zhj(&nPipeIndex, pOutBuff, pAppType);					break;				}                case ALLDATA_STEP_SEND_STOP: //数据上报完毕，点召激活终止                {                    pSendInObjBuff[0]  = 0;                    pSendInObjBuff[1]  = 0;                    pSendInObjBuff[2]  = 0;                    nSendInObjLen = 3;                    nSendTI = C_PC_NA_ZHJ_1;                    nSendCOT = CAUSE_ACTTERM;                    nSendVSQ = 1;                    nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);                    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);                    g_bPointCallFlag = 0;                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_STOP;                    break;                }                default:                {                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    break;                }            }            break;        }        case STEP_TASK_DATA_CALL://任务召测        {            int ret = 0;            uint8 nSendInObjLenMax = 0;            uint16 eqTmnGroupIndex = 0;//设备组别            uint16 eqTmnNoIndex = 0;//设备序号            uint16 eqTaskNoIndex = 0;//任务编号            uint16 eqSaveNoIndex = 0;//存储编号            nPipeIndex = g_sTaskReportPipe.nTaskCallPipe;            //历史冻结数据结构体            int fileret = 0;            REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容            memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));            fileret = his_frozen_file_read_zhj(eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));            if(fileret < 0)            {                FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",                     eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, fileret);            }                        switch(g_sTaskRunStep.nDataCallStep)            {                case TIMING_STEP_SEND_HEAD://组装报文头部				{					//FRAME104_FMT_TRACE("case TIMING_STEP_SEND_HEAD://组装报文头部 \n");					memset(g_sTaskRunStep.aTempBuff, 0x00, TOTAL_FRAME_LEN_MAX);                    g_sTaskRunStep.nTempBuffLen = 0;                    					if(move_to_next_call_task_zhj(TASK_DATA_FROZEN) < 0)                    {                        g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                        g_bTaskCallFlag = 0;//任务召唤结束                        break;//没有需要处理的历史冻结数据                    }                    if(move_next_task_call_frozen_zhj() < 0)                    {                        //当前周期上报任务结束，标志置0（先遥信，后遥测）                        g_aTaskCallEquipState[g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex][g_sTaskRunStep.nEqTaskNoIndex] = 0;                        g_sTaskRunStep.nStartNum = 0;                        if(1)                        {                            //-读取的数量少于要读的数据量，表示本次读取结束-                            g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                            g_sTaskRunStep.nFinishFlag = 0;//这里不判断所有任务完成, 由HEAD检查                            g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                            //g_sTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;                        }                        break;                    }                                        FRAME104_FMT_TRACE("report_task_run_zhj() 任务召测上报! 终端组别=%d, 终端下标=%d, 任务下标=%d, 存储编号=%d \n",                         g_sTaskRunStep.nEquipGroupIndex, g_sTaskRunStep.nEquipNoIndex, g_sTaskRunStep.nEqTaskNoIndex, g_sTaskRunStep.nEqSaveNoIndex);                    nTaskPubAddrIndex = g_sTaskRunStep.nTaskPubAddrIndex;                    nPubAddr = g_aReportTaskPubAddr[g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex][g_sTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];					                    nSendTI  =  M_TK_NA_ZHJ_1;                    nSendVSQ = 1;                    nSendCOT = 0x34 + (uint16)(((uint8)(g_sTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);                    //赋值冻结时标                    eqTmnGroupIndex = g_sTaskRunStep.nEquipGroupIndex;                    eqTmnNoIndex = g_sTaskRunStep.nEquipNoIndex;                    eqTaskNoIndex = g_sTaskRunStep.nEqTaskNoIndex;                    eqSaveNoIndex = g_sTaskRunStep.nEqSaveNoIndex;                    nSendInObjLenMax = 255 - APCI_UNIT_LABEL_LEN - 10;//预留十个数据类型                    memcpy(pSendInObjBuff, &aHisFrozenData[eqSaveNoIndex].aFrozenTime[0], 7);                    nSendInObjLen += 7;                    //判读最后一次读到的数据类型                    yc_refresh_frozen_call_zhj(&pSendInObjBuff[nSendInObjLen], &nSendInObjLen);                    g_sTaskRunStep.nDataCallStep = g_sTaskRunStep.nLastDataCallStep;                    g_sTaskRunStep.nSubDataCallSetp = g_sTaskRunStep.nLastSubDataCallSetp;				}                case TIMING_STEP_SEND_YX://上报所有遥信信息                {                    //FRAME104_FMT_TRACE("case TIMING_STEP_SEND_YX://上报所有遥信信息 \n");                    uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号                    ret  = yx_frozen_call_get_zhj(OBJ_ADDR_LEN, &pSendInObjBuff[nSendInObjLen], &nStartIndex, &nSendInObjLen, nSendInObjLenMax);                    FRAME104_FMT_TRACE("任务召测上报 遥信，返回数据长度 nSendInObjLen =%d, nSendInObjLenMax = %d \n",nSendInObjLen,nSendInObjLenMax);                    if(ret < 0)        			{        			    g_sTaskRunStep.nStartNum = 0;                        if(1)                        {                            //本类型数据遍历结束, 转下一种类型-            				g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                            g_sTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R;                        }        			}        			else        			{        				//-数据未读取完，还要继续读取-        				g_sTaskRunStep.nStartNum = nStartIndex;                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(不带时标)                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(带时标)                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(电能量 不带时标)                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(比特串)                        g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                        g_sTaskRunStep.nFinishFlag = 0;                        g_sTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                        //g_sTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;        			}                    //break;                }				case TIMING_STEP_SEND_YC://上报所有遥测信息				{					//FRAME104_FMT_TRACE("case TIMING_STEP_SEND_YC://上报所有遥测信息 \n");					yc_frozen_call_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nSendInObjLen, nSendInObjLenMax);					//break;				}                case TIMING_STEP_SEND_END://结束组帧				{					//FRAME104_FMT_TRACE("case TIMING_STEP_SEND_END://结束组帧 \n");					nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);                                        if(1 == g_sTaskRunStep.nFinishFlag)                    {                        g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                        g_sTaskRunStep.nDataCallStep = ALLDATA_STEP_SEND_DEFAULT;                        g_bTaskCallFlag = 0;//任务召唤结束                    }                    else                    {                        g_sTaskRunStep.nTaskStep = STEP_TASK_DATA_CALL;                        g_sTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                    }					break;				}                default:                {                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                    break;                }            }            break;        }        case STEP_SOE_CHANGE_SEND://soe事件上报(遥信变位)        {            if(changed_yx_left_zhj() < 0)            {                g_bYxChanged = FALSE;                g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            }            nSendTI  =  M_SP_TB_1;            nSendCOT =  CAUSE_SPONT;  //突发，遥信上报            nPubAddr       =  (uint16)((uint16)(g_sTaskRunStep.nEquipTypeIndex+1) << 11) + (uint16)((uint16)(g_sTaskRunStep.nEquipGroupIndex) << 8) + (g_sTaskRunStep.nEquipNoIndex+1);            uint8 nSendNumMax = 20;  //单次上送信号的最大个数(255-12)/(3+1+7)            uint16 nStartIndex = g_sTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yx_change_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("变化遥信 数据，返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_aChangedEquipStateYX[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yx_eq_zhj() < 0)                {                    //-没有更多数据需要上报-                    g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;    				                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_aChangedEquipStateYX[g_sTaskRunStep.nEquipTypeIndex][g_sTaskRunStep.nEquipGroupIndex][g_sTaskRunStep.nEquipNoIndex] = 0;                g_sTaskRunStep.nStartNum = 0;                if(next_changed_yx_eq_zhj() < 0)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-    				g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case STEP_YC_CHANGE_SEND://遥测数据变化上报        {               nOutbufLen = yc_change_get_zhj(&nPipeIndex, pOutBuff, pAppType);			break;        }        case STEP_ENN_DATA_CALL_ALL://--电量召唤--        {            nPipeIndex = g_sTaskReportPipe.nEnDataCallPipe;        	nOutbufLen = en_total_get_zhj(&nPipeIndex, pOutBuff, pAppType);            break;        }        case STEP_ALL_PARA_CALL://--所有参数召唤--        {            nPipeIndex = g_nGlobalPipe;        	nOutbufLen = para_total_get_zhj(&nPipeIndex, pOutBuff, pAppType);            break;        }        case STEP_SOME_PARA_CALL://--部分参数召唤--        {            nPipeIndex = g_nGlobalPipe;        	nOutbufLen = para_some_get_zhj(&nPipeIndex, pOutBuff, pAppType);            break;        }        case STEP_TIMER_SYN://时钟同步        {        	nPipeIndex = g_sTaskReportPipe.nTimeSynPipe;        	struct timeval tv;			time_t tmpTime;    		struct tm *p;			uint16  wtemp = 0;            nSendTI  = C_CS_NA_1;            nSendCOT = CAUSE_ACTTERM;            nSendVSQ      = 1;            pSendInObjBuff[0] = 0;            pSendInObjBuff[1] = 0;            pSendInObjBuff[2] = 0;                        time( &tmpTime );/*得到当前时间*/            gettimeofday(&tv,NULL);            p = localtime( &tmpTime );            wtemp = tv.tv_usec/1000 + p->tm_sec*1000;            pSendInObjBuff[3] = wtemp&0xff;            pSendInObjBuff[4] = (wtemp&0xff00)>>8;            pSendInObjBuff[5] = p->tm_min;            pSendInObjBuff[6] = p->tm_hour;            pSendInObjBuff[7] = p->tm_mday|(p->tm_wday<<5);            pSendInObjBuff[8] = p->tm_mon+1;            pSendInObjBuff[9] = p->tm_year;            if(pSendInObjBuff[9]>100)            {				pSendInObjBuff[9] -= 100;			}			FRAME104_FMT_TRACE("report_task_run() tv.tv_sec=%ld, tv.tv_usec=%ld \n", tv.tv_sec, tv.tv_usec);            FRAME104_FMT_TRACE("report_task_run() 年:%d 月:%d 日:%d 周:%d 时:%d 分:%d 毫秒:%d \n",                     pSendInObjBuff[9], pSendInObjBuff[8], p->tm_mday, p->tm_wday, p->tm_hour, p->tm_min, wtemp);            nSendInObjLen = 10;            nOutbufLen = i_frame_data_pack_zhj(nSendTI, nSendVSQ, nSendCOT, g_nTimeSynPubAddrZhj, pSendInObjBuff, nSendInObjLen, pOutBuff);			g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            break;        }        case STEP_FAULT_CHANGE_SEND:  //故障事件上报		{		    uint16 eqTmnTypeIndex = 0;//设备类型		    uint16 eqTmnGroupIndex = 0;//设备组别            uint16 eqTmnNoIndex = 0;//设备序号                        nSendTI  =  M_FT_NA_ZHJ_1;            nSendCOT =  CAUSE_SPONT;  //突发，故障信息上报            nSendInObjLen  = event_get_faults_zhj(&eqTmnTypeIndex, &eqTmnGroupIndex, &eqTmnNoIndex, pSendInObjBuff);            FRAME104_FMT_TRACE("report_task_run() 故障事件数据，返回数据长度 eqTmnTypeIndex=%d, eqTmnGroupIndex=%d, eqTmnNoIndex=%d, nSendInObjLen=%d \n",                     eqTmnTypeIndex, eqTmnGroupIndex, eqTmnNoIndex, nSendInObjLen);            FRAME104_BUF_TRACE(pSendInObjBuff, nSendInObjLen, "pSendInObjBuff:");            if(nSendInObjLen <= 0)            {            	//-没有更多数据需要上报-                g_sTaskRunStep.nStartNum = 0;                g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;                break;            }			nSendVSQ =  1;            nPubAddr = (uint16)((uint16)(eqTmnTypeIndex+1) << 11) + (uint16)((uint16)(eqTmnGroupIndex) << 8) + (eqTmnNoIndex+1);            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);            break;		}		case STEP_IDEL_ACK_SEND://空闲时，对i帧应答确认s帧		{			nOutbufLen = s_frame_data_pack(pOutBuff);			g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;			break;		}	        default://任务空闲        {			g_sTaskRunStep.nTaskStep = STEP_CONT_DEFAULT;            break;        }    }	*pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}#endif/******************************************************************************** 函数名称: query_yx_by_detail_zhj* 函数功能: 根据公共地址，信息体地址，查询遥信值* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yx_by_detail_zhj(uint16 nPubAddr, uint32 nInfoAddr, uint8 *nInfoValue, BOOL *bValidFlag){    int i = 0;    uint16 nEquipType = 0;//设备类型    uint16 nEquipGroup = 0;//设备组别    uint16 nEquipNo = 0;//设备序号        nEquipType = (nPubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    nEquipGroup = (nPubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    nEquipNo = nPubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    //判断设备类型是否合法    if((nEquipType == 0) || (nEquipType > MAX_EQUIP_TYPE_NUM))    {        return -1;    }    //判断设备组别是否合法    if(nEquipGroup > MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if((nEquipNo == 0) || (nEquipNo > MAX_EQUIP_COUNT_NUM))    {        return -1;    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYxDataIndexZhj[nEquipType-1][nEquipGroup][nEquipNo-1];    //查找信息点号对应的值    for(i=0; i<g_nConfigYxNumZhj[nEquipType-1][nEquipGroup][nEquipNo-1]; i++)    {        if(nInfoAddr == g_aYxDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            *nInfoValue = g_aYxDataSendZhj[ArrIdx+i].nNewValue;            *bValidFlag = g_aYxDataSendZhj[ArrIdx+i].bNewValidFlag;            return 1;        }    }    return -1;}/******************************************************************************** 函数名称: query_yc_r_by_detail_zhj* 函数功能: 根据公共地址，信息体地址，查询遥测值(短浮点数)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yc_r_by_detail_zhj(uint16 nPubAddr, uint32 nInfoAddr, float32 *fInfoValue, BOOL *bValidFlag){    int i = 0;    uint16 nEquipType = 0;//设备类型    uint16 nEquipGroup = 0;//设备组别    uint16 nEquipNo = 0;//设备序号        nEquipType = (nPubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    nEquipGroup = (nPubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    nEquipNo = nPubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    //判断设备类型是否合法    if((nEquipType == 0) || (nEquipType > MAX_EQUIP_TYPE_NUM))    {        return -1;    }    //判断设备组别是否合法    if(nEquipGroup > MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if((nEquipNo == 0) || (nEquipNo > MAX_EQUIP_COUNT_NUM))    {        return -1;    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[nEquipType-1][nEquipGroup][nEquipNo-1];    //查找信息点号对应的值    for(i=0; i<g_nConfigYcNumZhj[nEquipType-1][nEquipGroup][nEquipNo-1]; i++)    {            if(nInfoAddr == g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            const Map645ToOop *pMap645ToOop = NULL;            float32 fRatio = 1;  //倍率            //读取倍率            pMap645ToOop = oad_info_find(g_aYcDataConfigZhj[ArrIdx+i].nDbCenterOAD);            if(pMap645ToOop == NULL)            {                FRAME104_FMT_TRACE("if(pMap645ToOop == NULL) \n");            }            else            {                fRatio = ratio_convert(pMap645ToOop->DesScaler, E_OOP_TO_REAL);                FRAME104_FMT_TRACE("读取倍率 fRatio=%f \n", fRatio);            }                        *fInfoValue = g_aYcDataSendZhj[ArrIdx+i].fNewValue * fRatio;            *bValidFlag = g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag;            return 1;        }    }    return -1;}/******************************************************************************** 函数名称: query_yc_by_detail_zhj* 函数功能: 根据公共地址，信息体地址，查询遥测值(短浮点数)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yc_str_by_detail_zhj(uint16 nPubAddr, uint32 nInfoAddr, uint8 *nArrLen, uint8 *aArr, BOOL *bValidFlag){    int i = 0;    uint16 nEquipType = 0;//设备类型    uint16 nEquipGroup = 0;//设备组别    uint16 nEquipNo = 0;//设备序号        nEquipType = (nPubAddr>>11) & 0x1f;//设备类型 bit15-bit11 1-30 31表示所有设备    nEquipGroup = (nPubAddr>>8) & 0x07;//设备组号 bit10-bit8 0-6 7表示所有设备    nEquipNo = nPubAddr & 0xff;//设备序号 1-254 255表示该类型所有设备    //判断设备类型是否合法    if((nEquipType == 0) || (nEquipType > MAX_EQUIP_TYPE_NUM))    {        return -1;    }    //判断设备组别是否合法    if(nEquipGroup > MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if((nEquipNo == 0) || (nEquipNo > MAX_EQUIP_COUNT_NUM))    {        return -1;    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[nEquipType-1][nEquipGroup][nEquipNo-1];    //查找信息点号对应的值    for(i=0; i<g_nConfigYcNumZhj[nEquipType-1][nEquipGroup][nEquipNo-1]; i++)    {        if(nInfoAddr == g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            *nArrLen = g_aYcDataConfigZhj[ArrIdx+i].nArrLen;            memcpy(aArr, g_aYcDataSendZhj[ArrIdx+i].aNewArrValue, g_aYcDataConfigZhj[ArrIdx+i].nArrLen);            *bValidFlag = g_aYcDataSendZhj[ArrIdx+i].bNewValidFlag;            return 1;        }    }    return -1;}/******************************************************************************** 函数名称: check_info_addr_type_zhj* 函数功能: 判断信息体的地址为遥测，还是遥信* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int check_info_addr_type_zhj(uint32 nInfoAddr){    uint8 type = INFO_ADDR_TYPE_NULL;        if(nInfoAddr >= 0x00000001 && nInfoAddr < 0x00008000)//不带时标遥测    {        type = INFO_ADDR_TYPE_YC;    }    else if(nInfoAddr >= 0x00008001 && nInfoAddr < 0x00010000)//参数    {        type = INFO_ADDR_TYPE_PARA;    }    else if(nInfoAddr >= 0x00010001 && nInfoAddr < 0x00020000)//带时标遥测    {        type = INFO_ADDR_TYPE_YC;    }    else if(nInfoAddr >= 0x00020001 && nInfoAddr < 0x00030000)//变长比特串    {        type = INFO_ADDR_TYPE_YC;    }    else if(nInfoAddr >= 0x00100001 && nInfoAddr < 0x00110000)//遥信    {        type = INFO_ADDR_TYPE_YX;    }    else if(nInfoAddr >= 0x00200001 && nInfoAddr < 0x00210000)//电能量 不带时标    {        type = INFO_ADDR_TYPE_YC;    }    else    {        type = INFO_ADDR_TYPE_NULL;    }    return type;}/******************************************************************************** 函数名称: query_yc_ratio_config_zhj* 函数功能: 查找遥测点表中的上报系数* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int query_yc_ratio_config_zhj(uint16 eqtypeIndex, uint16 eqgroupIndex, uint16 eqnoIndex, uint32 InfoAddr, int *ratio){    //判断设备类型是否合法    if(eqtypeIndex >= MAX_EQUIP_TYPE_NUM)    {        return -1;    }    //判断设备组别是否合法    if(eqgroupIndex >= MAX_EQUIP_GROUP_NUM)    {        return -1;    }    //判断设备序号是否合法    if(eqnoIndex >= MAX_EQUIP_COUNT_NUM)    {        return -1;    }    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aYcDataIndexZhj[eqtypeIndex][eqgroupIndex][eqnoIndex];        int i = 0;    for(i=0; i<g_nConfigYcNumZhj[eqtypeIndex][eqgroupIndex][eqnoIndex]; i++)    {        if(InfoAddr == g_aYcDataConfigZhj[ArrIdx+i].nObjAddrU32)        {            *ratio = g_aYcDataConfigZhj[ArrIdx+i].nReportRatio;            return 1;        }    }    return -1;}/******************************************************************************** 函数名称: check_frozen_time_zhj* 函数功能: 判断当前时间是否达到冻结周期* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int check_frozen_time_zhj(uint16 nGroupIndex, uint16 nNoIndex, uint16 nTaskIndex, OOP_DATETIME_S_T stCurrentTime, time_t tCurrentTime){    int ret = -1;    uint32 tDiffSecValue = 0; //时间差值 单位秒    uint32 tDiffMonValue = 0; //时间差值 单位月    int x = nGroupIndex;//终端组别    int i = nNoIndex;//终端序号    int j = nTaskIndex;//任务序号    OOP_DATETIME_S_T stTempTime;//临时变量    time_t tTempTime;//临时变量    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[x][i];    switch(g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodUnit)    {        case 0x02://分钟        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tFrozenTime) < 10)            {                break;            }                        tDiffSecValue = tCurrentTime - g_aReportTaskConfig[ArrIdx+j].tFrozenBaseTime;            if(0 == tDiffSecValue%(g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodValue*60))            {                ret = 1;            }        }            break;                case 0x03://小时        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tFrozenTime) < 10)            {                break;            }                        tDiffSecValue = tCurrentTime - g_aReportTaskConfig[ArrIdx+j].tFrozenBaseTime;            if(0 == tDiffSecValue%(g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodValue*60*60))            {                ret = 1;            }        }            break;                case 0x04://日        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tFrozenTime) < 10)            {                break;            }                        tDiffSecValue = tCurrentTime - g_aReportTaskConfig[ArrIdx+j].tFrozenBaseTime;            if(0 == tDiffSecValue%(g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodValue*24*60*60))            {                ret = 1;            }        }            break;                case 0x05://月        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tFrozenTime) < 10)            {                break;            }            memcpy(&stTempTime, &stCurrentTime, sizeof(OOP_DATETIME_S_T));            stTempTime.year = g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.year;            stTempTime.month = g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.month;            ooptm_to_systm(stTempTime, &tTempTime);            tDiffSecValue = tTempTime - g_aReportTaskConfig[ArrIdx+j].tFrozenBaseTime;            tDiffMonValue = (stCurrentTime.year*12 + stCurrentTime.month) -                 (g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.year*12 + g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.month);            if( (0 == (tDiffMonValue%g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodValue))                && (0 == tDiffSecValue))            {                ret = 1;            }        }            break;                default:            break;    }    return ret;}/******************************************************************************** 函数名称: check_report_time_zhj* 函数功能: 判断当前时间是否达到上报周期* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int check_report_time_zhj(uint16 nGroupIndex, uint16 nNoIndex, uint16 nTaskIndex, OOP_DATETIME_S_T stCurrentTime, time_t tCurrentTime){    int ret = -1;    uint32 tDiffSecValue = 0; //时间差值 单位秒    uint32 tDiffMonValue = 0; //时间差值 单位月    int x = nGroupIndex;//终端组别    int i = nNoIndex;//终端序号    int j = nTaskIndex;//任务序号    OOP_DATETIME_S_T stTempTime;//临时变量    time_t tTempTime;//临时变量    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[x][i];    switch(g_aReportTaskConfig[ArrIdx+j].nReportPeriodUnit)    {        case 0x02://分钟        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tReportTime) < 10)            {                break;            }                        tDiffSecValue = tCurrentTime - g_aReportTaskConfig[ArrIdx+j].tReportBaseTime;            if(0 == tDiffSecValue%(g_aReportTaskConfig[ArrIdx+j].nReportPeriodValue*60))            {                ret = 1;            }        }            break;                case 0x03://小时        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tReportTime) < 10)            {                break;            }                        tDiffSecValue = tCurrentTime - g_aReportTaskConfig[ArrIdx+j].tReportBaseTime;            if(0 == tDiffSecValue%(g_aReportTaskConfig[ArrIdx+j].nReportPeriodValue*60*60))            {                ret = 1;            }        }            break;                case 0x04://日        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tReportTime) < 10)            {                break;            }                        tDiffSecValue = tCurrentTime - g_aReportTaskConfig[ArrIdx+j].tReportBaseTime;            if(0 == tDiffSecValue%(g_aReportTaskConfig[ArrIdx+j].nReportPeriodValue*24*60*60))            {                ret = 1;            }        }            break;                case 0x05://月        {            //两次冻结时间间隔至少为1分钟            if(abs(tCurrentTime - g_aReportTaskData[ArrIdx+j].tReportTime) < 10)            {                break;            }            memcpy(&stTempTime, &stCurrentTime, sizeof(OOP_DATETIME_S_T));            stTempTime.year = g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.year;            stTempTime.month = g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.month;            ooptm_to_systm(stTempTime, &tTempTime);            tDiffSecValue = tTempTime - g_aReportTaskConfig[ArrIdx+j].tReportBaseTime;            tDiffMonValue = (stCurrentTime.year*12 + stCurrentTime.month) -                 (g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.year*12 + g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.month);            if( (0 == (tDiffMonValue%g_aReportTaskConfig[ArrIdx+j].nReportPeriodValue))                && (0 == tDiffSecValue))            {                ret = 1;            }        }            break;                default:            break;    }    return ret;}/******************************************************************************** 函数名称: save_frozen_data_zhj* 函数功能: 存储当前冻结数据* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int save_frozen_data_zhj(uint16 nGroupIndex, uint16 nNoIndex, uint16 nTaskIndex, REPORT_TASK_DATA_ZHJ stFrozenData){    int i = nGroupIndex;//设备组号 下标    int j = nNoIndex;//设备组内偏移地址 下标    int k = nTaskIndex;//任务 下标    uint16 nNowNum = g_aHisFrozenDataNum[i][j][k];//当前已经存储的历史数据数    //历史冻结数据结构体    int fileret = 0;    REPORT_TASK_DATA_ZHJ aHisFrozenData[FROZEN_SAVE_DEPTH_MAX];//内容    memset(aHisFrozenData, 0x00, sizeof(aHisFrozenData));    fileret = his_frozen_file_read_zhj(nGroupIndex, nNoIndex, nTaskIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_read_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             nGroupIndex, nNoIndex, nTaskIndex, fileret);    }    int m = 0;    if(nNowNum < FROZEN_SAVE_DEPTH_MAX)    {        aHisFrozenData[nNowNum] = stFrozenData;        g_aHisFrozenDataNum[i][j][k] += 1;    }    else if(nNowNum == FROZEN_SAVE_DEPTH_MAX)    {        for(m=0; m<(FROZEN_SAVE_DEPTH_MAX-1); m++)        {            //所有的元素往前挪动一位, 空出最后一个位置            aHisFrozenData[m] = aHisFrozenData[m+1];        }        //最后一个位置赋为最新数据        aHisFrozenData[FROZEN_SAVE_DEPTH_MAX-1] = stFrozenData;    }    else    {        return -1;    }    //历史冻结数据结构体    fileret = his_frozen_file_write_zhj(nGroupIndex, nNoIndex, nTaskIndex, (char *)&aHisFrozenData[0], sizeof(aHisFrozenData));    if(fileret < 0)    {        FRAME104_FMT_TRACE("his_frozen_file_write_zhj() 组别下标=%d, 序号下标=%d, 任务下标=%d, ret=%d \n",             nGroupIndex, nNoIndex, nTaskIndex, fileret);    }    return 1;}/******************************************************************************** 函数名称: timing_active_send* 函数功能: 系统定时任务，104规约处理背景扫描或循环上报数据* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/void timing_active_send_zhj(){    int x = 0;//终端组别    int i = 0;//终端序号    int j = 0;//任务序号    int k = 0;//信息元素序号    uint32 ArrIdx = 0;//一维数组索引(起始)        time_t tCurrentTime; //系统当前时间    time(&tCurrentTime); //获取time_t类型的当前时间    //uint32 tDiffValue = 0; //时间差值    OOP_DATETIME_S_T stCurrentTime; //获取结构体类型的当前时间    systm_to_ooptm(tCurrentTime, &stCurrentTime);    //FRAME104_FMT_DEBUG("当前最新时间 %d-%d-%d %d:%d:%d \n", stCurrentTime.year, stCurrentTime.month,       stCurrentTime.day, stCurrentTime.hour, stCurrentTime.minute, stCurrentTime.second);    //冻结数据    for(x=0; x<g_aGroupCountZhj[E_EQUIP_POWERTERMINAL-1]; x++)//终端组别    {        for(i=0; i<g_aEquipCountZhj[E_EQUIP_POWERTERMINAL-1][x]; i++)//终端序号        {            ArrIdx = g_aReportTaskIndex[x][i];            for(j=0; j<MAX_REPORT_TASK_NUM; j++)            {                if(g_aReportTaskConfig[ArrIdx+j].bIsValid == 0)                {                    continue;//任务无效                }                if(g_aReportTaskConfig[ArrIdx+j].bIsCorrect == 0)                {                    continue;//配置错误, 任务无效                }                if(g_aReportTaskConfig[ArrIdx+j].nReportDataType == TASK_DATA_FROZEN)//冻结任务                {                    if(check_frozen_time_zhj(x, i, j, stCurrentTime, tCurrentTime) > 0)                    {                        FRAME104_FMT_TRACE("终端组别下标x=%d, 设备下标i=%d, 任务下标j=%d, 达到冻结周期! \n", x, i, j);                        FRAME104_FMT_TRACE("冻结基准时间 %d-%d-%d %d:%d:%d, 冻结周期 %d, 周期单位 %d \n", g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.year, g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.month,                             g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.day, g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.hour, g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.minute,                             g_aReportTaskConfig[ArrIdx+j].stFrozenBaseTime.second, g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodValue, g_aReportTaskConfig[ArrIdx+j].nFrozenPeriodUnit);                        FRAME104_FMT_TRACE("当前最新时间 %d-%d-%d %d:%d:%d \n", stCurrentTime.year, stCurrentTime.month,       stCurrentTime.day, stCurrentTime.hour, stCurrentTime.minute, stCurrentTime.second);                        for(k=0; k<g_aReportTaskConfig[ArrIdx+j].nRealInfoItemNum; k++)                        {                            if(M_SP_NA_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k])                            {                                //单点遥信                                query_yx_by_detail_zhj(g_aReportTaskConfig[ArrIdx+j].aPublicAddr[k], g_aReportTaskConfig[ArrIdx+j].aInfoItemAddr[k], &g_aReportTaskData[ArrIdx+j].aYxFrozenValue[k],                                     &g_aReportTaskData[ArrIdx+j].bValidFlag[k]);                            }                            else if(M_ME_NC_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k]                                || M_ME_TF_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k]                                || M_IT_NB_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k])                            {                                //浮点型遥测                                query_yc_r_by_detail_zhj(g_aReportTaskConfig[ArrIdx+j].aPublicAddr[k], g_aReportTaskConfig[ArrIdx+j].aInfoItemAddr[k], &g_aReportTaskData[ArrIdx+j].aYcFrozenValue[k],                                     &g_aReportTaskData[ArrIdx+j].bValidFlag[k]);                            }                            else if(M_VBO_TB_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k])                            {                                //比特串遥测                                query_yc_str_by_detail_zhj(g_aReportTaskConfig[ArrIdx+j].aPublicAddr[k], g_aReportTaskConfig[ArrIdx+j].aInfoItemAddr[k], &g_aReportTaskData[ArrIdx+j].nFrozenArrLen[k], g_aReportTaskData[ArrIdx+j].aFrozenArrValue[k],                                     &g_aReportTaskData[ArrIdx+j].bValidFlag[k]);                            }                        }                        //冻结时间                        system_time_get(g_aReportTaskData[ArrIdx+j].aFrozenTime);                        g_aReportTaskData[ArrIdx+j].tFrozenTime = tCurrentTime;                        memcpy(&g_aReportTaskData[ArrIdx+j].stFrozenTime, &stCurrentTime, sizeof(OOP_DATETIME_S_T));                        //存入历史队列                        FRAME104_FMT_TRACE("存储之前 历史记录数量=%d \n", g_aHisFrozenDataNum[x][i][j]);                        save_frozen_data_zhj(x, i, j, g_aReportTaskData[ArrIdx+j]);                        FRAME104_FMT_TRACE("存储之后 历史记录数量=%d \n", g_aHisFrozenDataNum[x][i][j]);                    }                }                else if(g_aReportTaskConfig[ArrIdx+j].nReportDataType == TASK_DATA_REALTIME)//实时任务                {                    if(1)                    {                        for(k=0; k<g_aReportTaskConfig[ArrIdx+j].nRealInfoItemNum; k++)                        {                            if(M_SP_NA_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k])                            {                                //单点遥信                                query_yx_by_detail_zhj(g_aReportTaskConfig[ArrIdx+j].aPublicAddr[k], g_aReportTaskConfig[ArrIdx+j].aInfoItemAddr[k], &g_aReportTaskData[ArrIdx+j].aYxFrozenValue[k],                                     &g_aReportTaskData[ArrIdx+j].bValidFlag[k]);                            }                            else if(M_ME_NC_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k]                                || M_ME_TF_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k]                                || M_IT_NB_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k])                            {                                //浮点型遥测                                query_yc_r_by_detail_zhj(g_aReportTaskConfig[ArrIdx+j].aPublicAddr[k], g_aReportTaskConfig[ArrIdx+j].aInfoItemAddr[k], &g_aReportTaskData[ArrIdx+j].aYcFrozenValue[k],                                     &g_aReportTaskData[ArrIdx+j].bValidFlag[k]);                            }                            else if(M_VBO_TB_1 == g_aReportTaskConfig[ArrIdx+j].aSignalType[k])                            {                                //比特串遥测                                query_yc_str_by_detail_zhj(g_aReportTaskConfig[ArrIdx+j].aPublicAddr[k], g_aReportTaskConfig[ArrIdx+j].aInfoItemAddr[k], &g_aReportTaskData[ArrIdx+j].nFrozenArrLen[k], g_aReportTaskData[ArrIdx+j].aFrozenArrValue[k],                                     &g_aReportTaskData[ArrIdx+j].bValidFlag[k]);                            }                        }                    }                }                            }        }        //任务上报        if(1)//if(g_bDataSendFlag == 2)    	{    	    for(x=0; x<g_aGroupCountZhj[E_EQUIP_POWERTERMINAL-1]; x++)//终端组别            {                for(i=0; i<g_aEquipCountZhj[E_EQUIP_POWERTERMINAL-1][x]; i++)                {                    ArrIdx = g_aReportTaskIndex[x][i];                    for(j=0; j<MAX_REPORT_TASK_NUM; j++)                    {                        if(g_aReportTaskConfig[ArrIdx+j].bIsValid == 0)                        {                            continue;//任务无效                        }                        if(g_aReportTaskConfig[ArrIdx+j].bIsCorrect == 0)                        {                            continue;//配置错误, 任务无效                        }                        if(check_report_time_zhj(x, i, j, stCurrentTime, tCurrentTime) > 0)                        {                            FRAME104_FMT_TRACE("终端组别下标x=%d, 设备下标i=%d, 任务下标j=%d, 达到上报周期! \n", x, i, j);                            FRAME104_FMT_TRACE("上报基准时间 %d-%d-%d %d:%d:%d, 上报周期 %d, 周期单位:%d \n", g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.year, g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.month,                             g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.day, g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.hour, g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.minute,                             g_aReportTaskConfig[ArrIdx+j].stReportBaseTime.second, g_aReportTaskConfig[ArrIdx+j].nReportPeriodValue, g_aReportTaskConfig[ArrIdx+j].nReportPeriodUnit);                            FRAME104_FMT_TRACE("当前最新时间 %d-%d-%d %d:%d:%d \n", stCurrentTime.year, stCurrentTime.month,       stCurrentTime.day, stCurrentTime.hour, stCurrentTime.minute, stCurrentTime.second);                            //任务上报状态                            g_aReportTaskState[x][i][j] = 1;                            //公共地址上报状态                            memset(&g_aReportTaskPubAddrState[x][i][j][0], 0x01, g_aReportTaskPubAddrNum[x][i][j]);                            //上报时间                            system_time_get(g_aReportTaskData[ArrIdx+j].aReportTime);                            g_aReportTaskData[ArrIdx+j].tReportTime = tCurrentTime;                            memcpy(&g_aReportTaskData[ArrIdx+j].stReportTime, &stCurrentTime, sizeof(OOP_DATETIME_S_T));                        }                    }            }            }    	}    }	}/******************************************************************************** 函数名称: move_to_next_task_zhj* 函数功能: 获取下一个终端设备编号和数据冻结上报任务(数组下标)* 输入参数: nType 上报数据类型 1实时 2冻结* 输出参数: 无* 返 回 值: 无*******************************************************************************/int move_to_next_task_zhj(uint8 nType){    int x = 0;    int i = 0;    int j = 0;    uint16 nowEqCountIndex = g_sTimingTaskRunStep.nEquipGroupIndex;//终端设备组别    uint16 nowEqNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;//终端设备编号    uint16 nowEqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;//任务下标    uint32 ArrIdx = 0;//一维数组索引(起始)    for(x=nowEqCountIndex; i<MAX_EQUIP_GROUP_NUM; i++)    {        for(i=nowEqNoIndex; i<MAX_EQUIP_COUNT_NUM; i++)        {            ArrIdx = g_aReportTaskIndex[x][i];            for(j=nowEqTaskNoIndex; j<MAX_REPORT_TASK_NUM; j++)            {                //任务有效，并且需要上报                if(g_aReportTaskConfig[ArrIdx+j].bIsValid == 1 &&                     g_aReportTaskConfig[ArrIdx+j].bIsCorrect == 1 &&                     g_aReportTaskState[x][i][j] == 1)                {                    //上报数据类型 1实时 2冻结                    if(g_aReportTaskConfig[ArrIdx+j].nReportDataType == nType)                    {                        g_sTimingTaskRunStep.nEquipGroupIndex = x;                        g_sTimingTaskRunStep.nEquipNoIndex = i;                        g_sTimingTaskRunStep.nEqTaskNoIndex = j;                        return 1;                    }                }            }            nowEqTaskNoIndex = 0;        }        nowEqNoIndex = 0;    }    g_sTimingTaskRunStep.nEquipGroupIndex = 0;    g_sTimingTaskRunStep.nEquipNoIndex = 0;    g_sTimingTaskRunStep.nEqTaskNoIndex = 0;    return -1;}/******************************************************************************** 函数名称: move_to_next_task_pub_zhj* 函数功能: 获取下一个终端设备编号和数据冻结上报任务的公共地址(数组下标)* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int move_to_next_task_pub_zhj(){    int i = 0;    uint16 nowEqCountIndex = g_sTimingTaskRunStep.nEquipGroupIndex;//终端设备组别    uint16 nowEqNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;//终端设备编号    uint16 nowEqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;//任务下标    uint16 nowTaskPubIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;//公共地址下标    for(i=nowTaskPubIndex; i<g_aReportTaskPubAddrNum[nowEqCountIndex][nowEqNoIndex][nowEqTaskNoIndex]; i++)    {        if(1 == g_aReportTaskPubAddrState[nowEqCountIndex][nowEqNoIndex][nowEqTaskNoIndex][i])        {            g_sTimingTaskRunStep.nTaskPubAddrIndex = i;            return 1;        }    }        g_sTimingTaskRunStep.nTaskPubAddrIndex = 0;    return -1;}/*********************************************************************所属功能单元：yx_timing_get_zhj功能描述	：实时任务 上送遥信输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yx_timing_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_SP_NA_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//单点遥信数值			pData[index++] = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYxFrozenValue[i];			//带时标			memcpy(&pData[index], &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);			index += 7;			FRAME104_FMT_TRACE("实时任务遥信 yx_timing_get_zhj() eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, FrozenValue:%d \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYxFrozenValue[i]);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_timing_r_get_zhj功能描述	： 实时任务 上送遥测 短浮点输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_timing_r_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_ME_NC_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);			index += 7;			FRAME104_FMT_TRACE("实时任务遥测 (短浮点数)yc_timing_r_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_timing_r_t_get_zhj功能描述	： 实时任务 上送遥测 短浮点 带时标输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_timing_r_t_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_ME_TF_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);			index += 7;			FRAME104_FMT_TRACE("实时任务遥测 (短浮点数 带时标)yc_timing_r_t_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元： yc_timing_en_get_zhj功能描述	： 实时任务 上送遥测 短浮点 电量输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_timing_en_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){	int i = 0;	int j = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 getnum_bk = 0;//备份最大允许上报个数	uint8 len = 0;	uint8 index = 0;    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;	getnum_bk = *pGetNum;	*pGetNum = 0; 	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return 0;	}	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_IT_NB_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);			index += 7;			FRAME104_FMT_TRACE("实时任务遥测(短浮点数 电量)yc_timing_en_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]);			//判断已经获取的个数是否达到允许最大个数			j++;			*pGetNum = j;			if(j >= getnum_bk)				break;		}	}	//计算下一次的起始位置	*pStartNum = i+1;		len = index;	return len;}/*********************************************************************所属功能单元：yc_timing_str_get_zhj功能描述	： 实时任务 上送遥测 比特串输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/uint8 yc_timing_str_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pGetNum){    int i = 0;    int j = 0;    uint16 startnum_bk = 0;//备份起始序号    uint8 getnum_bk = 0;//备份最大允许上报个数    uint8 len = 0;    uint8 index = 0;    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];        startnum_bk = *pStartNum;    getnum_bk = *pGetNum;    *pGetNum = 0;     if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)    {        return 0;    }    //将数据填写返回区    for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)    {        if(M_VBO_TB_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))        {            //信息体地址            memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);            pData[index++] = addr[0];            pData[index++] = addr[1];            if(bAdulen == 3)            {                pData[index++] = addr[2];            }            //比特串长度            pData[index++] = g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i];            //比特串内容            memcpy(&pData[index], g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenArrValue[i], g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i]);			index += g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i];			//品质            if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            //带时标            memcpy(&pData[index], &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);            index += 7;            FRAME104_FMT_TRACE("实时任务遥测(比特串)yc_timing_str_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, nFrozenArrLen:%d \n",                 eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i],                 i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i]);            FRAME104_BUF_TRACE(g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenArrValue[i], g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i], "字符串:");            //判断已经获取的个数是否达到允许最大个数            j++;            *pGetNum = j;            if(j >= getnum_bk)                break;        }    }    //计算下一次的起始位置    *pStartNum = i+1;        len = index;    return len;}/*********************************************************************所属功能单元：yc_timing_get功能描述	：周期任务遥测上报输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_timing_get_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	//int    result = 0;	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;	uint8 nSendInObjLen = 0;	//uint8 pBackInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于备份	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容    uint16 nTaskPubAddrIndex = 0;//公共地址编号    uint16 nPubAddr = 0;    	uint8  bgetnum = 0;	*pAppType = APP_TYPE_NOMMAL;	switch (g_sTimingTaskRunStep.nSubDataCallSetp)	{		case YC_TIMING_STEP_SEND_R://实时数据周期上报遥测信息（短浮点数）        {            nSendTI = M_ME_TF_1;            nSendCOT = 0x01 + (uint16)(((uint8)(g_sTimingTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_timing_r_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("实时数据周期上报遥测信息（短浮点数），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-没有更多数据需要上报-                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R_T;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R_T;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;            nPubAddr = g_aReportTaskPubAddr[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case YC_TIMING_STEP_SEND_R_T://实时数据周期上报遥测信息（短浮点数 带时标）        {            nSendTI = M_ME_TF_1;            nSendCOT = 0x01 + (uint16)(((uint8)(g_sTimingTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_timing_r_t_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("实时数据周期上报遥测信息（短浮点数 带时标），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-没有更多数据需要上报-                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_EN;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_EN;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;            nPubAddr = g_aReportTaskPubAddr[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case YC_TIMING_STEP_SEND_EN://实时数据周期上报遥测信息（短浮点数 电量）        {            nSendTI = M_IT_TC_1;            nSendCOT = 0x01 + (uint16)(((uint8)(g_sTimingTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint8 nSendNumMax = 15;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_timing_en_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("实时数据周期上报遥测信息（短浮点数 电量），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-没有更多数据需要上报-                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_STR;                }                break;            }			else if(bgetnum < nSendNumMax)			{			    g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_STR;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;            nPubAddr = g_aReportTaskPubAddr[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }        case YC_TIMING_STEP_SEND_STR://上报实时任务遥测信息（比特串）        {            nSendTI = M_VBO_TB_1;            nSendCOT = 0x01 + (uint16)(((uint8)(g_sTimingTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint8 nSendNumMax = 10;  //单次上送信号的最大个数(255-12)/(3+4+1+7)            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            bgetnum = nSendNumMax;  //单次上送信号的最大个数            nSendInObjLen  = yc_timing_str_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);            FRAME104_FMT_TRACE("实时数据周期上报遥测信息（比特串），返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);            if(bgetnum == 0)            {                //当前公共地址上报结束                g_aReportTaskPubAddrState[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][g_sTimingTaskRunStep.nTaskPubAddrIndex] = 0;                                if(move_to_next_task_pub_zhj() < 0)//所有公共地址类型均上报                {                    //当前周期上报任务结束，标志置0（先遥信，后遥测）                    g_aReportTaskState[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex] = 0;                    g_sTimingTaskRunStep.nStartNum = 0;                    if(1)                    {                        //-没有更多数据需要上报-                        g_sTimingTaskRunStep.nTaskStep = STEP_FROZEN_TASK_SEND;                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                    }                }                else                {                    g_sTimingTaskRunStep.nStartNum = 0;                    g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;                }                                break;            }			else if(bgetnum < nSendNumMax)			{			    //当前公共地址上报结束                g_aReportTaskPubAddrState[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][g_sTimingTaskRunStep.nTaskPubAddrIndex] = 0;                                if(move_to_next_task_pub_zhj() < 0)//所有公共地址类型均上报                {                    //当前周期上报任务结束，标志置0（先遥信，后遥测）                    g_aReportTaskState[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex] = 0;                    g_sTimingTaskRunStep.nStartNum = 0;                    if(1)                    {                        //-没有更多数据需要上报-                        g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;                    }                }                else                {                    g_sTimingTaskRunStep.nStartNum = 0;                    g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;			}            nSendVSQ =  bgetnum;            nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;            nPubAddr = g_aReportTaskPubAddr[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];            nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);			break;        }		default:        {            g_sTimingTaskRunStep.nTaskStep = STEP_FROZEN_TASK_SEND;            g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;            break;        }	}	*pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}/*********************************************************************所属功能单元： yx_frozen_get_zhj功能描述	：获取周期冻结与上报的遥信数据输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yx_frozen_get_zhj(uint8 bAdulen, uint8 *pData, uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;    //int ret = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_SP_NA_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{            if( (index+3+1) > leftlen )//3地址+1值            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//单点遥信数值			pData[index++] = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYxFrozenValue[i];			FRAME104_FMT_TRACE("周期冻结遥信 yx_frozen_get_zhj() eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, FrozenValue:%d \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYxFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}    pData[0] = count;//更新信息体数量    *pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_r_get_zhj功能描述	：获取周期冻结与上报的遥测数据（短浮点数）输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yc_frozen_r_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位	    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_ME_NC_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{		    if( (index+3+4+1) > leftlen )//3地址+4值+1品质            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			FRAME104_FMT_TRACE("周期冻结遥测(短浮点数) yc_frozen_r_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}	pData[0] = count;//更新信息体数量	*pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_r_t_get_zhj功能描述	：获取周期冻结与上报的遥测数据（短浮点数 带时标）输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yc_frozen_r_t_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位	    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_ME_TF_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{		    if( (index+3+4+1+7) > leftlen )//3地址+4值+1品质+7时标            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			//带时标			memcpy(&pData[index], &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);			index += 7;			FRAME104_FMT_TRACE("周期冻结遥测(短浮点数 带时标) yc_frozen_r_t_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}	pData[0] = count;//更新信息体数量	*pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_en_get_zhj功能描述	：获取周期冻结与上报的遥测数据（短浮点数 电量）输入参数	：	输出参数	：		  函数返回值	：是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕*******************************************************************/int yc_frozen_en_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){	int i = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位	    int nReportRatio = 0;  //点表配置的上送倍率系数	float32 fRatio = 1;  //上报调度倍率	float32 fConvertValue = 0;  //上报调度的值需要乘以系数    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];		startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值	//将数据填写返回区	for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)	{		if(M_IT_NB_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))		{		    if( (index+3+4+1) > leftlen )//3地址+4值+1品质            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }            			//信息体地址    		memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);    		pData[index++] = addr[0];    		pData[index++] = addr[1];    		if(bAdulen == 3)    		{    			pData[index++] = addr[2];    		}			//浮点型数值			query_yc_ratio_config_zhj(E_EQUIP_POWERTERMINAL-1, eqTmnGroupIndex, eqTmnNoIndex, 			    g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], &nReportRatio);			fRatio = ratio_convert(nReportRatio, E_REAL_TO_DISPATCH);			fConvertValue = g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]*fRatio;			FRAME104_FMT_TRACE("fConvertValue=%f, aYcFrozenValue=%f, fRatio=%f \n", fConvertValue, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i], fRatio);			memcpy((void *)&pData[index], (void *)&fConvertValue, sizeof(float32));			index += sizeof(float32);			//品质			if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }			FRAME104_FMT_TRACE("周期冻结遥测(短浮点数 电量) yc_frozen_en_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, fFrozenValue:%f \n", 				eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 				i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].aYcFrozenValue[i]);			//累计信息体个数			count++;		}        //计算下一次的起始位置	    *pStartNum = i+1;	}	pData[0] = count;//更新信息体数量	*pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元：yc_timing_str_get_zhj功能描述	：获取周期冻结与上报的遥测数据（比特串）输入参数	：bStartNum-数据队列的位置，*pGetNum，想要获取的数据个数	输出参数	：*pdata-返回数据缓冲区，返回数据个数*pGetNum 		  函数返回值	：返回数据的长度*******************************************************************/int yc_frozen_str_get_zhj(uint8 bAdulen, uint8 *pData ,uint16 *pStartNum,uint8 *pCurrLen, uint8 nMaxLen){    int i = 0;	//int ret = 0;	uint16 startnum_bk = 0;//备份起始序号	uint8 currlen_bk = 0;//备份当前信息体长度	uint8 leftlen = 0;//剩余可填充长度	uint8 count = 0;//当前类型信息体个数	uint8 index = 0;//偏移位    uint16 eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;    uint16 eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;    uint16 eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;    uint16 nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;    uint16 nPubAddr = g_aReportTaskPubAddr[eqTmnGroupIndex][eqTmnNoIndex][eqTaskNoIndex][nTaskPubAddrIndex];    uint8 addr[4] = {0};//信息体地址    uint32 ArrIdx = 0;//一维数组索引(起始)    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];        startnum_bk = *pStartNum;    currlen_bk = *pCurrLen;    leftlen = nMaxLen - currlen_bk;    pData[index++] = count;//初始值    //将数据填写返回区    for(i=startnum_bk; i<g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum; i++)    {        if(M_VBO_TB_1 == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aSignalType[i]            && (nPubAddr == g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aPublicAddr[i]))        {            if( (index+3+1+g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i]+1) > leftlen )//3地址+1长度+变长内容+1品质            {                //计算下一次的起始位置	            *pStartNum = i;                break;            }                        //信息体地址            memcpy(addr, &g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i], 4);            pData[index++] = addr[0];            pData[index++] = addr[1];            if(bAdulen == 3)            {                pData[index++] = addr[2];            }            //比特串长度            pData[index++] = g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i];            //比特串内容            memcpy(&pData[index], g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenArrValue[i], g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i]);			index += g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i];			//品质            if(g_aReportTaskData[ArrIdx+eqTaskNoIndex].bValidFlag[i])            {                pData[index++] = 0;            }            else            {                pData[index++] = 0x80;//bit8 0有效 1无效            }            FRAME104_FMT_TRACE("周期冻结遥测(比特串)yc_timing_str_get_zhj()后 eqTmnGroupIndex=%d, eqTmnNoIndex=%d, eqTaskNoIndex=%d, addr=%08x, i=%d, nFrozenArrLen:%d \n",                 eqTmnGroupIndex, eqTmnNoIndex, eqTaskNoIndex, g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].aInfoItemAddr[i],                 i, g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i]);            FRAME104_BUF_TRACE(g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenArrValue[i], g_aReportTaskData[ArrIdx+eqTaskNoIndex].nFrozenArrLen[i], "字符串:");            //累计信息体个数			count++;        }        //计算下一次的起始位置	    *pStartNum = i+1;    }    pData[0] = count;//更新信息体数量    *pCurrLen += index;//更新信息体报文长度	//判断当前序号是否达到任务信息体数量	startnum_bk = *pStartNum;	if(startnum_bk >= g_aReportTaskConfig[ArrIdx+eqTaskNoIndex].nRealInfoItemNum)	{		return -1;	}		return 1;}/*********************************************************************所属功能单元： yc_frozen_get_zhj功能描述	：冻结数据周期上报 遥测输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_frozen_get_zhj(uint8 bAdulen, uint8 *pData, uint8 *pCurrLen, uint8 nMaxLen){	int ret = 0;//是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕	uint8 nSendInObjLen = 0;    	switch (g_sTimingTaskRunStep.nSubDataCallSetp)	{		case YC_TIMING_STEP_SEND_R://实时数据周期上报遥测信息（短浮点数）        {            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_r_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("冻结数据周期上报 遥测信息（短浮点数），返回数据长度 nSendInObjLen=%d, nMaxLen=%d, nStartIndex=%d, *pCurrLen=%d, ret=%d \n", *pCurrLen, nMaxLen, nStartIndex, *pCurrLen, ret);            if(ret < 0)			{			    g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R_T;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;                pData[(*pCurrLen)++] = 0x00;//遥测个数(带时标)                pData[(*pCurrLen)++] = 0x00;//遥测个数(电能量 不带时标)                pData[(*pCurrLen)++] = 0x00;//遥测个数(比特串)                g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTimingTaskRunStep.nFinishFlag = 0;                g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTimingTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_R;			}        }        case YC_TIMING_STEP_SEND_R_T://实时数据周期上报遥测信息（短浮点数 带时标）        {            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_r_t_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("冻结数据周期上报 遥测信息（短浮点数 带时标），返回数据长度 nSendInObjLen=%d, nMaxLen=%d, nStartIndex=%d, ret=%d \n", *pCurrLen, nMaxLen, nStartIndex, ret);            if(ret < 0)			{			    g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_EN;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;                pData[(*pCurrLen)++] = 0x00;//遥测个数(电能量 不带时标)                pData[(*pCurrLen)++] = 0x00;//遥测个数(比特串)                g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTimingTaskRunStep.nFinishFlag = 0;                g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTimingTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_R_T;			}        }        case YC_TIMING_STEP_SEND_EN://实时数据周期上报遥测信息(短浮点数 电量)        {            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_en_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("冻结数据周期上报 遥测信息（短浮点数 电量），返回数据长度 nSendInObjLen=%d, nMaxLen=%d, nStartIndex=%d, ret=%d \n", *pCurrLen, nMaxLen, nStartIndex, ret);            if(ret < 0)			{			    g_sTimingTaskRunStep.nStartNum = 0;                if(1)                {                    //-读取的数量少于要读的数据量，表示本次读取结束-				    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                    g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_STR;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;                pData[(*pCurrLen)++] = 0x00;//遥测个数(比特串)                g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTimingTaskRunStep.nFinishFlag = 0;                g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTimingTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_EN;			}        }        case YC_TIMING_STEP_SEND_STR://上报变化遥测信息（比特串）        {            uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号            nSendInObjLen = *pCurrLen;            ret = yc_frozen_str_get_zhj(bAdulen, pData+nSendInObjLen, &nStartIndex, pCurrLen, nMaxLen);            FRAME104_FMT_TRACE("冻结数据周期上报 遥测信息（比特串），返回数据长度 nSendInObjLen=%d, nMaxLen=%d, nStartIndex=%d, ret=%d \n", *pCurrLen, nMaxLen, nStartIndex, ret);            if(ret < 0)			{			    //当前公共地址上报结束                g_aReportTaskPubAddrState[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][g_sTimingTaskRunStep.nTaskPubAddrIndex] = 0;                                if(move_to_next_task_pub_zhj() < 0)//所有公共地址类型均上报                {                    //当前周期上报任务结束，标志置0（先遥信，后遥测）                    g_aReportTaskState[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex] = 0;                    g_sTimingTaskRunStep.nStartNum = 0;                    if(1)                    {                        //-读取的数量少于要读的数据量，表示本次读取结束-                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                        g_sTimingTaskRunStep.nFinishFlag = 0;                        g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                        //g_sTimingTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;                    }                }                else                {                    g_sTimingTaskRunStep.nStartNum = 0;                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                    g_sTimingTaskRunStep.nFinishFlag = 0;                    g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                    //g_sTimingTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;                }			}			else			{				//-数据未读取完，还要继续读取-				g_sTimingTaskRunStep.nStartNum = nStartIndex;                g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                g_sTimingTaskRunStep.nFinishFlag = 0;                g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YC;                g_sTimingTaskRunStep.nLastSubDataCallSetp = YC_TIMING_STEP_SEND_STR;			}            break;        }		default:        {            g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;            g_sTimingTaskRunStep.nFinishFlag = 1;            break;        }	}    return 1;}/*********************************************************************所属功能单元： yc_refresh_frozen_zhj功能描述	：冻结数据周期上报 遥测输入参数	：输出参数	：函数返回值	：*******************************************************************/int yc_refresh_frozen_zhj(uint8 *pData, uint8 *pCurrLen){    uint8 nSendInObjLen = *pCurrLen;        if( (TIMING_STEP_SEND_YC==g_sTimingTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_R==g_sTimingTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0    }    else if( (TIMING_STEP_SEND_YC==g_sTimingTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_R_T==g_sTimingTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数)数量置0    }    else if( (TIMING_STEP_SEND_YC==g_sTimingTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_EN==g_sTimingTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数)数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数 带时标)数量置0    }    else if( (TIMING_STEP_SEND_YC==g_sTimingTaskRunStep.nLastDataCallStep)         && (YC_TIMING_STEP_SEND_STR==g_sTimingTaskRunStep.nLastSubDataCallSetp) )    {        pData[nSendInObjLen++] = 0;//遥信数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数)数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数 带时标)数量置0        pData[nSendInObjLen++] = 0;//遥测(浮点数 电量)数量置0    }    else    {        return -1;    }    *pCurrLen = nSendInObjLen;    return 1;}/******************************************************************************** 函数名称: timing_active_run_zhj* 函数功能: 数据周期冻结与上报任务* 输入参数: 无* 输出参数: 无* 返 回 值: 无*******************************************************************************/int timing_active_run_zhj(uint8 *pPipeIndex, uint8 *pReportBuf, uint8 *pAppType){	/*	FRAME104_FMT_TRACE("report_task_run() 执行上报任务 g_nNetWorkFlag=%d, nTaskStep=%d, nDataCallStep=%d, nSubDataCallSetp=%d, nStartNum=%d \n", 		g_nNetWorkFlag, g_sTaskRunStep.nTaskStep, g_sTaskRunStep.nDataCallStep, g_sTaskRunStep.nSubDataCallSetp, g_sTaskRunStep.nStartNum);	*/	int nOutbufLen = 0;//返回的发送数据长度	uint8 pOutBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //返回的完整发送数据长度	uint8 nPipeIndex = g_nGlobalPipe;  //收发通道号		uint8 nSendTI = 0;	uint8 nSendVSQ = 0;	uint16 nSendCOT = 0;    uint8 nSendInObjLenMax = 0;	uint8 nSendInObjLen = 0;	uint8 pSendInObjBuff[MAX_INFO_OBJ_DATA_LEN] = {0};  //用于组发送报文中的消息对象集内容    uint16 eqTmnGroupIndex = 0;//设备组别    uint16 eqTmnNoIndex = 0;//设备序号    uint16 eqTaskNoIndex = 0;//任务编号    uint16 nTaskPubAddrIndex = 0;//公共地址编号    uint16 nPubAddr = 0;    uint32 ArrIdx = 0;//一维数组索引(起始)	uint8  bgetnum = 0;    int ret = 0;//是否存在未取出的数据 1是 下一次还要继续获取 -1否 该类型数据全部遍历完毕	*pAppType = APP_TYPE_NOMMAL;		if(g_nNetWorkFlag != PRO_DATA_TRANSMIT)	{		return -1;	}		//任务闪转处理	switch(g_sTimingTaskRunStep.nTaskStep)	{        case STEP_TIMING_TASK_SEND://实时数据周期上报        {        	nPipeIndex = g_nGlobalPipe;            switch(g_sTimingTaskRunStep.nDataCallStep)            {                case TIMING_STEP_SEND_YX://上报所有遥信信息                {                    if(move_to_next_task_zhj(TASK_DATA_REALTIME) < 0)                    {                        g_sTimingTaskRunStep.nTaskStep = STEP_FROZEN_TASK_SEND;                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                        break;//没有需要处理的实时数据周期上报任务                    }                    FRAME104_FMT_TRACE("timing_active_run_zhj() 实时数据周期上报! 终端组别=%d, 终端下标=%d, 任务下标=%d \n",                     g_sTimingTaskRunStep.nEquipGroupIndex, g_sTimingTaskRunStep.nEquipNoIndex, g_sTimingTaskRunStep.nEqTaskNoIndex);                                        nSendTI  =  M_SP_TB_1;                    nSendCOT = 0x01 + (uint16)(((uint8)(g_sTimingTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);  //单次上送信号的最大个数(255-12)/(3+4+1+7)                    uint8 nSendNumMax = 20;  //单次上送信号的最大个数(255-12)/(3+1+7)                    uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号                    bgetnum = nSendNumMax;  //单次上送信号的最大个数                    nSendInObjLen  = yx_timing_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nStartIndex, &bgetnum);                    FRAME104_FMT_TRACE("实时数据周期上报遥信，返回数据长度 nSendInObjLen =%d, bgetnum = %d \n",nSendInObjLen,bgetnum);                    if(bgetnum == 0)                    {                        g_sTimingTaskRunStep.nStartNum = 0;                        if(1)                        {                            //-没有更多数据需要上报-                            g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                            g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R;                        }                        break;                    }        			else if(bgetnum < nSendNumMax)        			{        			    g_sTimingTaskRunStep.nStartNum = 0;                        if(1)                        {                            //-读取的数量少于要读的数据量，表示本次读取结束-            				g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                            g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R;                        }        			}        			else        			{        				//-数据未读取完，还要继续读取-        				g_sTimingTaskRunStep.nStartNum = nStartIndex;        			}                    nSendVSQ =  bgetnum;                    nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;                    nPubAddr = g_aReportTaskPubAddr[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];                    nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);        			break;                }				case TIMING_STEP_SEND_YC://上报所有遥测信息				{					//FRAME104_FMT_TRACE("case ALLDATA_STEP_SEND_YC://上报所有遥测信息 \n");					nOutbufLen = yc_timing_get_zhj(&nPipeIndex, pOutBuff, pAppType);					break;				}                default:                {                    g_sTimingTaskRunStep.nTaskStep = STEP_FROZEN_TASK_SEND;                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                    break;                }            }            break;        }        case STEP_FROZEN_TASK_SEND://冻结数据周期上报        {        	nPipeIndex = g_nGlobalPipe;            switch(g_sTimingTaskRunStep.nDataCallStep)            {                case TIMING_STEP_SEND_HEAD://组装报文头部				{					//FRAME104_FMT_TRACE("case TIMING_STEP_SEND_HEAD://组装报文头部 \n");					memset(g_sTimingTaskRunStep.aTempBuff, 0x00, TOTAL_FRAME_LEN_MAX);                    g_sTimingTaskRunStep.nTempBuffLen = 0;                    if(move_to_next_task_zhj(TASK_DATA_FROZEN) < 0)                    {                        g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;                        break;//没有需要处理的冻结数据周期上报任务                    }                    FRAME104_FMT_TRACE("timing_active_run_zhj() 冻结数据周期上报! 终端组别=%d, 终端下标=%d, 任务下标=%d \n",                         g_sTimingTaskRunStep.nEquipGroupIndex, g_sTimingTaskRunStep.nEquipNoIndex, g_sTimingTaskRunStep.nEqTaskNoIndex);                    nTaskPubAddrIndex = g_sTimingTaskRunStep.nTaskPubAddrIndex;                    nPubAddr = g_aReportTaskPubAddr[g_sTimingTaskRunStep.nEquipGroupIndex][g_sTimingTaskRunStep.nEquipNoIndex][g_sTimingTaskRunStep.nEqTaskNoIndex][nTaskPubAddrIndex];					nSendTI  =  M_TK_NA_ZHJ_1;                    nSendCOT = 0x01 + (uint16)(((uint8)(g_sTimingTaskRunStep.nEqTaskNoIndex + 1)<<8) & 0xff00);                    //赋值冻结时标                    eqTmnGroupIndex = g_sTimingTaskRunStep.nEquipGroupIndex;                    eqTmnNoIndex = g_sTimingTaskRunStep.nEquipNoIndex;                    eqTaskNoIndex = g_sTimingTaskRunStep.nEqTaskNoIndex;                    ArrIdx = g_aReportTaskIndex[eqTmnGroupIndex][eqTmnNoIndex];                    nSendInObjLenMax = 255 - APCI_UNIT_LABEL_LEN - 10;//预留十个数据类型                    memcpy(pSendInObjBuff, &g_aReportTaskData[ArrIdx+eqTaskNoIndex].aFrozenTime[0], 7);                    nSendInObjLen += 7;                    //判读最后一次读到的数据类型                    yc_refresh_frozen_zhj(&pSendInObjBuff[nSendInObjLen], &nSendInObjLen);                    FRAME104_BUF_TRACE(pSendInObjBuff, nSendInObjLen, "TIMING_STEP_SEND_HEAD头部:");                    g_sTimingTaskRunStep.nDataCallStep = g_sTimingTaskRunStep.nLastDataCallStep;                    g_sTimingTaskRunStep.nSubDataCallSetp = g_sTimingTaskRunStep.nLastSubDataCallSetp;                    				}                case TIMING_STEP_SEND_YX://上报所有遥信信息                {                    //FRAME104_FMT_TRACE("case TIMING_STEP_SEND_YX://上报所有遥信信息 \n");                    uint16 nStartIndex = g_sTimingTaskRunStep.nStartNum;  //起始序号                    ret  = yx_frozen_get_zhj(OBJ_ADDR_LEN, &pSendInObjBuff[nSendInObjLen], &nStartIndex, &nSendInObjLen, nSendInObjLenMax);                    FRAME104_FMT_TRACE("冻结数据周期上报遥信，返回数据长度 nSendInObjLen=%d, nSendInObjLenMax=%d, nStartIndex=%d, ret=%d \n", nSendInObjLen, nSendInObjLenMax, nStartIndex, ret);                    if(ret < 0)        			{        			    g_sTimingTaskRunStep.nStartNum = 0;                        if(1)                        {                            //本类型数据遍历结束, 转下一种类型-            				g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YC;                            g_sTimingTaskRunStep.nSubDataCallSetp = YC_TIMING_STEP_SEND_R;                        }        			}        			else        			{        				//-数据未读取完，还要继续读取-        				g_sTimingTaskRunStep.nStartNum = nStartIndex;                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(不带时标)                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(带时标)                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(电能量 不带时标)                        pSendInObjBuff[nSendInObjLen++] = 0x00;//遥测个数(比特串)                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_END;                        g_sTimingTaskRunStep.nFinishFlag = 0;                        g_sTimingTaskRunStep.nLastDataCallStep = TIMING_STEP_SEND_YX;                        //g_sTimingTaskRunStep.nLastSubDataCallSetp = TIMING_STEP_SEND_YX;        			}                    //break;                }				case TIMING_STEP_SEND_YC://上报所有遥测信息				{					//FRAME104_FMT_TRACE("case TIMING_STEP_SEND_YC://上报所有遥测信息 \n");					yc_frozen_get_zhj(OBJ_ADDR_LEN, pSendInObjBuff, &nSendInObjLen, nSendInObjLenMax);					//break;				}                case TIMING_STEP_SEND_END://结束组帧				{					//FRAME104_FMT_TRACE("case TIMING_STEP_SEND_END://结束组帧 \n");					nOutbufLen = i_frame_data_pack_zhj(nSendTI,nSendVSQ,nSendCOT,nPubAddr,pSendInObjBuff,nSendInObjLen,pOutBuff);        			                    if(1 == g_sTimingTaskRunStep.nFinishFlag)                    {                        g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;                    }                    else                    {                        g_sTimingTaskRunStep.nTaskStep = STEP_FROZEN_TASK_SEND;                        g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_HEAD;                    }                    					break;				}                default:                {                    g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;                    g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;                    break;                }            }            break;        }        default://任务空闲        {			g_sTimingTaskRunStep.nTaskStep = STEP_TIMING_TASK_SEND;            g_sTimingTaskRunStep.nDataCallStep = TIMING_STEP_SEND_YX;            break;        }    }	*pPipeIndex = nPipeIndex;	memcpy(pReportBuf, pOutBuff, nOutbufLen);	return nOutbufLen;}
