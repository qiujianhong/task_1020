/*
*********************************************************************
* @file    class8.c
* @brief： class8处理
* @author：
* @date：   2019.12.06
* @copyright 2019 南京新联电子股份有限公司 All rights reserved.
*********************************************************************
*/
#include "baseCommon.h"
#include "hal.h"
#include "rtc.h"
#include "drv_closing.h"
#include "oadInfoList.h"
#include "oopservice.h"
#include "commClass.h"
#include "EventIO.h"
#include "appcomm.h"
#include "msg_id.h"
#include "oopStorage.h"
#include "macro.h"
#include "statmain.h"
#include "devinfo.h"
#include "appmsg_struct.h"
#include "appmsg_split.h"
#include "area.h"
#include "msgSecApp.h"
#include "ssal.h"

//
// class8
//

/**********************************************************
名称： bin2_int32u

函数功能:将1字节转成4字节；

函数输入值:       
函数返回值:无
*************************************************************/
uint32 bin2_int32u(uint8 bin[4])
{
   int16 idx;
   uint32 val;

   val = 0;
   for(idx=0;idx<=3;idx++)
   {
       val<<=8;
       val += bin[idx];
   }
   return val;
}

/**
*********************************************************************
* @brief：     获取系统时间
* @param[in]： 
* @param[out]：DateTime_s格式时间
* @return：    null
*********************************************************************
*/
void systime_get(DateTimeHex_t *pDateTime)
{
    time_t linuxTime=time(NULL);

    DT_Time2DateTimeHex(linuxTime,pDateTime);
    //memrev((uint8*)pDateTime,7);
}

extern BOOL DT_DateTimeHex2BCD(DateTimeHex_t *dateTimeHex,DateTimeBcd_t *dateTimeBCD);
extern int32 data_to_buf_evt_asobjattr(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, 
                                       void *srcData, uint32 srcLen);
extern OOP_DAR_E buf_to_data_evt_asobjattr(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, 
                                           void *dstData, uint32 dstLen);
extern void appmain_buzzer_status(int dbClient, uint8 status);
extern int appdb_get_version(int clientid, uint8 logicId, uint16 infoNum, uint32 value);
typedef uint8 (*CTRL_SHOW_HINT)(uint8, uint8, uint8, uint8*, uint16, uint16*);
extern void appctrl_alarm_data(uint8 ctrltype, uint8 group, uint8 times, uint8 Voindex, CTRL_SHOW_HINT pfunc);

/**********************************************************************
* @name      : systime_set_to_smiOS
* @brief     ：向系统管理器发送对时命令
* @param[in] ：
* @return    ：
* @Date      ：2020-3-18
* @Update    :
**********************************************************************/
int systime_set_to_smiOS(DateTimeHex_t *pDateTime)
{
    uint8  sendbuf[100] = {0};
    uint8  recvbuf[32] = {0};
    uint16 recLen = 0;
    uint16 offset = 0;
    int    ret = 0;
    int    nRet = 0;
    struct tm systime;
    struct  timeval tv;
    struct  timezone tz;
    uint16  year;
    uint16  msec;

    sendbuf[offset++] = pDateTime->year_h;
    sendbuf[offset++] = pDateTime->year_l;
    sendbuf[offset++] = pDateTime->month;
    sendbuf[offset++] = pDateTime->day;
    sendbuf[offset++] = 0;
    sendbuf[offset++] = pDateTime->hour;
    sendbuf[offset++] = pDateTime->min;
    //针对打分广播校时一项 延时800毫秒 对到下一秒
//    if(pDateTime->sec == 0)
//    {
//        sendbuf[offset++] = pDateTime->sec + 1;
//        usleep(800000);
//    }else
    {
        sendbuf[offset++] = pDateTime->sec;
    }
    sendbuf[offset++] = 0;
    sendbuf[offset++] = 0;
   
    //智芯系统管理器过秒对时可能会有问题，做特殊处理
    #if PRODUCT_ECU
    uint16 i = 0;
    for (i = 0; i < 10; i++)
    {
        gettimeofday(&tv, &tz);
        if (tv.tv_usec > 992000)
        {
            usleep(1000000 - tv.tv_usec);
        }
        else
        {
            break;
        }
    }
    #else
    gettimeofday(&tv, &tz);
//    //对时的时候放倒100ms前对时
//    while(1)
//    {
//        gettimeofday(&tv, &tz);
//        if(tv.tv_usec <= 100000)
//        {
//            break;
//        }else
//        {
//            usleep(10000);
//        }
//    }
    #endif
    FastSecondToDate(&tv, &tz, &systime);
    
    year = systime.tm_year + 1900;
    MEMCPY_R(sendbuf + offset, &year, 2);
    offset += 2;
    sendbuf[offset++] = systime.tm_mon + 1;
    sendbuf[offset++] = systime.tm_mday;
    sendbuf[offset++] = systime.tm_wday;
    sendbuf[offset++] = systime.tm_hour;
    sendbuf[offset++] = systime.tm_min;
    sendbuf[offset++] = systime.tm_sec;
    msec = tv.tv_usec / 1000;
    MEMCPY_R(sendbuf + offset, &msec, 2);
    offset += 2;

    ret = appmain_send_syncmsg(MSG_APPAMIN_RCT, sendbuf, offset, recvbuf, 32, &recLen);
    if ((ret != ERR_OK) || (recLen != 1) || (recvbuf[0] != 1))
    {
        PRTL_FMT_DEBUG("systime_set_to_smiOS err! ret = %d, recLen = %d, recvbuf[0] = %x\n", ret, recLen, recvbuf[0]);
        nRet = ERR_NORMAL;
    }
    else
    {
        nRet = ERR_OK;
    }
    
    return nRet;
}

/**
*********************************************************************
* @brief：     设置系统时间
* @param[in]： pDateTime:      DateTime_s格式时间入口地址
* @param[out]：
* @return：    =TRUE            - 成功
               =FLASE           - 错误码
*********************************************************************
*/
BOOL systime_set(DateTimeHex_t *pDateTime)
{
    int iRet = 0;
    // struct tm rtc;
    int year = 0;

    // RTC_DEVICE_T* dev = (RTC_DEVICE_T*)hal_device_get(HW_DEVICE_ID_RTC);
    // if (NULL == dev)
    // {
    //     printf("rtc dev is null\n");
    //     return FALSE;
    // }

    // memset(&rtc, 0, sizeof(rtc));
    year = (uint16)pDateTime->year_l + (uint16)(pDateTime->year_h<<8);
    // rtc.tm_year = BIN2BCD(year - 2000);
    // rtc.tm_mon = BIN2BCD(pDateTime->month);
    // rtc.tm_mday = BIN2BCD(pDateTime->day);
    // rtc.tm_hour = BIN2BCD(pDateTime->hour);
    // rtc.tm_min = BIN2BCD(pDateTime->min);
    // rtc.tm_sec = BIN2BCD(pDateTime->sec);
    // PRTL_FMT_LOGCC("modify time: yy[%x],mm[%x],dd[%x],hh[%x],nn[%x],ss[%x]\n",
    //     rtc.tm_year,rtc.tm_mon,rtc.tm_mday,rtc.tm_hour,rtc.tm_min,rtc.tm_sec);
    // iRet = dev->rtc_time_set(dev, &rtc);
    // if (iRet < 0)
    // {
    //     printf("rtc set time is failed\n");
    //     return FALSE;
    // }

    PRTL_FMT_DEBUG("start set time modify time: %d-%d-%d %d:%d:%d\n",
        year, pDateTime->month, pDateTime->day, pDateTime->hour, pDateTime->min, pDateTime->sec);
    iRet = systime_set_to_smiOS(pDateTime);
    if (iRet != ERR_OK)
    {
        PRTL_FMT_DEBUG("set time err\n");
        return FALSE;
    }
    PRTL_FMT_DEBUG("set time ok\n");

    // sleep(1);
    // struct tm rtc1;
    // memset(&rtc1, 0, sizeof(rtc1));
    // iRet = dev->rtc_time_get(dev, &rtc1);
    // if(iRet >= 0)
    //   printf("rtc time: %x-%x-%x %x:%x:%x\n", rtc1.tm_year, rtc1.tm_mon, rtc1.tm_mday, 
    //                                           rtc1.tm_hour, rtc1.tm_min, rtc1.tm_sec);
    // else
    //   printf("rtc get time is failed\n");

    // hal_device_release((HW_DEVICE *)dev);
    return TRUE;
}

#if DESC("系统版本查询", 1)
/**
*********************************************************************
* @brief：      获取系统版本信息
* @param[in]： 
* @param[out]：tmp    版本信息
* @return：      0    成功
               非0    错误码
*********************************************************************
*/
int oop_get_sys_ver(char * temp)
{
    char buf[1024] = {0};

    if(temp == NULL)
        return -1;
    
    FILE* pipe = fopen("/proc/version", "r");  
    if (!pipe)  
    {
        pipe = fopen("/proc/version", "r");
    }
    if (!pipe)
    {
        PRTL_FMT_DEBUG("查询系统版本失败, /proc/version！\n");
        return -1;
    }

    fseek(pipe, -1024L, SEEK_END);
    while (fgets(buf, 1024, pipe) != NULL)
    {
        PRTL_FMT_TRACE("%s", buf);
        char *pfile = NULL;
        if ((pfile = strstr(buf,"+++OS_RK3358")) != NULL)
        {
            if (strlen(pfile) < 256)
            {
                strcpy(temp, pfile);
            }
            else
            {
                PRTL_FMT_DEBUG("查询系统版本失败, 长度溢出len[%d]\n", strlen(pfile));
            }
        }
        memset(buf, 0x0, sizeof(buf));
    }

    if (temp[0] == '\0')
    {
        fclose(pipe);
        return -1; 
    }

    if(temp[strlen(temp)-1] == '\n')
        temp[strlen(temp)-1] = '\0';
    
    fclose(pipe);
    return 0;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_sys_ver(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLEVAR256_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //组件名称
    dar = basic_data_to_buf(E_OOP_VISIBLESTR256_T, dstBuf, dstLen, &dOffset, &data, sizeof(OOP_VISIBLEVAR256_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_sys_ver(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    OOP_VISIBLEVAR256_T data;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 dOffset = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    ret = oop_get_sys_ver(data.value);
    if (ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("oop_get_sys_ver failed. ret(%d)\n", ret);
        return DATA_READ_WRITE_DENIED;
    }
    else
    {
        data.nNum = MIN(256, strlen(data.value));
    }

    PRTL_FMT_DEBUG("系统版本为[%s]\n", data.value);

    //OAD与返回数据
    memcpy(&outData->pResultData[dOffset], inData, sizeof(OOP_OAD_U));
    dOffset += sizeof(OOP_OAD_U);

    outData->pResultData[dOffset++] = 1;

    //转换成报文数据
    convert.srcBuf = &data;
    convert.srcLen = sizeof(data);
    convert.sOffset = &sOffset;
    
    convert.dstBuf = outData->pResultData;
    convert.dstLen = outDataMax;
    convert.dOffset = &dOffset;
    
    dar = data_to_buf_class8_sys_ver(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    outData->resultDataLen = dOffset;

    return dar;
}

#endif

#if DESC("档案方案任务相关转换函数",1)
/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(档案基本信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 data_to_buf_class8_basic_object(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcData, uint32 srcLen, void *dstBuf, uint32 *dstLen)
{
    int32 nRet = ERR_NORMAL;
    OAD_INFO_T *pOadInfoTmp = NULL;
    uint32     offset = 0;
    uint8      offlen = 0;
    uint8      lenBuf[3] = {0};
    uint32     oadInfoOffsetTmp = 0;
    pOadInfoTmp = pOadInfo;
    //uint8 *srcDataTmp = (uint8 *)srcData;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcData == NULL) || (dstBuf == NULL) || (dstLen == NULL))
    {
        PRTL_FMT_DEBUG("data_to_buf_class8_basic_object param err\n");
        return ERR_PTR;
    }

    if (pOadInfo->pTab->eData != E_BASIC_OBJECT)
    {
        nRet = ERR_OPTION;
        return nRet;
    }
    else
    {
        uint32 offsetTmp;
        uint32 dstLenTmp;
        OOP_METER_BASIC_T oopMeterBasic;

        if (srcLen != sizeof(OOP_METER_BASIC_T))
        {
            nRet = ERR_OPTION;
            return nRet;
        }
        memcpy(&oopMeterBasic, srcData, srcLen);

        offlen = set_len_offset(pOadInfoTmp->pTab->dataLen, lenBuf);

        dstBufTmp[offset++] = pOadInfoTmp->pTab->dataType;
        memcpy(&dstBufTmp[offset], lenBuf, offlen);
        offset += offlen;

        /*表计地址*/
        pOadInfoTmp->pTab ++;
        oadInfoOffsetTmp ++;
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.tsa, sizeof(oopMeterBasic.tsa), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*波特率*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.baud, sizeof(oopMeterBasic.baud), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*规约类型*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.protocol, sizeof(oopMeterBasic.protocol), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*端口*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.port, sizeof(oopMeterBasic.port), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*通信密码*/
        if (pOadInfoTmp->pTab->eData != E_PWD_COMM)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        dstBufTmp[offset++] = DT_OCTET_STRING;
        dstBufTmp[offset++] = oopMeterBasic.pwdLen;        //密码最大支持长度为8
        memcpy_rev(&dstBufTmp[offset], &oopMeterBasic.password[0], oopMeterBasic.pwdLen);
        offset += oopMeterBasic.pwdLen;
        pOadInfoTmp->pTab += 1;
        oadInfoOffsetTmp += 1;

        /*费率个数*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.rateNum, sizeof(oopMeterBasic.rateNum), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }
        
        /*用户类型*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.userType, sizeof(oopMeterBasic.userType), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*接线方式*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.pwrType, sizeof(oopMeterBasic.pwrType), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*额定电压*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.stVolt, sizeof(oopMeterBasic.stVolt), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*额定电流*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterBasic.stAmp, sizeof(oopMeterBasic.stAmp), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }
    }

    *dstLen = offset;
    *oadInfoOffset = oadInfoOffsetTmp;
    nRet = ERR_OK;

    return nRet;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(档案基本信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_basic_object(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32     offset = *pOffset;
    OOP_METER_BASIC_T data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;

    //结构成员个数
    dstBufTmp[offset++] = 10;    

    //表计地址
    dar = basic_data_to_buf(E_TSA, dstBufTmp, dstLen-offset, &offset, &data.tsa, sizeof(data.tsa));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //波特率
    dar = basic_data_to_buf(E_ENUM, dstBufTmp, dstLen-offset, &offset, &data.baud, sizeof(data.baud));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //规约类型
    dar = basic_data_to_buf(E_ENUM, dstBufTmp, dstLen-offset, &offset, &data.protocol, sizeof(data.protocol));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //端口
    dar = basic_data_to_buf(E_OAD, dstBufTmp, dstLen-offset, &offset, &data.port, sizeof(data.port));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //通信密码
    dstBufTmp[offset++] = DT_OCTET_STRING;
    dstBufTmp[offset++] = data.pwdLen;                              //密码最大支持长度为8
    memcpy_rev(&dstBufTmp[offset], &data.password[0], data.pwdLen);
    offset += data.pwdLen;

    //费率个数
    dar = basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.rateNum, sizeof(data.rateNum));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //用户类型
    dar = basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.userType, sizeof(data.userType));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //接线方式
    dar = basic_data_to_buf(E_ENUM, dstBufTmp, dstLen-offset, &offset, &data.pwrType, sizeof(data.pwrType));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //额定电压
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.stVolt, sizeof(data.stVolt));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //额定电流
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.stAmp, sizeof(data.stAmp));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(档案扩展信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 data_to_buf_class8_extended_object(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcData, uint32 srcLen, void *dstBuf, uint32 *dstLen)
{
    int32 nRet = ERR_NORMAL;
    OAD_INFO_T *pOadInfoTmp = NULL;
    uint32     offset = 0;
    uint8      offlen = 0;
    uint8      lenBuf[3] = {0};
    uint32     oadInfoOffsetTmp = 0;
    pOadInfoTmp = pOadInfo;
    //uint8 *srcDataTmp = (uint8 *)srcData;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcData == NULL) || (dstBuf == NULL) || (dstLen == NULL))
    {
        PRTL_FMT_DEBUG("data_to_buf_class8_extended_object param err\n");
        return ERR_PTR;
    }

    if (pOadInfo->pTab->eData != E_EXTENDED_OBJECT)
    {
        nRet = ERR_OPTION;
        return nRet;
    }
    else
    {
        uint32 offsetTmp;
        uint32 dstLenTmp;
        OOP_METER_EXTENDED_T oopMeterExtended;

        if (srcLen != sizeof(OOP_METER_EXTENDED_T))
        {
            nRet = ERR_OPTION;
            return nRet;
        }
        memcpy(&oopMeterExtended, srcData, srcLen);

        offlen = set_len_offset(pOadInfoTmp->pTab->dataLen, lenBuf);

        dstBufTmp[offset++] = pOadInfoTmp->pTab->dataType;
        memcpy(&dstBufTmp[offset], lenBuf, offlen);
        offset += offlen;

        /*采集器地址*/
        pOadInfoTmp->pTab ++;
        oadInfoOffsetTmp ++;
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterExtended.add, sizeof(oopMeterExtended.add), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*资产号*/
        if (pOadInfoTmp->pTab->eData != E_ASSETNO)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        dstBufTmp[offset++] = DT_OCTET_STRING;
        dstBufTmp[offset++] = oopMeterExtended.astLen;        //资产号最大支持长度为32
        memcpy_rev(&dstBufTmp[offset], &oopMeterExtended.assetNo[0], oopMeterExtended.astLen);
        offset += oopMeterExtended.astLen;
        pOadInfoTmp->pTab += 1;
        oadInfoOffsetTmp += 1;

        /*PT*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterExtended.PT, sizeof(oopMeterExtended.PT), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*CT*/
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeterExtended.CT, sizeof(oopMeterExtended.CT), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }
    }

    *dstLen = offset;
    *oadInfoOffset = oadInfoOffsetTmp;
    nRet = ERR_OK;

    return nRet;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(档案扩展信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_extended_object(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32     offset = *pOffset;
    OOP_METER_EXTENDED_T data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;

    //结构成员个数
    dstBufTmp[offset++] = 4;    

    //采集器地址
    dar = basic_data_to_buf(E_TSA, dstBufTmp, dstLen-offset, &offset, &data.add, sizeof(data.add));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //资产号
    dstBufTmp[offset++] = DT_OCTET_STRING;
    dstBufTmp[offset++] = data.astLen;                              //密码最大支持长度为8
    memcpy_rev(&dstBufTmp[offset], &data.assetNo[0], data.astLen);
    offset += data.astLen;
    
    //PT
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.PT, sizeof(data.PT));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    //CT
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.CT, sizeof(data.CT));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return dar;
    } 

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(档案扩展信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_annex_object(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32     offset = *pOffset;
    OOP_METER_ANNEX_T data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;
    uint8 i;
    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_ARRAY;

    //结构成员个数
    dstBufTmp[offset++] = data.nNum;    

    for(i=0;i<data.nNum;i++)
    {
        dstBufTmp[offset++] = DT_STRUCTURE;
        dstBufTmp[offset++] = 2;
        dar = basic_data_to_buf(E_OAD, dstBufTmp, dstLen-offset, &offset, &data.annexObj[i].oad , sizeof(data.annexObj[i].oad));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
            return dar;
        } 
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, data.annexObj[i].value , sizeof(data.annexObj[i].oad));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
            return dar;
        } 
    }

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(档案附属信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 data_to_buf_class8_annex_object(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcData, uint32 srcLen, void *dstBuf, uint32 *dstLen)
{
    int32  nRet = ERR_NORMAL;
    uint32 offset = 0;
    uint32 oadInfoOffsetTmp = 0;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcData == NULL) || (dstBuf == NULL) || (dstLen == NULL))
    {
        PRTL_FMT_DEBUG("data_to_buf_class8_extended_object param err\n");
        return ERR_PTR;
    }

    if (pOadInfo->pTab->eData != E_ANNEX_OBJECT_LIST)
    {
        nRet = ERR_OPTION;
        return nRet;
    } 
    else
    {
        dstBufTmp[offset++] = DT_ARRAY;
        dstBufTmp[offset++] = 0x00;
        oadInfoOffsetTmp = 2;
    }

    *dstLen = offset;
    *oadInfoOffset = oadInfoOffsetTmp;
    nRet = ERR_OK; 
    return nRet;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(采集档案单元)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 data_to_buf_class8_oop_meter(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcData, uint32 srcLen, void *dstBuf, uint32 *dstLen, uint32 outMaxLen)
{
    int32 nRet = ERR_NORMAL;
    OAD_INFO_T *pOadInfoTmp = NULL;
    uint32     offset = 0;
    uint8      offlen = 0;
    uint8      lenBuf[3] = {0};
    uint32     oadInfoOffsetTmp = 0;
    pOadInfoTmp = pOadInfo;
    //uint8 *srcDataTmp = (uint8 *)srcData;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcData == NULL) || (dstBuf == NULL) || (dstLen == NULL))
    {
        PRTL_FMT_DEBUG("data_to_buf_class8_oop_meter param err\n");
        return ERR_PTR;
    }

    if (pOadInfoTmp->pTab->eData != E_OOP_METER_T)
    {
        nRet = ERR_OPTION;
        return nRet;
    }
    else
    {
        uint32 offsetTmp;
        uint32 dstLenTmp;
        OOP_METER_T oopMeter;

        if (srcLen != sizeof(OOP_METER_T))
        {
            nRet = ERR_OPTION;
            return nRet;
        }

        memcpy(&oopMeter, srcData, srcLen);

        offlen = set_len_offset(pOadInfoTmp->pTab->dataLen, lenBuf);

        dstBufTmp[offset++] = pOadInfoTmp->pTab->dataType;
        memcpy(&dstBufTmp[offset], lenBuf, offlen);
        offset += offlen;

        /*配置序号*/
        pOadInfoTmp->pTab ++;
        oadInfoOffsetTmp ++;
        if(data_to_buf_common(pOadInfoTmp, &offsetTmp, &oopMeter.nIndex, sizeof(oopMeter.nIndex), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*基本信息*/
        if(data_to_buf_class8_basic_object(pOadInfoTmp, &offsetTmp, &oopMeter.basic, sizeof(oopMeter.basic), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*扩展信息*/
        if(data_to_buf_class8_extended_object(pOadInfoTmp, &offsetTmp, &oopMeter.extend, sizeof(oopMeter.extend), &dstBufTmp[offset], &dstLenTmp) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        else
        {
            offset += dstLenTmp;
            pOadInfoTmp->pTab += offsetTmp;
            oadInfoOffsetTmp += offsetTmp;
        }

        /*附属信息*/
        dstBufTmp[offset++] = DT_ARRAY;
        dstBufTmp[offset++] = 0x00;        
    }
    
    *dstLen = offset;
    *oadInfoOffset = oadInfoOffsetTmp;
    nRet = ERR_OK;

    return nRet;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(采集档案单元)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_oop_meter(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_METER_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 4;

    //配置序号
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nIndex, sizeof(data.nIndex));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //基本信息
    dar = data_to_buf_basic_object(pOadInfo, dstBuf, dstLen, &dOffset, &data.basic, sizeof(data.basic));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //扩展信息
    dar = data_to_buf_extended_object(pOadInfo, dstBuf, dstLen, &dOffset, &data.extend, sizeof(data.extend));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //附属信息
    dar = data_to_buf_annex_object(pOadInfo, dstBuf, dstLen, &dOffset, &data.annex, sizeof(data.annex));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar; 
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(采集状态案单元)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_acq_state(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_ACQ_RLUESTATE_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 0x08;

    //通信地址
    dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.add, sizeof(OOP_TSA_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //中继级别
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.relayLevel, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //中继地址
    dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.relayAdd, sizeof(OOP_TSA_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //端口
    dar = basic_data_to_buf(E_OAD, dstBuf, dstLen, &dOffset, &data.port, sizeof(OOP_OAD_U));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
    //最后一次采集成功时间
    dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data.time, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
    //采集失败次数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.failTimes, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
    //相位
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.phase, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
    //相序异常
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.phaseSeq, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
    
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar; 
}


/**
*********************************************************************
* @brief：     搜表结果
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
* @author    : 贺宁
* @Date      ：2019-12-6                 
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_searchmeter_res_all(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SEARCHMET_RES_T data;
    // uint8 offlen = 0;      //数组数量长度
    // uint8 lenBuf[3] = {0}; //数组数量编码
    // uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    // //结构类型
    // dstBuf[dOffset++] = DT_STRUCTURE;

    // //结构成员数
    // dstBuf[dOffset++] = 7;
            
    // //通信地址
    // dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.commAdd, sizeof(data.commAdd));
    // if(dar != DATA_SUCCESS)
    // {
    //     PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.commAdd.len(%d)\n", dar, data.commAdd.len);
    //     return DATA_TYPE_UNMATCHED;
    // }
    
    // //采集器地址
    // dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.collAdd, sizeof(data.collAdd));
    // if(dar != DATA_SUCCESS)
    // {
    //     PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.collAdd.len(%d)\n", dar, data.collAdd.len);
    //     return DATA_TYPE_UNMATCHED;
    // }

    // //规约类型(enum) 
    // dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.proto, sizeof(uint8));
    // if(dar != DATA_SUCCESS)
    // {
    //     PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),nDepth(%d)\n", dar, data.proto);
    //     return DATA_TYPE_UNMATCHED;
    // }   

    // //相位(enum)   
    // dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.phase, sizeof(uint8));
    // if(dar != DATA_SUCCESS)
    // {
    //     PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),nDepth(%d)\n", dar, data.phase);
    //     return DATA_TYPE_UNMATCHED;
    // }  

    // //信号品质   
    // dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.quality, sizeof(uint8));
    // if(dar != DATA_SUCCESS)
    // {
    //     PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),nDepth(%d)\n", dar, data.quality);
    //     return DATA_TYPE_UNMATCHED;
    // }  

    // //搜到的时间    
    // dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data.serchTime, sizeof(OOP_DATETIME_S_T));
    // if(dar != DATA_SUCCESS)
    // {
    //     PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.serchTime.hour(%d)\n", dar, data.serchTime.hour);
    //     return DATA_TYPE_UNMATCHED;
    // }  

    // //附加信息
    // //数组类型
    // dstBuf[dOffset++] = DT_ARRAY;

    // //数组成员个数
    // offlen = set_len_offset(data.nAdded, lenBuf);
    // memcpy(&dstBuf[dOffset], lenBuf, offlen);
    // dOffset += offlen;

    // for (i = 0; i < data.nAdded; i++)
    // {
    //     //结构类型
    //     dstBuf[dOffset++] = DT_STRUCTURE;

    //     //结构成员数
    //     dstBuf[dOffset++] = 2;

    //     //oad
    //     dar = basic_data_to_buf(E_OAD, dstBuf, dstLen, &dOffset, &data.info[i].oad, sizeof(OOP_OAD_U));
    //     if(dar != DATA_SUCCESS)
    //     {
    //         PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d], dar(%d),nDepth(0x%x)\n", i, dar, data.info[i].oad);
    //         return DATA_TYPE_UNMATCHED;
    //     } 

    //     //Data
    //     if(vardata_data_to_buf(searchres.info[i].value, dstBuf, dstLen-offset, &offset) < 0)
    //     {
    //         nRet = ERR_NORMAL;
    //         return nRet;
    //     } 
    // } 

    dar = data_to_buf_search_met_res(pOadInfo, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     搜表结果
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
* @author    : 贺宁
* @Date      ：2019-12-6                 
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_searchmeter_res_acrossarea(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_ACROSSAREA_RES_T data;
    // uint8 offlen = 0;      //数组数量长度
    // uint8 lenBuf[3] = {0}; //数组数量编码
    // uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 3;
            
    //通信地址
    dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.commAdd, sizeof(data.commAdd));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.commAdd.len(%d)\n", dar, data.commAdd.len);
        return DATA_TYPE_UNMATCHED;
    }
    
    //主节点地址
    dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.netAdd, sizeof(data.netAdd));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.netAdd.len(%d)\n", dar, data.netAdd.len);
        return DATA_TYPE_UNMATCHED;
    }

    //变更时间  
    dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data.change, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.serchTime.hour(%d)\n", dar, data.change.hour);
        return DATA_TYPE_UNMATCHED;
    }  

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(class8)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
// int32 data_to_buf_class8(const OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcData, uint32 srcLen, void *dstBuf, uint32 *dstLen)
// {
//     int32 nRet = ERR_NORMAL;
//     OAD_INFO_T *pOadInfoTmp = NULL;
//     uint32     offset = 0;
//     uint8      offlen = 0;
//     uint8      lenBuf[3] = {0};
//     uint32     oadInfoOffsetTmp = 0;
//     pOadInfoTmp = pOadInfo;
//     uint8 *srcDataTmp = (uint8 *)srcData;
//     uint8 *dstBufTmp = (uint8 *)dstBuf;

//     /*入参检查*/
//     if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcData == NULL) || (dstBuf == NULL) || (dstLen == NULL))
//     {
//         PRTL_FMT_DEBUG("data_to_buf_class8 param err\n");
//         return ERR_PTR;
//     }

//     if (pOadInfoTmp->pTab->class != 8)
//     {
//         PRTL_FMT_DEBUG("data_to_buf_class8 error,pOadInfoTmp->pTab->class != 8\n");
//         return ERR_OPTION;
//     }

//     switch (pOadInfoTmp->pTab->eData)
//     {
//     case E_OOP_METER_T:
//     {
//         uint32 offsetTmp = 0;
//         uint32 dstLenTmp = 0;
//         OOP_METER_T oopMeter;

//         if (srcLen != sizeof(OOP_METER_T))
//         {
//             nRet = ERR_OPTION;
//             return nRet;
//         }

//         memcpy(&oopMeter, srcData, srcLen);

//         offlen = set_len_offset(pOadInfoTmp->pTab->dataLen, lenBuf);

//         dstBufTmp[offset++] = pOadInfoTmp->pTab->dataType;
//         memcpy(&dstBufTmp[offset], lenBuf, offlen);
//         offset += offlen;

//         /*配置序号*/
//         pOadInfoTmp->pTab ++;
//         oadInfoOffsetTmp ++;
//         if (data_to_buf_class8(pOadInfoTmp, &offsetTmp, &oopMeter.nIndex, sizeof(oopMeter.nIndex), &dstBuf[offset], &dstLenTmp) < 0)
//         {
//             nRet = ERR_NORMAL;
//             break;
//         }
//         else
//         {
//             offset += dstLenTmp;
//             pOadInfoTmp->pTab += offsetTmp;
//             oadInfoOffsetTmp += offsetTmp;
//             nRet = ERR_OK;
//         }

//         /*档案基本信息*/
//         if (data_to_buf_class8(pOadInfoTmp, &offsetTmp, &oopMeter.basic, sizeof(oopMeter.basic), &dstBuf[offset], &dstLenTmp) < 0)
//         {
//             nRet = ERR_NORMAL;
//             break;
//         }
//         else
//         {
//             offset += dstLenTmp;
//             pOadInfoTmp->pTab += offsetTmp;
//             oadInfoOffsetTmp += offsetTmp;
//             nRet = ERR_OK;
//         }

//         /*档案扩展信息*/
//         if (data_to_buf_class8(pOadInfoTmp, &offsetTmp, &oopMeter.extend, sizeof(oopMeter.extend), &dstBuf[offset], &dstLenTmp) < 0)
//         {
//             nRet = ERR_NORMAL;
//             break;
//         }
//         else
//         {
//             offset += dstLenTmp;
//             pOadInfoTmp->pTab += offsetTmp;
//             oadInfoOffsetTmp += offsetTmp;
//             nRet = ERR_OK;
//         }

//          /*档案附加信息*/
//         if (data_to_buf_class8(pOadInfoTmp, &offsetTmp, &oopMeter.annex, sizeof(oopMeter.annex), &dstBuf[offset], &dstLenTmp) < 0)
//         {
//             nRet = ERR_NORMAL;
//             break;
//         }
//         else
//         {
//             offset += dstLenTmp;
//             pOadInfoTmp->pTab += offsetTmp;
//             oadInfoOffsetTmp += offsetTmp;
//             nRet = ERR_OK;
//         }

//         *dstLen = offset;
//         *oadInfoOffset = oadInfoOffsetTmp;
//         nRet = ERR_OK;
//         break;
//     }
//     case E_BASIC_OBJECT:
//     {
//         if (data_to_buf_class8_basic_object(pOadInfoTmp, oadInfoOffset, srcData, srcLen, dstBuf, dstLen) < 0)
//         {
//             nRet = ERR_OPTION;
//             break;
//         }
//         else
//         {
//             nRet = ERR_OK;
//         }
//         break;
//     } 
//     case E_EXTENDED_OBJECT:
//     {
//         if (data_to_buf_class8_extended_object(pOadInfoTmp, oadInfoOffset, srcData, srcLen, dstBuf, dstLen) < 0)
//         {
//             nRet = ERR_OPTION;
//             break;
//         }
//         else
//         {
//             nRet = ERR_OK;
//         }
//         break;
//     } 

//     case E_ANNEX_OBJECT_LIST:
//     {
//         if (data_to_buf_class8_annex_object(pOadInfoTmp, oadInfoOffset, srcData, srcLen, dstBuf, dstLen) < 0)
//         {
//             nRet = ERR_OPTION;
//             break;
//         }
//         else
//         {
//             nRet = ERR_OK;
//         }
//         break;
//     } 
    
//     default:
//     {
//         if (data_to_buf_common(pOadInfoTmp, oadInfoOffset, srcData, srcLen, dstBuf, dstLen) < 0)
//         {
//             nRet = ERR_NORMAL;
//         }
//         else
//         {
//             nRet = ERR_OK;
//         }
//         break;
//     }

//     }
//     return nRet;
// }


/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案基本信息)
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_basic_object(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    int32 nRet = ERR_NORMAL;
    OAD_INFO_T *pOadInfoTmp = NULL;
    uint32     offset = 0;
    uint32     offsetTmp = 0;
    uint16     offsetTmp16 = 0;
    uint32     oadInfoOffsetTmp = 0;
    uint32     oadInfoOffsetAll = 0;
    pOadInfoTmp = pOadInfo;
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 *dstDataTmp = (uint8 *)dstData;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcBuf == NULL) || (dstData == NULL) || (dstLen <= 0))
    {
        PRTL_FMT_DEBUG("buf_to_data_class8_basic_object param err\n");
        return ERR_PTR;
    }

    if (pOadInfo->pTab->eData != E_BASIC_OBJECT)
    {
        nRet = ERR_OPTION;
        return nRet;
    }
    else if(!apdu_next_dpos_get(srcBuf, &offsetTmp16, srcLen, DT_NULL, FALSE))
    {
        nRet = ERR_FORMAT;
        return nRet;
    }
    else
    {
        //uint32 dstLenTmp;
        uint32 srcLenTmp;
        OOP_METER_BASIC_T oopMeterBasic;

        if (srcBufTmp[offset++] != DT_STRUCTURE)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        if (srcBufTmp[offset++] != 0x0a)        //结构体元素个数
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        pOadInfoTmp->pTab ++;
        oadInfoOffsetAll ++;

        /*通信地址*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.tsa, sizeof(oopMeterBasic.tsa)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*波特率*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.baud, sizeof(oopMeterBasic.baud)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*规约类型*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.protocol, sizeof(oopMeterBasic.protocol)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*端口*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.port, sizeof(oopMeterBasic.port)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*通信密码*/
        offsetTmp = 0;
        if (pOadInfoTmp->pTab->eData != E_PWD_COMM)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        if (srcBufTmp[offset++] != DT_OCTET_STRING)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        oopMeterBasic.pwdLen = srcBufTmp[offset++];
        memcpy_rev(&oopMeterBasic.password[0], &srcBufTmp[offset], oopMeterBasic.pwdLen);
        offset += oopMeterBasic.pwdLen;
        pOadInfoTmp->pTab += 1;
        oadInfoOffsetTmp = 1;
        oadInfoOffsetAll += oadInfoOffsetTmp;

        /*费率个数*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.rateNum, sizeof(oopMeterBasic.rateNum)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*用户类型*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.userType, sizeof(oopMeterBasic.userType)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*接线方式*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.pwrType, sizeof(oopMeterBasic.pwrType)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*额定电压*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.stVolt, sizeof(oopMeterBasic.stVolt)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*额定电流*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterBasic.stAmp, sizeof(oopMeterBasic.stAmp)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }
        memcpy(dstDataTmp, &oopMeterBasic, dstLen);
    }

    *pOffset = offset;
    *oadInfoOffset = oadInfoOffsetAll;
    nRet = ERR_OK;

    return nRet;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案基本信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
               !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_basic_object(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *pOffset;    
    OOP_METER_BASIC_T data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if(srcBufTmp[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[sOffset++] != 10)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //表计地址
    dar = basic_buf_to_data(E_TSA, srcBuf, srcLen, &sOffset, &data.tsa, sizeof(data.tsa));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //波特率
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.baud, sizeof(data.baud));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //规约类型
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.protocol, sizeof(data.protocol));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //端口
    dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.port, sizeof(data.port));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //通信密码
    if (srcBufTmp[sOffset++] != DT_OCTET_STRING)
    {
        return DATA_TYPE_UNMATCHED;
    }

    if (srcBufTmp[sOffset] < 0x80)
    {
        data.pwdLen = srcBufTmp[sOffset];        
    }
    else if (srcBufTmp[sOffset] == 0x81)
    {
        sOffset++;
        data.pwdLen = srcBufTmp[sOffset];
    }
    else 
    {
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }
    sOffset++;

    memcpy_rev(&data.password[0], &srcBufTmp[sOffset], data.pwdLen);
    sOffset += data.pwdLen;

    //费率个数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.rateNum, sizeof(data.rateNum));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //用户类型
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.userType, sizeof(data.userType));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //接线方式
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.pwrType, sizeof(data.pwrType));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //额定电压
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.stVolt, sizeof(data.stVolt));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //额定电流
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.stAmp, sizeof(data.stAmp));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(sOffset > srcLen)
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d)\n", sOffset, srcLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    memcpy(dstData, &data, dstLen);

    *pOffset = sOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案扩展信息)
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_extended_object(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    int32 nRet = ERR_NORMAL;
    OAD_INFO_T *pOadInfoTmp = NULL;
    uint32     offset = 0;
    uint32     offsetTmp = 0;
    uint16     offsetTmp16 = 0;
    uint32     oadInfoOffsetTmp = 0;
    uint32     oadInfoOffsetAll = 0;
    pOadInfoTmp = pOadInfo;
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 *dstDataTmp = (uint8 *)dstData;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcBuf == NULL) || (dstData == NULL) || (dstLen <= 0))
    {
        PRTL_FMT_DEBUG("buf_to_data_class8_basic_object param err\n");
        return ERR_PTR;
    }

    if (pOadInfo->pTab->eData != E_EXTENDED_OBJECT)
    {
        nRet = ERR_OPTION;
        return nRet;
    }
    else if(!apdu_next_dpos_get(srcBuf, &offsetTmp16, srcLen, DT_NULL, FALSE))
    {
        nRet = ERR_FORMAT;
        return nRet;
    }
    else
    {
        //uint32 dstLenTmp = 0;
        uint32 srcLenTmp = 0;
        OOP_METER_EXTENDED_T oopMeterExtended;

        if (srcBufTmp[offset++] != DT_STRUCTURE)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        if (srcBufTmp[offset++] != 0x04)        //结构体元素个数
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        pOadInfoTmp->pTab ++;
        oadInfoOffsetAll ++;

        /*采集器地址*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterExtended.add, sizeof(oopMeterExtended.add)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*资产号*/
        offsetTmp = 0;
        if (pOadInfoTmp->pTab->eData != E_ASSETNO)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        if (srcBufTmp[offset++] != DT_OCTET_STRING)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        oopMeterExtended.astLen = srcBufTmp[offset++];
        memcpy_rev(&oopMeterExtended.assetNo[0], &srcBufTmp[offset], oopMeterExtended.astLen);
        offset += oopMeterExtended.astLen;
        pOadInfoTmp->pTab += 1;
        oadInfoOffsetTmp = 1;
        oadInfoOffsetAll += oadInfoOffsetTmp;

        /*PT*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterExtended.PT, sizeof(oopMeterExtended.PT)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*CT*/
        offsetTmp16 = 0;
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeterExtended.CT, sizeof(oopMeterExtended.CT)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        memcpy(dstDataTmp, &oopMeterExtended, dstLen);

    }
    *pOffset = offset;
    *oadInfoOffset = oadInfoOffsetAll;
    nRet = ERR_OK;

    return nRet;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案扩展信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
               !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_extended_object(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *pOffset;    
    OOP_METER_EXTENDED_T data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if(srcBufTmp[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[sOffset++] != 4)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //采集器地址
    dar = basic_buf_to_data(E_TSA, srcBuf, srcLen, &sOffset, &data.add, sizeof(data.add));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //资产号
    if (srcBufTmp[sOffset++] != DT_OCTET_STRING)
    {
        return DATA_TYPE_UNMATCHED;
    }

    if (srcBufTmp[sOffset] < 0x80)
    {
        data.astLen = srcBufTmp[sOffset];        
    }
    else if (srcBufTmp[sOffset] == 0x81)
    {
        sOffset++;
        data.astLen = srcBufTmp[sOffset];
    }
    else 
    {
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }
    sOffset++;
    
    //data.astLen = srcBufTmp[sOffset++];
    memcpy_rev(&data.assetNo[0], &srcBufTmp[sOffset], data.astLen);
    sOffset += data.astLen;

    //PT
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.PT, sizeof(data.PT));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //CT
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.CT, sizeof(data.CT));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(sOffset > srcLen)
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d)\n", sOffset, srcLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    memcpy(dstData, &data, dstLen);

    *pOffset = sOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案附属信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
               !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_annex_object(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *pOffset;    
    OOP_METER_ANNEX_T		data;		/**< 附属信息	*/
    memset(&data,0x00,sizeof(OOP_METER_ANNEX_T));
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 i,count;
    
    //数组类型
    if(srcBufTmp[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    count = srcBufTmp[sOffset++];
    if(count == 0)
    {
        *pOffset = sOffset;
        //PRTL_BUF_DEBUG(srcBufTmp, srcLen, "annex_object count == 0 \n");
        return dar;
    }
    
    for(i=0; i<count; i++)
    {
        OOP_OAD_U oad;
        if(srcBufTmp[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        if(srcBufTmp[sOffset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        //OAD
        dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &oad, sizeof(OOP_OAD_U));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        switch(oad.value)
        {
            case 0x40360200:
            case 0x60500200: 
            {
                uint16 value;
                
                dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &value, sizeof(uint16));
                if(dar != DATA_SUCCESS)
                {
                    PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
                    return DATA_TYPE_UNMATCHED;
                }

                data.annexObj[data.nNum].oad.value = oad.value;
                data.annexObj[data.nNum].nLen = sizeof(uint16);
                memcpy(data.annexObj[data.nNum].value,&value,sizeof(uint16));
                data.nNum++;

            }break;
            
            default: break;
        }
        
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(sOffset > srcLen)
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d)\n", sOffset, srcLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    memcpy(dstData, &data, dstLen);

    *pOffset = sOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案信息)
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_oop_meter(OAD_INFO_T *pOadInfo, uint32 *oadInfoOffset, void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    int32 nRet = ERR_NORMAL;
    OAD_INFO_T *pOadInfoTmp = NULL;
    uint32     offset = *pOffset;
    uint32     offsetTmp = 0;
    uint16     offsetTmp16 = 0;
    uint32     oadInfoOffsetTmp = 0;
    uint32     oadInfoOffsetAll = 0;
    pOadInfoTmp = pOadInfo;
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 *dstDataTmp = (uint8 *)dstData;

    /*入参检查*/
    if ((pOadInfo == NULL) || (oadInfoOffset == NULL) || (srcBuf == NULL) || (dstData == NULL) || (dstLen <= 0))
    {
        PRTL_FMT_DEBUG("buf_to_data_class8_oop_meter param err\n");
        return ERR_PTR;
    }

    /*判断是不是档案类型*/
    if (pOadInfo->pTab->eData != E_OOP_METER_T)
    {
        nRet = ERR_OPTION;
        return nRet;
    }

    /*长度容错*/
    if (dstLen != sizeof(OOP_METER_T))
    {
        nRet = ERR_OPTION;
        return nRet;
    }
    else if(!apdu_next_dpos_get(srcBuf, &offsetTmp16, srcLen, DT_NULL, FALSE))
    {
        nRet = ERR_FORMAT;
        return nRet;
    }
    else
    {
        uint32 srcLenTmp;
        OOP_METER_T oopMeter;

        if (srcBufTmp[offset++] != DT_STRUCTURE)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        if (srcBufTmp[offset++] != 0x04)        //结构体元素个数
        {
            nRet = ERR_FORMAT;
            return nRet;
        }

        pOadInfoTmp->pTab ++;
        oadInfoOffsetAll ++;

        /*配置序号*/
        if (!apdu_next_dpos_get(&srcBufTmp[offset], &offsetTmp16, srcLen - offset, DT_NULL, FALSE))
        {
            nRet = ERR_FORMAT;
            return nRet;
        } 
        else
        {
            srcLenTmp = offsetTmp16;
            offsetTmp = 0;
        }
        if (buf_to_data_common(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLenTmp, &offsetTmp, &oopMeter.nIndex, sizeof(oopMeter.nIndex)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*基本信息*/
        if (buf_to_data_class8_basic_object(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLen - offset, &offsetTmp, &oopMeter.basic, sizeof(oopMeter.basic)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*扩展信息*/
        if (buf_to_data_class8_extended_object(pOadInfoTmp, &oadInfoOffsetTmp, &srcBufTmp[offset], srcLen - offset, &offsetTmp, &oopMeter.extend, sizeof(oopMeter.extend)) < 0)
        {
            nRet = ERR_FORMAT;
            return nRet;
        }
        else
        {
            offset += offsetTmp;
            pOadInfoTmp->pTab += oadInfoOffsetTmp;
            oadInfoOffsetAll += oadInfoOffsetTmp;
        }

        /*附属信息*/
        memset(&oopMeter.annex, 0x00, sizeof(oopMeter.annex));
        memcpy(dstDataTmp, &oopMeter, dstLen);
        offset += 2;
    }

    *pOffset = offset;
    *oadInfoOffset = oadInfoOffsetAll;

    nRet = ERR_OK;

    return nRet;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_oop_meter(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_METER_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 4)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //配置序号
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nIndex, sizeof(data.nIndex));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //基本信息
    dar = buf_to_data_basic_object(pOadInfo, srcBuf, srcLen, &sOffset, &data.basic, sizeof(data.basic));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //扩展信息
    dar = buf_to_data_extended_object(pOadInfo, srcBuf, srcLen, &sOffset, &data.extend, sizeof(data.extend));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //附属信息
    dar = buf_to_data_annex_object(pOadInfo, srcBuf, srcLen, &sOffset, &data.annex, sizeof(data.annex));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案信息，基本信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_oop_meter_basic_object(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOPM_METER_129_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    //配置序号
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.index, sizeof(data.index));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //基本信息
    dar = buf_to_data_basic_object(pOadInfo, srcBuf, srcLen, &sOffset, &data.basic, sizeof(data.basic));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("buf_to_data_basic_object failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_oop_meter_extend_object(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOPM_METER_130_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //配置序号
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.index, sizeof(data.index));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //扩展信息
    dar = buf_to_data_extended_object(pOadInfo, srcBuf, srcLen, &sOffset, &data.ext, sizeof(data.ext));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //附属信息
    memset(&data.annex, 0x00, sizeof(data.annex));
    sOffset += 2;

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_oop_meter_annex_object(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOPM_METER_135_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //配置序号
    dar = basic_buf_to_data(E_TSA, srcBuf, srcLen, &sOffset, &data.add , sizeof(data.add));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //附属信息
    dar = buf_to_data_annex_object(pOadInfo, srcBuf, srcLen, &sOffset, &data.annex, sizeof(data.annex));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(删除一个档案)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_del_one_meter(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint16 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //序号
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(档案信息，基本信息)
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_del_one_meter_by_basic(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_METER_BASIC_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //基本信息
    dar = buf_to_data_basic_object(pOadInfo, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("buf_to_data_basic_object failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_del_one_meter_by_act133(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_METER_M133_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    //通信地址
    dar = basic_buf_to_data(E_TSA, srcBuf, srcLen, &sOffset, &data.add, sizeof(data.add));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //端口号
    dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.port, sizeof(data.port));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      写任务数据到数据中心
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_task_config_uint(OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset,int hUdp)
{

    OOP_TASK_T TASK_T;
    uint32 offset=*pOffset;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint32 i;
    int result,ret;
    NOMAL_OAD_T NormalOad;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60120200;
    
    memset((uint8*)&TASK_T,0x00,sizeof(OOP_TASK_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return ERR_FORMAT;
    }
    offset++;
    //任务ID
    printf("buf_to_data_class8_task_config_uint11 offset is %d\n",offset);
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.id,1);
    NormalOad.infoNum =TASK_T.id;
    printf("TASK_T.id is %d\n",TASK_T.id);
    //任务执行间隔
    if(srcBufTmp[offset++]!=DT_TI)
    {
        return ERR_FORMAT;
    }
    TASK_T.acqFreq.unit=srcBufTmp[offset++];
    printf("TASK_T.acqFreq.unit %d\n",TASK_T.acqFreq.unit);
    memcpy_r((uint8*)&TASK_T.acqFreq.value,srcBufTmp+offset,2);
    offset=offset+2;
    printf("TASK_T.acqFreq.value %x\n",TASK_T.acqFreq.value);
    //方案类型
    result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&TASK_T.planType,1);
    printf("TASK_T.planType %x\n",TASK_T.planType);
    //方案编号
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.planID,1);
    printf("TASK_T.planID %x\n",TASK_T.planID);
    //开始时间
    printf("buf_to_data_class8_task_config_uint22 offset is %d\n",offset);
    if(srcBufTmp[offset++]!=DT_DATETIME_S)
    {
        return ERR_FORMAT;
    }
    memcpy_r((uint8*)&(TASK_T.startTime.year),srcBufTmp+offset,2);
    offset=offset+2;
    memcpy(&(TASK_T.startTime.month),srcBufTmp+offset,5);
    offset=offset+5;
    //frame_printf((uint8*)&TASK_T.startTime.year,7);
    //结束时间
    printf("buf_to_data_class8_task_config_uint33 offset is %d\n",offset);
    if(srcBufTmp[offset++]!=DT_DATETIME_S)
    {
        return ERR_FORMAT;
    }
    memcpy_r((uint8*)&TASK_T.endTime.year,srcBufTmp+offset,2);
    offset=offset+2;
    memcpy((uint8*)&TASK_T.endTime.month,srcBufTmp+offset,5);
    offset=offset+5;
    //frame_printf((uint8*)&TASK_T.endTime.year,7);
    //延时
    printf("buf_to_data_class8_task_config_uint44 offset is %d\n",offset);
    if(srcBufTmp[offset++]!=DT_TI)
    {
        return ERR_FORMAT;
    }
    TASK_T.acqDelay.unit=srcBufTmp[offset++];
    printf("TASK_T.acqDelay.unit is %d\n",TASK_T.acqDelay.unit);
    memcpy_r((uint8*)&TASK_T.acqDelay.value,srcBufTmp+offset,2);
    offset=offset+2;
    printf("TASK_T.acqDelay.value is %x\n",TASK_T.acqDelay.value);

    //任务执行优先级，此处兼容老698协议，E_UNSIGNED和E_ENUM都适应
    if (srcBufTmp[offset] == DT_ENUM)
    {
        result = basic_buf_to_data(E_ENUM, srcBufTmp, srcLen, &offset, &TASK_T.priority, 1);
    }
    else
    {
        result = basic_buf_to_data(E_UNSIGNED, srcBufTmp, srcLen, &offset, &TASK_T.priority, 1);
    }
    printf("TASK_T.priority is %x\n", TASK_T.priority);

    //任务执行状态
    result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&TASK_T.state,1);
    printf("TASK_T.state is %x\n",TASK_T.state);
    //任务开始前脚本id
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.startScriptID,2);
    printf("TASK_T.startScriptID is %x\n",TASK_T.startScriptID);
    //任务完成后脚本id
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.endScriptID,2);
    printf("TASK_T.endScriptID is %x\n",TASK_T.endScriptID);
    //任务运行时段
    printf("buf_to_data_class8_task_config_uint55 offset is %d\n",offset);
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return ERR_FORMAT;
    }
    offset++;
    //类型
    result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&TASK_T.workPeriod.type,1);
    printf("TASK_T.workPeriod.type is %x\n",TASK_T.workPeriod.type);
    //时段表
    printf("buf_to_data_class8_task_config_uint66 offset is %d\n",offset);
    if(srcBufTmp[offset++]!=DT_ARRAY)
    {
        return ERR_FORMAT;
    }
    TASK_T.workPeriod.nNum=srcBufTmp[offset++];
    for(i=0;i<TASK_T.workPeriod.nNum;i++)
    {
        if(srcBufTmp[offset++]!=DT_STRUCTURE)
        {
            return ERR_FORMAT;
        }
        offset++;
        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.workPeriod.period[i].startHour,1);
        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.workPeriod.period[i].startMin,1);
        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.workPeriod.period[i].endHour,1);
        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.workPeriod.period[i].endMin,1);
        printf("offset,&TASK_T.workPeriod.period[i].startHour is %x\n",TASK_T.workPeriod.period[i].startHour);
        printf("TASK_T.workPeriod.period[i].endMin is %x\n",TASK_T.workPeriod.period[i].endMin);
    }
    printf("输出!!!!\n");
    //frame_printf((uint8*)&TASK_T,sizeof(OOP_TASK_T));
    printf("NormalOad.infoNum is %d\n",NormalOad.infoNum);

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&TASK_T,sizeof(OOP_TASK_T));
    
    printf("ret is %d\n",ret);
    if(ret<0)
    {
        return DATA_READ_WRITE_DENIED;
    }
    *pOffset=offset;
    return result;
}

/**
*********************************************************************
* @brief：      更新任务数据到数据中心
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_update_task_config_uint(OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset,int hUdp)
{

    OOP_TASK_T TASK_T;
    uint32 offset=*pOffset;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint32 len;
    OOP_DAR_E result,ret;
    NOMAL_OAD_T NormalOad;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60120200;
    
    memset((uint8*)&TASK_T,0x00,sizeof(OOP_TASK_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return DATA_TYPE_UNMATCHED;
    }
    offset++;
    
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&TASK_T.id,1);
    
    PRTL_FMT_LOGCC("TASK_T.id is %d,result is %d\n",TASK_T.id,result);
    if(result !=0)
    {
        return result;
    }
    NormalOad.infoNum =TASK_T.id;

    ret=db_read_nomal(hUdp, &NormalOad,sizeof(OOP_TASK_T), (uint8*)&TASK_T, &len);

    PRTL_FMT_LOGCC("ret is %d\n",ret);
    if((ret !=0)||(len !=sizeof(OOP_TASK_T)))
    {
        return DATA_OBJECT_UNAVAILABLE;
    }

    result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&TASK_T.state,1);
    
    PRTL_FMT_LOGCC("result is %d\n",result);
    if(result !=0)
    {
        return result;
    }

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&TASK_T,sizeof(OOP_TASK_T));

    PRTL_FMT_LOGCC("ret123 is %d\n",ret);
    if(ret !=0)
    {
        return DATA_READ_WRITE_DENIED;
    }
    *pOffset=offset;
    return DATA_SUCCESS;
}

/**
*********************************************************************
* @brief：      写普通方案数据到数据中心
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_normal_scheme(OAD_INFO_T *pOadInfo, void *srcBuf, uint32 srcLen, uint32 *pOffset, int hUdp)
{

    OOP_PLAN_NORMAL_T PLAN_NORMAL_T;
    uint32 offset=*pOffset;;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint32 i,j;
    uint16 dataLen;
    int ret,result;
    OOP_TSA_T addr;
    NOMAL_OAD_T NormalOad;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60140200;

    memset((uint8*)&PLAN_NORMAL_T,0x00,sizeof(OOP_PLAN_NORMAL_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return ERR_FORMAT;
    }
    offset++;
    //方案编号
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.planID,1);
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.planID is %d\n",PLAN_NORMAL_T.planID);
    NormalOad.infoNum =PLAN_NORMAL_T.planID;
    //存储深度
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.memDepth,2);
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.memDepth is %d\n",PLAN_NORMAL_T.memDepth);
    //采集方式
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return ERR_FORMAT;
    }
    offset++;
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.recdRow.choice,1);
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.choice is %d\n",PLAN_NORMAL_T.recdRow.choice);
    switch(PLAN_NORMAL_T.recdRow.choice)
    {
        case 0:
        {
            offset++;
        }
        break;
        case 1:
        {
            result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.recdRow.num,1);
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.num is %d\n",PLAN_NORMAL_T.recdRow.num);
        }
        break;
        case 2:
        {
            offset++;
        }
        break;
        case 3:
        {
            if(srcBufTmp[offset++]!=DT_TI)
            {
                return ERR_FORMAT;
            }
            PLAN_NORMAL_T.recdRow.ti.unit=srcBufTmp[offset++];
            memcpy_r((uint8*)&PLAN_NORMAL_T.recdRow.ti.value,srcBufTmp+offset,2);
            offset=offset+2;
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.ti.unit is %d\n",PLAN_NORMAL_T.recdRow.ti.unit);
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.ti.value is %x\n",PLAN_NORMAL_T.recdRow.ti.value);
        }   
        break;
        case 4:
        {
            if(srcBufTmp[offset++]!=DT_STRUCTURE)
            {
                return ERR_FORMAT;
            }
            offset++;
            if(srcBufTmp[offset++]!=DT_TI)
            {
                return ERR_FORMAT;
            }
            PLAN_NORMAL_T.recdRow.rd.ti.unit=srcBufTmp[offset++];
            
            memcpy_r((uint8*)&PLAN_NORMAL_T.recdRow.rd.ti.value,srcBufTmp+offset,2);
            offset=offset+2;
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.rd.ti.unit is %d\n",PLAN_NORMAL_T.recdRow.rd.ti.unit);
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.rd.ti.value is %x\n",PLAN_NORMAL_T.recdRow.rd.ti.value);
            result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.recdRow.rd.last,2);
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.rd.last is %d\n",PLAN_NORMAL_T.recdRow.rd.last);
        }
        break;
        default:

        break;  
    }
    //记录列选择
    if(srcBufTmp[offset++]!=DT_ARRAY)
    {
        return ERR_FORMAT;
    }
    PLAN_NORMAL_T.recdCol.num=srcBufTmp[offset++];
    if(PLAN_NORMAL_T.recdCol.num > OOP_MAX_CSDS)
    {
        return ERR_FORMAT;
    }
    for(i=0;i<PLAN_NORMAL_T.recdCol.num;i++)
    {
        if(srcBufTmp[offset++]!=DT_CSD)
        {
                return ERR_FORMAT;
        }
        switch(srcBufTmp[offset++])
        {
        case 0:
        {
            PLAN_NORMAL_T.recdCol.csd[i].choice=0;
            PLAN_NORMAL_T.recdCol.csd[i].oad.value=bin2_int32u(srcBufTmp+offset);
            offset=offset+4;
            PRTL_FMT_LOGCC("PLAN_NORMAL_T.recdRow.rd.last is %x\n",PLAN_NORMAL_T.recdCol.csd[i].oad.value);
        }
        break;
        case 1:
        {
            PLAN_NORMAL_T.recdCol.csd[i].choice=1;
            PLAN_NORMAL_T.recdCol.csd[i].road.oadMain.value=bin2_int32u(srcBufTmp+offset);
            offset=offset+4;
            PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.nNum=srcBufTmp[offset++];
            if(PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.nNum > OOP_MAX_OADS)
            {
                return ERR_FORMAT;
            }
            PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.rsv=0;
            for(j=0;j<PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.nNum;j++)
            {
                PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.oad[j].value=bin2_int32u(srcBufTmp+offset);
                offset=offset+4;
            }   
        }
        break;
        default:
        break;
            
        }
    }
    //表计集合
    if(srcBufTmp[offset++]!=DT_MS)
    {
        return ERR_FORMAT;
    }
    PLAN_NORMAL_T.ms.choice=srcBufTmp[offset++];
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.ms.choice is %d\n",PLAN_NORMAL_T.ms.choice);
    switch(PLAN_NORMAL_T.ms.choice)
    {
        case 0:
        case 1:
        break;
        case 2:
        {
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.mst.size=dataLen;
            memcpy(PLAN_NORMAL_T.ms.mst.type,srcBufTmp+offset,dataLen);
            offset=offset+dataLen;      
        }
        break;
        case 3:
        {
            uint8 tsalen=0,j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.msa.size=dataLen;  
            PRTL_FMT_LOGCC("dataLen is %d\n",dataLen);
            PRTL_BUF_LOGCC(srcBufTmp+offset,20,"一组用户地址");
            for(j=0;j<dataLen;j++)
            {
                tsalen=srcBufTmp[offset++];
                memset(&addr,0x00,sizeof(addr));
                PRTL_FMT_LOGCC("tsalen is %d,offset is %d\n",tsalen,offset);
                addr.af = srcBufTmp[offset++];
                PRTL_FMT_LOGCC("addr.af is %d,addr.flag is %d\n",addr.af,addr.flag);
                if(addr.flag == 0x01)
                {
                    addr.vxd = srcBufTmp[offset++];
                    memcpy(addr.add,srcBufTmp+offset,addr.len);
                    offset += addr.len;
                }
                else
                {
                    memcpy(addr.add,srcBufTmp+offset,addr.len+1);
                    offset += addr.len + 1;
                }
                memcpy((uint8*)&PLAN_NORMAL_T.ms.msa.add[j],(uint8*)&addr,sizeof(OOP_TSA_T));
                PRTL_BUF_LOGCC((uint8*)&addr,sizeof(OOP_TSA_T),"地址");
            }
        }
        break;
        case 4:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.msi.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                memcpy_r((uint8*)&PLAN_NORMAL_T.ms.msi.idx[j],srcBufTmp+offset,2);
                offset=offset+2;
            }
        }
        break;
        case 5:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.msrt.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                PLAN_NORMAL_T.ms.msrt.region[j].nType=srcBufTmp[offset++];
                result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.ms.msrt.region[j].start,1);
                result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.ms.msrt.region[j].end,1);
                PRTL_FMT_LOGCC("PLAN_NORMAL_T.ms.msrt.region[j].nType is %x\n",PLAN_NORMAL_T.ms.msrt.region[j].nType);
                PRTL_FMT_LOGCC("PLAN_NORMAL_T.ms.msrt.region[j].start is %x\n",PLAN_NORMAL_T.ms.msrt.region[j].start);
                PRTL_FMT_LOGCC("PLAN_NORMAL_T.ms.msrt.region[j].end is %x\n",PLAN_NORMAL_T.ms.msrt.region[j].end);
            }
        }
        break;
        case 6:
        {

            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.msra.size=dataLen;
            for(j=0;j<dataLen;j++)
            {

                PLAN_NORMAL_T.ms.msra.region[j].nType=srcBufTmp[offset++];
                result=basic_buf_to_data(E_TSA,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.ms.msra.region[j].start,sizeof(OOP_TSA_T));
                if(result != DATA_SUCCESS)
                {
                    return DATA_TYPE_UNMATCHED;
                }
                result=basic_buf_to_data(E_TSA,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.ms.msra.region[j].end,sizeof(OOP_TSA_T));
                if(result != DATA_SUCCESS)
                {
                    return DATA_TYPE_UNMATCHED;
                }
//                offset++;
//                tsalen=srcBufTmp[offset++];
//                memcpy((uint8*)&PLAN_NORMAL_T.ms.msra.region[j].start,srcBufTmp+offset,tsalen);
//                offset=offset+tsalen;
//                offset++;
//                tsalen=srcBufTmp[offset++];
//                memcpy((uint8*)&PLAN_NORMAL_T.ms.msra.region[j].end,srcBufTmp+offset,tsalen);
//                offset=offset+tsalen;
            }
        }   
        break;
        case 7:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.msra.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                PLAN_NORMAL_T.ms.msri.region[j].nType=srcBufTmp[offset++];
                result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.ms.msri.region[j].start,2);
                result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.ms.msri.region[j].end,2);
                PRTL_FMT_LOGCC("PLAN_NORMAL_T.ms.msri.region[j].start is %d\n",PLAN_NORMAL_T.ms.msri.region[j].start);
                PRTL_FMT_LOGCC("PLAN_NORMAL_T.ms.msri.region[j].end is %d\n",PLAN_NORMAL_T.ms.msri.region[j].end);
            }
            
        }
        break;

       case 8:  //一组设备类型
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_NORMAL_T.ms.size=dataLen;
            PLAN_NORMAL_T.ms.msdt.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                memcpy_r((uint8*)&PLAN_NORMAL_T.ms.msdt.type[j],srcBufTmp+offset,2);
                offset=offset+2;
            }
        }
        break;

    }
    //存储时标选择
    result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&PLAN_NORMAL_T.tmFlag,1);
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.tmFlag is %d\n",PLAN_NORMAL_T.tmFlag);
    PRTL_FMT_LOGCC("输出!!!!\n");
    //frame_printf((uint8*)&PLAN_NORMAL_T,sizeof(OOP_PLAN_NORMAL_T));
    PRTL_FMT_LOGCC("NormalOad.infoNum is %d\n",NormalOad.infoNum);

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&PLAN_NORMAL_T,sizeof(OOP_PLAN_NORMAL_T));
    if(ret != 0)
    {
        PRTL_FMT_DEBUG("normal_scheme: db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
            ret, NormalOad.logicId, NormalOad.infoNum, NormalOad.oad.value);
        return DATA_READ_WRITE_DENIED;
    }
    *pOffset=offset;
    return result;
}

/**
*********************************************************************
* @brief：      写事件方案数据到数据中心
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 buf_to_data_class8_event_scheme(OAD_INFO_T *pOadInfo,  const void *srcBuf, uint32 srcLen, uint32 *pOffset, int hUdp)
{

    OOP_PLAN_EVENT_T PLAN_EVENT_T;
    uint32 offset=*pOffset;;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint32 i,j;
    uint16 dataLen;
    int ret,result;
    NOMAL_OAD_T NormalOad;
    OOP_TSA_T addr;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60160200;

    memset((uint8*)&PLAN_EVENT_T,0x00,sizeof(OOP_PLAN_EVENT_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return ERR_FORMAT;
    }
    offset++;
    //方案编号
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.planID,1);
    NormalOad.infoNum =PLAN_EVENT_T.planID;
    printf("PLAN_EVENT_T.planID is %d\n",PLAN_EVENT_T.planID);
    //采集方式
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return ERR_FORMAT;
    }
    offset++;
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.nType,1);
    printf("PLAN_EVENT_T.nType is %d\n",PLAN_EVENT_T.nType);
    switch(PLAN_EVENT_T.nType)
    {
        case 0:
        {
            if(srcBufTmp[offset++]!=DT_ARRAY)
            {
                return ERR_FORMAT;
            }
            PLAN_EVENT_T.events.nNum=srcBufTmp[offset++];
            if(PLAN_EVENT_T.events.nNum > OOP_MAX_EVENT)
            {
                return ERR_FORMAT;
            }
            for(i=0;i<PLAN_EVENT_T.events.nNum;i++)
            {
                if(srcBufTmp[offset++]!=DT_ROAD)
                {
                    return ERR_FORMAT;
                }
                PLAN_EVENT_T.events.cols[i].oadMain.value=bin2_int32u(srcBufTmp+offset);
                printf("PLAN_EVENT_T.events.cols[i].oadMain.value is %x\n",PLAN_EVENT_T.events.cols[i].oadMain.value);
                offset=offset+4;
                PLAN_EVENT_T.events.cols[i].oadCols.nNum=srcBufTmp[offset++];
                printf("PLAN_EVENT_T.events.cols[i].oadCols.nNum is %d\n",PLAN_EVENT_T.events.cols[i].oadCols.nNum);
                if(PLAN_EVENT_T.events.cols[i].oadCols.nNum > OOP_MAX_OADS)
                {
                    return ERR_FORMAT;
                }
                PLAN_EVENT_T.events.cols[i].oadCols.rsv=0;
                for(j=0;j<PLAN_EVENT_T.events.cols[i].oadCols.nNum;j++)
                {
                    PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value=bin2_int32u(srcBufTmp+offset);
                    offset=offset+4;
                    printf("PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value is %x\n",PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value);
                }
            }
        }
        break;
        case 1:
        {
            offset++;
        }
        break;
        case 2:
        {
            if(srcBufTmp[offset++]!=DT_ARRAY)
            {
                return ERR_FORMAT;
            }
            PLAN_EVENT_T.events.nNum=srcBufTmp[offset++];
            if(PLAN_EVENT_T.events.nNum > OOP_MAX_EVENT)
            {
                return ERR_FORMAT;
            }
            for(i=0;i<PLAN_EVENT_T.events.nNum;i++)
            {
                if(srcBufTmp[offset++]!=DT_ROAD)
                {
                    return ERR_FORMAT;
                }
                PLAN_EVENT_T.events.cols[i].oadMain.value=bin2_int32u(srcBufTmp+offset);
                printf("PLAN_EVENT_T.events.cols[i].oadMain.value is %x\n",PLAN_EVENT_T.events.cols[i].oadMain.value);
                offset=offset+4;
                PLAN_EVENT_T.events.cols[i].oadCols.nNum=srcBufTmp[offset++];
                if(PLAN_EVENT_T.events.cols[i].oadCols.nNum > OOP_MAX_OADS)
                {
                    return ERR_FORMAT;
                }
                PLAN_EVENT_T.events.cols[i].oadCols.rsv=0;
                for(j=0;j<PLAN_EVENT_T.events.cols[i].oadCols.nNum;j++)
                {
                    PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value=bin2_int32u(srcBufTmp+offset);
                    offset=offset+4;
                    printf("PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value is %x\n",PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value);
                }
            }
        }
        break;
        case 3:
        {
            offset++;
        }   
        break;

        default:

        break;  
    }
    //表计集合
        //表计集合
    if(srcBufTmp[offset++]!=DT_MS)
    {
        return ERR_FORMAT;
    }
    PLAN_EVENT_T.ms.choice=srcBufTmp[offset++];
    printf("PLAN_EVENT_T.ms.choice is %d\n",PLAN_EVENT_T.ms.choice);
    switch(PLAN_EVENT_T.ms.choice)
    {
        case 0:
        case 1:
        break;
        case 2:
        {
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.mst.size=dataLen;
            memcpy(PLAN_EVENT_T.ms.mst.type,srcBufTmp+offset,dataLen);
            offset=offset+dataLen;      
        }
        break;
        case 3:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.msa.size=dataLen;   
            for(j=0;j<dataLen;j++)
            {
                offset++;
                memset(&addr,0x00,sizeof(addr));
                addr.af = srcBufTmp[offset++];
                if(addr.flag == 0x01)
                {
                    addr.vxd = srcBufTmp[offset++];
                    memcpy(addr.add,srcBufTmp+offset,addr.len);
                    offset=offset+addr.len;
                }
                else
                {
                    memcpy(addr.add,srcBufTmp+offset,addr.len+1);
                    offset=offset+addr.len+1;
                }

                //memcpy((uint8*)&PLAN_EVENT_T.ms.msa.add[j],srcBufTmp+offset,tsalen);
                memcpy(&PLAN_EVENT_T.ms.msa.add[j],&addr,sizeof(OOP_TSA_T));
                //offset=offset+addr.len+1;
            }
        }
        break;
        case 4:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.msi.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                memcpy_r((uint8*)&PLAN_EVENT_T.ms.msi.idx[j],srcBufTmp+offset,2);
                offset=offset+2;
            }
        }
        break;
        case 5:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.msrt.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                PLAN_EVENT_T.ms.msrt.region[j].nType=srcBufTmp[offset++];
                result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.ms.msrt.region[j].start,1);
                result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.ms.msrt.region[j].end,1);
            }
        }
        break;
        case 6:
        {

            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.msra.size=dataLen;
            for(j=0;j<dataLen;j++)
            {

                PLAN_EVENT_T.ms.msra.region[j].nType=srcBufTmp[offset++];

                result=basic_buf_to_data(E_TSA,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.ms.msra.region[j].start,sizeof(OOP_TSA_T));
                if(result != DATA_SUCCESS)
                {
                    return DATA_TYPE_UNMATCHED;
                }
                result=basic_buf_to_data(E_TSA,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.ms.msra.region[j].end,sizeof(OOP_TSA_T));
                if(result != DATA_SUCCESS)
                {
                    return DATA_TYPE_UNMATCHED;
                }
//                printf("PLAN_EVENT_T.ms.msra.region[j].nType is %d\n",PLAN_EVENT_T.ms.msra.region[j].nType);
//                offset++;
//                tsalen=srcBufTmp[offset++];
//                memcpy((uint8*)&PLAN_EVENT_T.ms.msra.region[j].start,srcBufTmp+offset,tsalen);
//                printf("AASS\n");
//                //frame_printf((uint8*)&PLAN_EVENT_T.ms.msra.region[j].start,tsalen);
//                offset=offset+tsalen;
//                offset++;
//                tsalen=srcBufTmp[offset++];
//                memcpy((uint8*)&PLAN_EVENT_T.ms.msra.region[j].end,srcBufTmp+offset,tsalen);
//                offset=offset+tsalen;
//                //frame_printf((uint8*)&PLAN_EVENT_T.ms.msra.region[j].end,tsalen);
            }
        }   
        break;
        case 7:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.msra.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                PLAN_EVENT_T.ms.msri.region[j].nType=srcBufTmp[offset++];
                result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.ms.msri.region[j].start,2);
                result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.ms.msri.region[j].end,2);
            }
            
        }
        break;

        case 8:
        {
            uint8 j=0;
            dataLen = srcBufTmp[offset++];
            if(dataLen ==0x81)
            {
                dataLen = srcBufTmp[offset++];
            }
            else if(dataLen == 0x82)
            {
                dataLen = srcBufTmp[offset++];
                dataLen <<= 8;
                dataLen += srcBufTmp[offset++];
            }
            else if(dataLen>0x82||dataLen==0x80)
            {
                return ERR_OPTION;
            }
            PLAN_EVENT_T.ms.size=dataLen;
            PLAN_EVENT_T.ms.msdt.size=dataLen;
            for(j=0;j<dataLen;j++)
            {
                memcpy_r((uint8*)&PLAN_EVENT_T.ms.msdt.type[j],srcBufTmp+offset,2);
                offset=offset+2;
            }
        }
        break;

        
    }
    //上报标识
    result=basic_buf_to_data(E_BOOL,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.bReport,1);
    printf("PLAN_EVENT_T.bReport is %d\n",PLAN_EVENT_T.bReport);
    //存储深度
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.nDepth,2);
    printf("PLAN_EVENT_T.nDepth is %d\n",PLAN_EVENT_T.nDepth);

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&PLAN_EVENT_T,sizeof(OOP_PLAN_EVENT_T));
    
    printf("eventret is %d\n",ret);
    if(ret<0)
    {
        return DATA_READ_WRITE_DENIED;
    }
    *pOffset=offset;
    return result;
    
}

int32 buf_to_data_class8_update_event_scheme(OAD_INFO_T *pOadInfo,  const void *srcBuf, uint32 srcLen, uint32 *pOffset, int hUdp)
{

    OOP_PLAN_EVENT_T PLAN_EVENT_T;
    uint32 offset=*pOffset;;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint32 len;
    int ret,result;
    NOMAL_OAD_T NormalOad;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60160200;

    memset((uint8*)&PLAN_EVENT_T,0x00,sizeof(OOP_PLAN_EVENT_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return DATA_TYPE_UNMATCHED;
    }
    offset++;
    //方案编号
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.planID,1);
    if(result !=0)
    {
        return result;
    }
    NormalOad.infoNum =PLAN_EVENT_T.planID;

    ret=db_read_nomal(hUdp, &NormalOad,sizeof(OOP_PLAN_EVENT_T), (uint8*)&PLAN_EVENT_T, &len);
    
    if((ret !=0)||(len !=sizeof(OOP_PLAN_EVENT_T)))
    {
        return DATA_OBJECT_UNAVAILABLE;
    }

    result=basic_buf_to_data(E_BOOL,srcBufTmp,srcLen,&offset,&PLAN_EVENT_T.bReport,1);
    if(result !=0)
    {
        return result;
    }

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&PLAN_EVENT_T,sizeof(OOP_PLAN_EVENT_T));
    
    if(ret !=0)
    {
        return DATA_READ_WRITE_DENIED;
    }


    *pOffset=offset;
    return result;
    
}

/**
*********************************************************************
* @name：       normal_colscheme_csd_reset
* @brief：      重置普通采集方案的CSD
* @param[in] ：pOdaInfo        OAD信息
               inData         输入报文
               inLen          输入报文长度
* @return    ：输出报文实际长度
* @author    : 贺宁
* @Date      ：2020-03-26
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_transparent_scheme(OAD_INFO_T *pOadInfo, void *srcBuf, uint32 srcLen, uint32 *pOffset, int hUdp)
{

   
    uint32 offset=*pOffset;;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint32 i,j;
    uint16 dataLen;
    uint8 bytes;
//    uint8 adrrslen=0;
    OOP_DAR_E result = DATA_SUCCESS;
    int ret;
    NOMAL_OAD_T NormalOad;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60180200;
    

 
    OOP_PLAN_TRANS_T PLAN_TRANS_T;

   
    memset((uint8*)&PLAN_TRANS_T,0x00,sizeof(OOP_PLAN_TRANS_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return DATA_TYPE_UNMATCHED;
    }
    offset++;
    //方案编号
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.planID,1);
    NormalOad.infoNum =PLAN_TRANS_T.planID;
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.planID is %d\n",PLAN_TRANS_T.planID);
   
    //方案内容集
    if(srcBufTmp[offset++]!=DT_ARRAY)
    {
        return DATA_TYPE_UNMATCHED;
    }
    //方案内容数
    PLAN_TRANS_T.value.nNum= srcBufTmp[offset++];
    //result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.nNum,1);
    for(i=0;i<PLAN_TRANS_T.value.nNum;i++)
    {
        //方案内容
        if(srcBufTmp[offset++]!=DT_STRUCTURE)
        {
            PRTL_FMT_LOGCC("方案内容\n");
            return DATA_TYPE_UNMATCHED;
        }
        offset++;
        //序号
        result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].nIndex,2);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("序号\n");
            return result;
        }
        //通信地址
//        if(srcBufTmp[offset++] !=DT_TSA)
//        {
//            PRTL_FMT_LOGCC("通信地址\n");
//            return DATA_TYPE_UNMATCHED;
//
//        }
//        offset++;
//        adrrslen=srcBufTmp[offset++];
//        PLAN_TRANS_T.value.info[i].addr.af=adrrslen;
//        memcpy(PLAN_TRANS_T.value.info[i].addr.add,&srcBufTmp[offset],adrrslen+1);
//        offset=offset+adrrslen+1;

        result=basic_buf_to_data(E_TSA,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].addr,sizeof(OOP_TSA_T));
        if(result != DATA_SUCCESS)
        {
            return DATA_TYPE_UNMATCHED;
        }

        //开始前脚本id
        result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].startid,2);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("开始前脚本id\n");
            return result;
        }
        //完成后脚本id
        result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].endid,2);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("完成后脚本id\n");
            return result;
        }
        //方案控制标志
        if(srcBufTmp[offset++]!=DT_STRUCTURE)
        {
            PRTL_FMT_LOGCC("方案控制标志\n");
            return DATA_TYPE_UNMATCHED;
        }
        offset++;
        //上报透明方案结果并等待后续报文
        result=basic_buf_to_data(E_BOOL,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.bReport,1);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("上报透明方案结果并等待后续报文\n");
            return result;
        }
        //等待后续报文超时时间(秒)
        result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.nDelay,2);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("等待后续报文超时时间(秒)\n");
            return result;
        }
        //结果比对标识
        result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.nCompare,1);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("结果比对标识\n");
            return result;
        }
        //结果比对参数
        if(srcBufTmp[offset++]!=DT_STRUCTURE)
        {
            PRTL_FMT_LOGCC("结果比对参数\n");
            return DATA_TYPE_UNMATCHED;
        }
        offset++;
        // 特征字节
        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.cmpParm.flag,1);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("特征字节\n");
            return result;
        }
        //截取开始
        result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.cmpParm.start,2);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("截取开始\n");
            return result;
        }
        //截取长度
        result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.cmpParm.len,2);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("截取长度\n");
            return result;
        }
        
        //方案报文集
        if(srcBufTmp[offset++]!=DT_ARRAY)
        {
            PRTL_FMT_LOGCC("方案报文集\n");
            return DATA_TYPE_UNMATCHED;
        }
        //方案报文数
        PLAN_TRANS_T.value.info[i].cmd.nNum = srcBufTmp[offset++];

        for(j=0;j<PLAN_TRANS_T.value.info[i].cmd.nNum;j++)
        {
            if(srcBufTmp[offset++]!=DT_STRUCTURE)
            {
                return DATA_TYPE_UNMATCHED;
            }
            offset++;
            //报文序号
            result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex,1);
            if(result !=DATA_SUCCESS)
            {
                PRTL_FMT_LOGCC("报文序号111\n");
                return result;
            }
            //报文内容
            if(srcBufTmp[offset++]!=DT_OCTET_STRING)
            {
                return DATA_TYPE_UNMATCHED;
            }
            dataLen=get_len_offset(srcBufTmp+offset, &bytes);
            offset=offset+bytes;
            PLAN_TRANS_T.value.info[i].cmd.value[j].data.nNum=dataLen;
            memcpy(PLAN_TRANS_T.value.info[i].cmd.value[j].data.value,srcBufTmp+offset,dataLen);
            offset =offset+dataLen;
        }
        
    }
    
    //存储深度
    PRTL_FMT_LOGCC("存储深度,offset is %d\n",offset);
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.nSaveCount,2);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("存储深度\n");
        return result;
    }
    PRTL_FMT_LOGCC("PLAN_TRANS_T.nSaveCount is %d\n",PLAN_TRANS_T.nSaveCount);

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&PLAN_TRANS_T,sizeof(OOP_PLAN_TRANS_T));
    
    PRTL_FMT_LOGCC("ret is %d\n",ret);
    if(ret != 0)
    {
        return DATA_READ_WRITE_DENIED;
    }
    *pOffset=offset;
    //从报文中提取数据


    return result;
}

/**
*********************************************************************
* @name：       
* @brief：     
* @param[in] ：pOdaInfo        OAD信息
               inData         输入报文
               inLen          输入报文长度
* @return    ：输出报文实际长度
* @author    : 
* @Date      ：
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_Add_Meter_Frame(OAD_INFO_T *pOadInfo, void *srcBuf, uint32 srcLen, uint32 *pOffset, int hUdp)

{
    OOP_PLAN_TRANS_T PLAN_TRANS_T;
    //OOP_PLAN_TRANS_T PLAN_TRANS;
    uint32 offset=*pOffset;;
    uint8 *srcBufTmp=(uint8*)srcBuf;
    uint8 m=0;
    uint32 i=0,j,len;
    uint16 dataLen;
    uint8 bytes;
    OOP_TSA_T addr; 
    uint8 number=0;
    //uint8 sameaddr=0;
    //uint8 adrrslen=0;
    uint8 addframenum=0;
    //uint8 framenum=0;
    OOP_DAR_E result = DATA_SUCCESS;
    int ret;
    NOMAL_OAD_T NormalOad;
    NormalOad.logicId = 0;
    NormalOad.infoNum = 0;
    NormalOad.oad.value =0x60180200;
    
 
    memset((uint8*)&PLAN_TRANS_T,0x00,sizeof(OOP_PLAN_TRANS_T));
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        return DATA_TYPE_UNMATCHED;
    }
    offset++;
    //方案编号
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.planID,1);
    NormalOad.infoNum =PLAN_TRANS_T.planID;
    PRTL_FMT_LOGCC("PLAN_NORMAL_T.planID is %d\n",PLAN_TRANS_T.planID);
   
    ret=db_read_nomal(hUdp, &NormalOad,sizeof(OOP_PLAN_TRANS_T), (uint8*)&PLAN_TRANS_T, &len);
    if((ret != 0)||(len==0))
    {
        return DATA_TYPE_UNMATCHED;
    }
    
    //通信地址
//    if(srcBufTmp[offset++] !=DT_TSA)
//    {
//        PRTL_FMT_LOGCC("通信地址\n");
//        return DATA_TYPE_UNMATCHED;
//
//    }
//    offset++;
//    adrrslen=srcBufTmp[offset++];
//    memcpy(add,&srcBufTmp[offset],6);

    result=basic_buf_to_data(E_TSA,srcBufTmp,srcLen,&offset,&addr,sizeof(OOP_TSA_T));
    if(result != DATA_SUCCESS)
    {
        return DATA_TYPE_UNMATCHED;
    }
    for(i=0;i<PLAN_TRANS_T.value.nNum;i++)
    {
//        PLAN_TRANS_T.value.info[i].addr.af=adrrslen;
//        memcpy_r(PLAN_TRANS_T.value.info[i].addr.add,&srcBufTmp[offset],adrrslen+1);

          if(0==memcmp(PLAN_TRANS_T.value.info[i].addr.add,addr.add,6))
          {
            PRTL_FMT_LOGCC("存在相同的表地址\n");
            //sameaddr=1;
            break;
          }
    }
    if(i>=PLAN_TRANS_T.value.nNum)
    {
//        if(PLAN_TRANS_T.value.nNum<OOP_MAX_TRANS_INFO)
//        {
//            PLAN_TRANS_T.value.nNum++;
//        }
//        else
        {
            return DATA_TYPE_UNMATCHED;
        }
    }
    //offset=offset+adrrslen+1;
    
    //方案控制标志
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        PRTL_FMT_LOGCC("方案控制标志\n");
        return DATA_TYPE_UNMATCHED;
    }
    offset++;
    //上报透明方案结果并等待后续报文
    result=basic_buf_to_data(E_BOOL,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.bReport,1);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("上报透明方案结果并等待后续报文\n");
        return result;
    }
    //等待后续报文超时时间(秒)
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.nDelay,2);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("等待后续报文超时时间(秒)\n");
        return result;
    }
    //结果比对标识
    result=basic_buf_to_data(E_ENUM,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.nCompare,1);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("结果比对标识\n");
        return result;
    }
    //结果比对参数
    if(srcBufTmp[offset++]!=DT_STRUCTURE)
    {
        PRTL_FMT_LOGCC("结果比对参数\n");
        return DATA_TYPE_UNMATCHED;
    }
    offset++;
    // 特征字节
    result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.cmpParm.flag,1);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("特征字节\n");
        return result;
    }
    //截取开始
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.cmpParm.start,2);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("截取开始\n");
        return result;
    }
    //截取长度
    result=basic_buf_to_data(E_LONG_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].flag.cmpParm.len,2);
    if(result !=DATA_SUCCESS)
    {
        PRTL_FMT_LOGCC("截取长度\n");
        return result;
    }
    
    //方案报文集
    if(srcBufTmp[offset++]!=DT_ARRAY)
    {
        PRTL_FMT_LOGCC("方案报文集\n");
        return DATA_TYPE_UNMATCHED;
    }
    //方案报文数
    addframenum=srcBufTmp[offset++];
    PRTL_FMT_LOGCC("addframenum is %d\n",addframenum);

    //framenum=PLAN_TRANS_T.value.info[i].cmd.nNum;
    
    PRTL_FMT_LOGCC("PLAN_TRANS_T.value.info[i].cmd.nNum is %d\n",PLAN_TRANS_T.value.info[i].cmd.nNum);
    //PLAN_TRANS_T.value.info[i].cmd.nNum =PLAN_TRANS_T.value.info[i].cmd.nNum +addframenum;

//    for(j=framenum;j<PLAN_TRANS_T.value.info[i].cmd.nNum;j++)
//    {
//        if(srcBufTmp[offset++]!=DT_STRUCTURE)
//        {
//            return DATA_TYPE_UNMATCHED;
//        }
//        offset++;
//        //报文序号
//        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex,1);
//        if(result !=DATA_SUCCESS)
//        {
//            PRTL_FMT_LOGCC("报文序号111\n");
//            return result;
//        }
//        ret=app_get_plan_transparent_list(PLAN_TRANS_T.planID, &PLAN_TRANS);
//        if(ERR_OK==ret)
//        {
//            for(n=0;n<OOP_MAX_TRANS_NUM;n++)
//            {
//
//                if(PLAN_TRANS.value.info[i].cmd.value[n].nIndex==PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex)
//                {   
//                    j=n;
//                    break;
//                }
//            }
//        }
//        //报文内容
//        if(srcBufTmp[offset++]!=DT_OCTET_STRING)
//        {
//            return DATA_TYPE_UNMATCHED;
//        }
//        dataLen=get_len_offset(srcBufTmp+offset, &bytes);
//        offset=offset+bytes;
//        PLAN_TRANS_T.value.info[i].cmd.value[j].data.nNum=dataLen;
//        memcpy(PLAN_TRANS_T.value.info[i].cmd.value[j].data.value,srcBufTmp+offset,dataLen);
//        offset =offset+dataLen;
//    }
    for(m=0;m<addframenum;m++)
    {
        if(srcBufTmp[offset++]!=DT_STRUCTURE)
        {
            return DATA_TYPE_UNMATCHED;
        }
        offset++;
        //报文序号
        result=basic_buf_to_data(E_UNSIGNED,srcBufTmp,srcLen,&offset,&number,1);
        if(result !=DATA_SUCCESS)
        {
            PRTL_FMT_LOGCC("报文序号111\n");
            return result;
        }
        
        for(j=0;j<PLAN_TRANS_T.value.info[i].cmd.nNum;j++)
        {

            if(PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex==number)
            {   
                PRTL_FMT_LOGCC("有相同的报文序号\n");
                break;
            }
        }

        if(j>=PLAN_TRANS_T.value.info[i].cmd.nNum)
        {
            PLAN_TRANS_T.value.info[i].cmd.nNum++;
            PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex=number;
        }
        //报文内容
        if(srcBufTmp[offset++]!=DT_OCTET_STRING)
        {
            return DATA_TYPE_UNMATCHED;
        }
        dataLen=get_len_offset(srcBufTmp+offset, &bytes);
        offset=offset+bytes;
        PLAN_TRANS_T.value.info[i].cmd.value[j].data.nNum=dataLen;
        memcpy(PLAN_TRANS_T.value.info[i].cmd.value[j].data.value,srcBufTmp+offset,dataLen);
        offset =offset+dataLen;
    }    

    NormalOad.classtag = CLASS_DATA_INIT;
    ret=db_write_nomal(hUdp, &NormalOad,(uint8*)&PLAN_TRANS_T,sizeof(OOP_PLAN_TRANS_T));
    
    PRTL_FMT_LOGCC("ret is %d\n",ret);
    if(ret != 0)
    {
        return DATA_READ_WRITE_DENIED;
    }
    *pOffset=offset;
    //从报文中提取数据


    return result;
}

/**
*********************************************************************
* @brief：      读取任务配置单元
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/

int32 data_to_buf_task_config_uint(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{

    int32 nRet = ERR_NORMAL;
    OOP_TASK_T TASK_T;
    uint32 offset=*convert->dOffset;
    uint8 *dstBufTmp=(uint8*)convert->dstBuf;
    uint32 i,dstLen=convert->dstLen;

//    NOMAL_OAD_T NormalOad ;
//    NormalOad.logicId = 0;
//    NormalOad.infoNum = pn;
//    NormalOad.oad.value=0x60120200;
//
//    ret=db_read_nomal(hUdp, &NormalOad,sizeof(OOP_TASK_T), (uint8*)&TASK_T, &len);
    
//    if((ret<0)||(len==0))
//    {
//        return ERR_ITEM;
//    }
    memcpy((uint8*)&TASK_T,(uint8*)convert->srcBuf,convert->srcLen);

    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x0C;
    //方案编号
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.id, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    //执行时间频率
    dstBufTmp[offset++]=DT_TI;
    dstBufTmp[offset++]=TASK_T.acqFreq.unit;
    memcpy_r(dstBufTmp+offset,(uint8*)&TASK_T.acqFreq.value,2);
    offset=offset+2;
    
    //方案类型
    if(basic_data_to_buf(E_ENUM, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.planType, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    //方案编号
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.planID, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    
    //开始时间
    dstBufTmp[offset++]=DT_DATETIME_S;
    memcpy_r(dstBufTmp+offset,(uint8*)&TASK_T.startTime.year,2);
    offset=offset+2;
    memcpy(dstBufTmp+offset,(uint8*)&TASK_T.startTime.month,5);
    offset=offset+5;
    //结束时间
    dstBufTmp[offset++]=DT_DATETIME_S;
    memcpy_r(dstBufTmp+offset,(uint8*)&TASK_T.endTime.year,2);
    offset=offset+2;
    memcpy(dstBufTmp+offset,(uint8*)&TASK_T.endTime.month,5);
    offset=offset+5;
    //延时
    dstBufTmp[offset++]=DT_TI;
    dstBufTmp[offset++]=TASK_T.acqDelay.unit;
    memcpy_r(dstBufTmp+offset,(uint8*)&TASK_T.acqDelay.value,2);
    offset=offset+2;
    //执行优先级
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.priority, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    //任务状态
    if(basic_data_to_buf(E_ENUM, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.state, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    //任务开始前脚本id
    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.startScriptID, 2) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    //任务完成后脚本id
    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.endScriptID, 2) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    
    //任务运行时段
    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x02;
    //类型
    if(basic_data_to_buf(E_ENUM, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.workPeriod.type, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    dstBufTmp[offset++]=DT_ARRAY;
    dstBufTmp[offset++]=TASK_T.workPeriod.nNum;
    for(i=0;i<TASK_T.workPeriod.nNum;i++)
    {
        dstBufTmp[offset++]=DT_STRUCTURE;
        dstBufTmp[offset++]=0x04;
        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.workPeriod.period[i].startHour, 1) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.workPeriod.period[i].startMin, 1) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.workPeriod.period[i].endHour, 1) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &TASK_T.workPeriod.period[i].endMin, 1) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
    }
    *convert->dOffset=offset;
    return ERR_OK;
}

/**
*********************************************************************
* @brief：      读取普通方案配置单元
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/

int32 data_to_buf_normal_scheme(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{

    int32 nRet = ERR_NORMAL;
    OOP_PLAN_NORMAL_T PLAN_NORMAL_T;
    uint32 offset=*convert->dOffset;
    uint32 dstLen=convert->dstLen;
    uint8 *dstBufTmp=(uint8*)convert->dstBuf;
    uint32 i,j;

    uint8 tsalen=0;

    memcpy((uint8*)&PLAN_NORMAL_T,(uint8*)convert->srcBuf,convert->srcLen);
    
    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x06;
    //方案编号
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.planID, 1) < 0)
    {
        nRet = DATA_TYPE_UNMATCHED;
        return nRet;
    }
    
    //存储深度
    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.memDepth, 2) < 0)
    {
        nRet = DATA_TYPE_UNMATCHED;
        return nRet;
    }
    
    //采集方式
    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x02;
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.recdRow.choice, 1) < 0)
    {
        nRet = DATA_TYPE_UNMATCHED;
        return nRet;
    }
    
    switch(PLAN_NORMAL_T.recdRow.choice)
    {
        case 0:
        {
            dstBufTmp[offset++]=0x00;
        }
        break;
        case 1:
        {
            if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.recdRow.num, 1) < 0)
            {
                nRet = DATA_TYPE_UNMATCHED;
                return nRet;
            }
        }
        break;
        case 2:
        {
            dstBufTmp[offset++]=0x00;
        }
        break;
        case 3:
        {
            dstBufTmp[offset++]=DT_TI;
            dstBufTmp[offset++]=PLAN_NORMAL_T.recdRow.ti.unit;
            memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.recdRow.ti.value,2);
            offset=offset+2;
        }
        break;
        case 4:
        {
            dstBufTmp[offset++]=DT_STRUCTURE;
            dstBufTmp[offset++]=0x02;
            dstBufTmp[offset++]=DT_TI;
            dstBufTmp[offset++]=PLAN_NORMAL_T.recdRow.rd.ti.unit;
            memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.recdRow.rd.ti.value,2);
            offset=offset+2;
            if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.recdRow.rd.last, 2) < 0)
            {
                nRet = DATA_TYPE_UNMATCHED;
                return nRet;
            }
        }
        break;
    }
    //记录列选择
    dstBufTmp[offset++]=DT_ARRAY;
    dstBufTmp[offset++]=PLAN_NORMAL_T.recdCol.num;
    
    for(i=0;i<PLAN_NORMAL_T.recdCol.num;i++)
    {
        dstBufTmp[offset++]=DT_CSD;
        switch(PLAN_NORMAL_T.recdCol.csd[i].choice)
        {
            case 0:
            {
                dstBufTmp[offset++]=0x00;
                memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.recdCol.csd[i].oad.value,4);
                offset=offset+4;
                
            }   
            break;
            case 1:
            {
                dstBufTmp[offset++]=0x01;
                memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.recdCol.csd[i].road.oadMain.value,4);
                offset=offset+4;
                dstBufTmp[offset++]=PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.nNum;
                for(j=0;j<PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.nNum;j++)
                {
                    memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.recdCol.csd[i].road.oadCols.oad[j].value,4);
                    offset=offset+4;
                }
            }
            break;

        }
    }
    //表计集合
    dstBufTmp[offset++]=DT_MS;
   
    switch (PLAN_NORMAL_T.ms.choice)
        {
            case 0:
                {
                    dstBufTmp[offset++]=0x00;
                }
            break;
            case 1:
                {
                    dstBufTmp[offset++]=0x01;
                }
            break;
            case 2:
                {
                    dstBufTmp[offset++]=0x02;
                    if(PLAN_NORMAL_T.ms.mst.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.mst.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.mst.size>>8;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.mst.size;
                        
                    }
                    memcpy(dstBufTmp+offset,PLAN_NORMAL_T.ms.mst.type,PLAN_NORMAL_T.ms.mst.size);
                    offset=offset+PLAN_NORMAL_T.ms.mst.size;
                }
            break;
            case 3:
                {
                    dstBufTmp[offset++]=0x03;
                    if(PLAN_NORMAL_T.ms.msa.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msa.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msa.size>>8;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msa.size;
                        
                    }
                    for(i=0;i<PLAN_NORMAL_T.ms.msa.size;i++)
                    {
                        tsalen=PLAN_NORMAL_T.ms.msa.add[i].af&0x0F;
                        if(PLAN_NORMAL_T.ms.msa.add[i].flag == 0x01)
                        {
                            dstBufTmp[offset++]=tsalen+2;
                            dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msa.add[i].af;
                            dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msa.add[i].vxd;
                            memcpy(dstBufTmp + offset, (uint8*)&PLAN_NORMAL_T.ms.msa.add[i].add, tsalen);
                            offset += tsalen;
                        }
                        else
                        {
                            dstBufTmp[offset++]=tsalen+2;
                            dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msa.add[i].af;
                            memcpy(dstBufTmp + offset, (uint8*)&PLAN_NORMAL_T.ms.msa.add[i].add, tsalen + 1);
                            offset += (tsalen + 1);
                        }
                    }
                    
                }
            break;
            case 4:
                {
                    dstBufTmp[offset++]=0x04;
                    if(PLAN_NORMAL_T.ms.msi.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msi.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msi.size>>8;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msi.size;
                        
                    }
                    for(i=0;i<PLAN_NORMAL_T.ms.msi.size;i++)
                    {
                        memcpy_r(dstBufTmp+offset,(uint8*)&(PLAN_NORMAL_T.ms.msi.idx[i]),2);
                        offset=offset+2;
                    }
                }

            break;
            case 5:
                {
                    dstBufTmp[offset++]=0x05;
                    if(PLAN_NORMAL_T.ms.msi.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msrt.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msrt.size>>8;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msrt.size; 
                    }
                    for(i=0;i<PLAN_NORMAL_T.ms.msrt.size;i++)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msrt.region[i].nType;
                        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.ms.msrt.region[i].start, 1) < 0)
                        {
                            nRet = DATA_TYPE_UNMATCHED;
                            return nRet;
                        }
                        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.ms.msrt.region[i].end, 1) < 0)
                        {
                            nRet = DATA_TYPE_UNMATCHED;
                            return nRet;
                        }
                    
                    }
                    
                }
            break;
            case 6:
                {
                
                    dstBufTmp[offset++]=0x06;
                    if(PLAN_NORMAL_T.ms.msra.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msra.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msra.size>>8;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msra.size; 
                    }
                    
                    for(i=0;i<PLAN_NORMAL_T.ms.msra.size;i++)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msra.region[i].nType;
                        if(basic_data_to_buf(E_TSA, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.ms.msra.region[i].start, sizeof(OOP_TSA_T)) < 0)
                        {
                            nRet = DATA_TYPE_UNMATCHED;
                            return nRet;
                        }
                        if(basic_data_to_buf(E_TSA, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.ms.msra.region[i].end, sizeof(OOP_TSA_T)) < 0)
                        {
                            nRet = DATA_TYPE_UNMATCHED;
                            return nRet;
                        }
//                        dstBufTmp[offset++]=DT_TSA;
//                        tsalen=PLAN_NORMAL_T.ms.msra.region[i].start.af&0x0F;
//                        dstBufTmp[offset++]=tsalen+2;
//                        memcpy(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.ms.msra.region[i].start,(tsalen+2));


//                        offset=offset+(tsalen+2);
//                        dstBufTmp[offset++]=DT_TSA;
//                        tsalen=PLAN_NORMAL_T.ms.msra.region[i].end.af&0x0F;
//                        dstBufTmp[offset++]=tsalen+2;
//                        memcpy(dstBufTmp+offset,(uint8*)&PLAN_NORMAL_T.ms.msra.region[i].end,(tsalen+2));
//                        offset=offset+(tsalen+2);
                        
                    
                    }
                }
            break;
            case 7:
            {
                dstBufTmp[offset++]=0x06;
                if(PLAN_NORMAL_T.ms.msi.size<0x80)
                {
                    dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msri.size;
                }
                else
                {
                    dstBufTmp[offset++]=0x82;
                    dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msri.size>>8;
                    dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msri.size; 
                }
                for(i=0;i<PLAN_NORMAL_T.ms.msrt.size;i++)
                {
                    dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msri.region[i].nType;
                    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.ms.msri.region[i].start, 2) < 0)
                    {
                        nRet = DATA_TYPE_UNMATCHED;
                        return nRet;
                    }
                    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.ms.msri.region[i].end, 2) < 0)
                    {
                        nRet = DATA_TYPE_UNMATCHED;
                        return nRet;
                    }
                
                }
            }
        break;
#if AREA_ZHEJIANG
            case 8:
                {
                    dstBufTmp[offset++]=0x08;
                    if(PLAN_NORMAL_T.ms.msdt.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msdt.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msdt.size>>8;
                        dstBufTmp[offset++]=PLAN_NORMAL_T.ms.msdt.size;
                        
                    }
                    for(i=0;i<PLAN_NORMAL_T.ms.msdt.size;i++)
                    {
                        memcpy_r(dstBufTmp+offset,(uint8*)&(PLAN_NORMAL_T.ms.msdt.type[i]),2);
                        offset=offset+2;
                    }
                }

            break;
#endif
        }
        //存储时标选择
        if(basic_data_to_buf(E_ENUM, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_NORMAL_T.tmFlag, 1) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        *convert->dOffset=offset;
        return ERR_OK;
}


/**
*********************************************************************
* @brief：      读取事件方案配置单元
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/

int32 data_to_buf_event_scheme(OAD_INFO_T *pOadInfo,  DATA_CONVERT_T *convert)
{

    int32 nRet = ERR_NORMAL;
    OOP_PLAN_EVENT_T PLAN_EVENT_T;
    uint32 offset=*convert->dOffset;
    uint8 *dstBufTmp=(uint8*)convert->dstBuf;
    uint32 i,j;
    uint32 dstLen=convert->dstLen;
    uint8 tsalen=0;

    memcpy((uint8*)&PLAN_EVENT_T,(uint8*)convert->srcBuf,convert->srcLen);
    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x05;
    //方案编号
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.planID, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    
    //采集方式
    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x02;
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.nType, 1) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
    
    switch(PLAN_EVENT_T.nType)
    {
        case 0:
        {
            dstBufTmp[offset++]=DT_ARRAY;
            dstBufTmp[offset++]=PLAN_EVENT_T.events.nNum;
            for(i=0;i<PLAN_EVENT_T.events.nNum;i++)
            {
                dstBufTmp[offset++]=DT_ROAD;
                memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_EVENT_T.events.cols[i].oadMain.value,4);
                offset=offset+4;
                dstBufTmp[offset++]=PLAN_EVENT_T.events.cols[i].oadCols.nNum;
                for(j=0;j<PLAN_EVENT_T.events.cols[i].oadCols.nNum;j++)
                {
                    memcpy_r(dstBufTmp+offset,(uint8*)&PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value,4);
                    offset=offset+4;
                }
            }
            
        }
        break;
        case 1:
        {
            dstBufTmp[offset++] = 0x00;
        }
        break;
        case 2:
        {
            dstBufTmp[offset++] = DT_ARRAY;
            dstBufTmp[offset++] = PLAN_EVENT_T.events.nNum;
            for(i = 0; i < PLAN_EVENT_T.events.nNum; i++)
            {
                dstBufTmp[offset++] = DT_ROAD;
                memcpy_r(dstBufTmp + offset, (uint8*)&PLAN_EVENT_T.events.cols[i].oadMain.value, 4);
                offset = offset + 4;
                dstBufTmp[offset++] = PLAN_EVENT_T.events.cols[i].oadCols.nNum;
                for(j = 0; j < PLAN_EVENT_T.events.cols[i].oadCols.nNum; j++)
                {
                    memcpy_r(dstBufTmp+offset, (uint8*)&PLAN_EVENT_T.events.cols[i].oadCols.oad[j].value, 4);
                    offset = offset + 4;
                }
            }
        }
        break;
        case 3:
        {
            dstBufTmp[offset++] = 0x00;
        }
        break;

    }
    //表计集合
    dstBufTmp[offset++]=DT_MS;
    
    switch (PLAN_EVENT_T.ms.choice)
        {
            case 0:
                {
                    dstBufTmp[offset++]=0x00;
                }
            break;
            case 1:
                {
                    dstBufTmp[offset++]=0x01;
                }
            break;
            case 2:
                {
                    dstBufTmp[offset++]=0x02;
                    if(PLAN_EVENT_T.ms.mst.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.mst.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.mst.size>>8;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.mst.size;
                        
                    }
                    memcpy(dstBufTmp+offset,PLAN_EVENT_T.ms.mst.type,PLAN_EVENT_T.ms.mst.size);
                    offset=offset+PLAN_EVENT_T.ms.mst.size;
                }
            break;
            case 3:
                {
                    dstBufTmp[offset++]=0x03;
                    if(PLAN_EVENT_T.ms.msa.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msa.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msa.size>>8;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msa.size;
                        
                    }
                    for(i=0;i<PLAN_EVENT_T.ms.msa.size;i++)
                    {
                        tsalen=PLAN_EVENT_T.ms.msa.add[i].af&0x0F;
                        if(PLAN_EVENT_T.ms.msa.add[i].flag == 0x01)
                        {
                            dstBufTmp[offset++]=tsalen+3;
                            dstBufTmp[offset++]=PLAN_EVENT_T.ms.msa.add[i].af;
                            dstBufTmp[offset++]=PLAN_EVENT_T.ms.msa.add[i].vxd;
                        }
                        else
                        {
                            dstBufTmp[offset++]=tsalen+2;
                            dstBufTmp[offset++]=PLAN_EVENT_T.ms.msa.add[i].af;
                        }
                        memcpy(dstBufTmp+offset,(uint8*)&PLAN_EVENT_T.ms.msa.add[i].add,tsalen+1);
                        offset=offset+(tsalen+1);
                    }
                    
                }
            break;
            case 4:
                {
                    dstBufTmp[offset++]=0x04;
                    if(PLAN_EVENT_T.ms.msi.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msi.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msi.size>>8;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msi.size;
                        
                    }
                    for(i=0;i<PLAN_EVENT_T.ms.msi.size;i++)
                    {
                        memcpy_r(dstBufTmp+offset,(uint8*)&(PLAN_EVENT_T.ms.msi.idx[i]),2);
                        offset=offset+2;
                    }
                }

            break;
            case 5:
                {
                    dstBufTmp[offset++]=0x05;
                    if(PLAN_EVENT_T.ms.msi.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msrt.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msrt.size>>8;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msrt.size;  
                    }
                    for(i=0;i<PLAN_EVENT_T.ms.msrt.size;i++)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msrt.region[i].nType;
                        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.ms.msrt.region[i].start, 1) < 0)
                        {
                            nRet = ERR_NORMAL;
                            return nRet;
                        }
                        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.ms.msrt.region[i].end, 1) < 0)
                        {
                            nRet = ERR_NORMAL;
                            return nRet;
                        }
                    
                    }
                    
                }
            break;
            case 6:
                {
//                    uint8 tsalen=0;
                    dstBufTmp[offset++]=0x06;
                    if(PLAN_EVENT_T.ms.msra.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msra.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msra.size>>8;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msra.size;  
                    }
                    
                    for(i=0;i<PLAN_EVENT_T.ms.msra.size;i++)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msra.region[i].nType;
                        if(basic_data_to_buf(E_TSA, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.ms.msra.region[i].start, sizeof(OOP_TSA_T)) < 0)
                        {
                            nRet = DATA_TYPE_UNMATCHED;
                            return nRet;
                        }
                        if(basic_data_to_buf(E_TSA, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.ms.msra.region[i].end, sizeof(OOP_TSA_T)) < 0)
                        {
                            nRet = DATA_TYPE_UNMATCHED;
                            return nRet;
                        }
//                        dstBufTmp[offset++]=DT_TSA;
//                        tsalen=PLAN_EVENT_T.ms.msra.region[i].start.af&0x0F;
//                        dstBufTmp[offset++]=tsalen+2;
//                        memcpy(dstBufTmp+offset,(uint8*)&PLAN_EVENT_T.ms.msra.region[i].start,(tsalen+2));
//                        
//                        offset=offset+(tsalen+2);
//                        dstBufTmp[offset++]=DT_TSA;
//                        tsalen=PLAN_EVENT_T.ms.msra.region[i].end.af&0x0F;
//                        dstBufTmp[offset++]=tsalen+2;
//                        memcpy(dstBufTmp+offset,(uint8*)&PLAN_EVENT_T.ms.msra.region[i].end,(tsalen+2));
//                        offset=offset+(tsalen+2);
                        
                    
                    }
                }
            break;
            case 7:
            {
                dstBufTmp[offset++]=0x06;
                if(PLAN_EVENT_T.ms.msi.size<0x80)
                {
                    dstBufTmp[offset++]=PLAN_EVENT_T.ms.msri.size;
                }
                else
                {
                    dstBufTmp[offset++]=0x82;
                    dstBufTmp[offset++]=PLAN_EVENT_T.ms.msri.size>>8;
                    dstBufTmp[offset++]=PLAN_EVENT_T.ms.msri.size;  
                }
                for(i=0;i<PLAN_EVENT_T.ms.msrt.size;i++)
                {
                    dstBufTmp[offset++]=PLAN_EVENT_T.ms.msri.region[i].nType;
                    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.ms.msri.region[i].start, 2) < 0)
                    {
                        nRet = ERR_NORMAL;
                        return nRet;
                    }
                    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.ms.msri.region[i].end, 2) < 0)
                    {
                        nRet = ERR_NORMAL;
                        return nRet;
                    }
                
                }
            }
        break;
#if AREA_ZHEJIANG
            case 8:
                {
                    dstBufTmp[offset++]=0x08;
                    if(PLAN_EVENT_T.ms.msdt.size<0x80)
                    {
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msdt.size;
                    }
                    else
                    {
                        dstBufTmp[offset++]=0x82;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msdt.size>>8;
                        dstBufTmp[offset++]=PLAN_EVENT_T.ms.msdt.size;
                        
                    }
                    for(i=0;i<PLAN_EVENT_T.ms.msdt.size;i++)
                    {
                        memcpy_r(dstBufTmp+offset,(uint8*)&(PLAN_EVENT_T.ms.msdt.type[i]),2);
                        offset=offset+2;
                    }
                }

            break;
#endif
        }
        //上报标识
        if(basic_data_to_buf(E_BOOL, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.bReport, 1) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        
        //存储深度
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_EVENT_T.nDepth, 2) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }
        *convert->dOffset=offset;
        
        return ERR_OK;
}

/**
*********************************************************************
* @brief：      读取透明方案配置单元
* @param[in]： pOadInfo      - 数据表指针
               srcBuf        - 源数据
               srcLen        - 源数据长度
               dstLen        - 目的数据长度
* @param[out]：dstData       - 目的数据
               pOffset       - 报文偏移   
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/

OOP_DAR_E data_to_buf_transparent_scheme(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)

{

    OOP_DAR_E nRet = DATA_SUCCESS;
    OOP_PLAN_TRANS_T PLAN_TRANS_T;
    uint32 offset=*convert->dOffset;
    uint32 dstLen=convert->dstLen;
    uint8 *dstBufTmp=(uint8*)convert->dstBuf;
    uint8 data0ffset;
    uint32 i,j;

    memset((uint8 *)&PLAN_TRANS_T,0x00,sizeof(OOP_PLAN_TRANS_T));
    memcpy((uint8 *)&PLAN_TRANS_T,convert->srcBuf,convert->srcLen);
    dstBufTmp[offset++]=DT_STRUCTURE;
    dstBufTmp[offset++]=0x03;
    
    //方案编号

    PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.planID is %d,offset is %d\n",PLAN_TRANS_T.planID,offset);
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.planID, 1) < 0)
    {
        nRet = DATA_TYPE_UNMATCHED;
        return nRet;
    }
    
    //方案内容集
    dstBufTmp[offset++]=DT_ARRAY;
    dstBufTmp[offset++]=PLAN_TRANS_T.value.nNum;

    //方案内容
    PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.nNum is %d,offset is %d\n",PLAN_TRANS_T.value.nNum,offset);
    for(i=0;i<PLAN_TRANS_T.value.nNum;i++)
    {
        //序号
        dstBufTmp[offset++]=DT_STRUCTURE;
        dstBufTmp[offset++]=0x06;
        
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].nIndex is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].nIndex,offset);
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].nIndex, 2) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //通信地址
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :offset is %d\n",offset);
        if(basic_data_to_buf(E_TSA, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].addr, sizeof(OOP_TSA_T)) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //开始前脚本id
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].startid is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].startid,offset);
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].startid, 2) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //完成后脚本id
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].endid is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].endid,offset);
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].endid, 2) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //方案控制标志
        dstBufTmp[offset++]=DT_STRUCTURE;
        dstBufTmp[offset++]=0x04;
        //上报透明方案结果并等待后续报文
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].flag.bReport is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].flag.bReport,offset);
        if(basic_data_to_buf(E_BOOL, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].flag.bReport, 1) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //等待后续报文超时时间(秒)
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].flag.nDelay is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].flag.nDelay,offset);
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].flag.nDelay, 2) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //结果比对标识
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].flag.nCompare is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].flag.nCompare,offset);
        if(basic_data_to_buf(E_ENUM, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].flag.nCompare, 1) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //结果比对参数
        dstBufTmp[offset++]=DT_STRUCTURE;
        dstBufTmp[offset++]=0x03;
        //特征字节
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].flag.cmpParm.flag is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].flag.cmpParm.flag,offset);
        if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].flag.cmpParm.flag, 1) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //截取开始
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].flag.cmpParm.start is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].flag.cmpParm.start,offset);
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].flag.cmpParm.start, 2) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //截取长度
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].flag.cmpParm.len is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].flag.cmpParm.len,offset);
        if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].flag.cmpParm.len, 2) < 0)
        {
            nRet = DATA_TYPE_UNMATCHED;
            return nRet;
        }
        //方案报文集
        dstBufTmp[offset++]=DT_ARRAY;
        dstBufTmp[offset++]=PLAN_TRANS_T.value.info[i].cmd.nNum;
        PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].cmd.nNum is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].cmd.nNum,offset);
        for(j=0;j<PLAN_TRANS_T.value.info[i].cmd.nNum;j++)
        {
            dstBufTmp[offset++]=DT_STRUCTURE;
            dstBufTmp[offset++]=0x02;
            PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex is %d,offset is %d\n",PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex,offset);
            if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.value.info[i].cmd.value[j].nIndex,1) < 0)
            {
                nRet = DATA_TYPE_UNMATCHED;
                return nRet;
            }
            dstBufTmp[offset++]=DT_OCTET_STRING;
            
            data0ffset=set_len_offset(PLAN_TRANS_T.value.info[i].cmd.value[j].data.nNum, dstBufTmp+offset);
            offset=offset+data0ffset;
            memcpy(dstBufTmp+offset,PLAN_TRANS_T.value.info[i].cmd.value[j].data.value,PLAN_TRANS_T.value.info[i].cmd.value[j].data.nNum);
            offset =offset+PLAN_TRANS_T.value.info[i].cmd.value[j].data.nNum;
        }

    }
    
    //存储深度
    PRTL_FMT_LOGCC("data_to_buf_transparent_scheme :PLAN_TRANS_T.nSaveCount is %d,offset is %d\n",PLAN_TRANS_T.nSaveCount,offset);
    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, (uint32)(dstLen-offset), &offset, &PLAN_TRANS_T.nSaveCount, 2) < 0)
    {
        nRet = DATA_TYPE_UNMATCHED;
        return nRet;
    }
    

    *convert->dOffset=offset;
    return DATA_SUCCESS;
}

#endif



#if DESC("安全模式相关函数接口", 1)

/**
*********************************************************************
* @brief：      事件记录号
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_event_record_no(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint32 data = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //事件记录号
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),nDepth(%d)\n", dar, data);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      钱包文件
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_wallet(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DWORD2_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;

    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nValue1, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),nValue1(%d)\n", dar, data.nValue1);
        return DATA_TYPE_UNMATCHED;
    }  

    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nValue2, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),nValue2(%d)\n", dar, data.nValue2);
        return DATA_TYPE_UNMATCHED;
    }
        
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      安全模式选择
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DATETIME_S_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //时间转换
    dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(%d)\n", i, dar, data);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      0x47010200订单状态数据转换
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_pile_work_status(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PILE_WORK_STATUS_T workstatus;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&workstatus, sizeof(workstatus)); 

    memcpy(&workstatus, &srcBuf[sOffset], sizeof(workstatus));
    sOffset += sizeof(workstatus);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;
    //结构成员数
    dstBuf[dOffset++] = 0x0D;
    //充电申请单号
    dstBuf[dOffset++] = DT_OCTET_STRING;
    dstBuf[dOffset++] = workstatus.item[0].applicationNumber_len;
    memcpy((uint8*)&dstBuf[dOffset],workstatus.item[0].applicationNumber,workstatus.item[0].applicationNumber_len);
    dOffset =dOffset + workstatus.item[0].applicationNumber_len;
    //用户ID
    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    dstBuf[dOffset++] = workstatus.item[0].userid_len;
    memcpy((uint8*)&dstBuf[dOffset],workstatus.item[0].userid,workstatus.item[0].userid_len);
    dOffset =dOffset + workstatus.item[0].userid_len;
    //路由器资产编号
    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    dstBuf[dOffset++] = workstatus.item[0].routingAssets_len;
    memcpy((uint8*)&dstBuf[dOffset],workstatus.item[0].routingAssets,workstatus.item[0].routingAssets_len);
    dOffset =dOffset + workstatus.item[0].routingAssets_len;
    //执行状态
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &workstatus.item[0].actionState, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("执行状态\n");
        return DATA_TYPE_UNMATCHED;
    }
    //电能示值底值
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = workstatus.item[0].bottomEn.nNum;
    for(i=0;i<workstatus.item[0].bottomEn.nNum;i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &workstatus.item[0].bottomEn.nValue[i], sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("电能示值底值\n");
            return DATA_TYPE_UNMATCHED;
        }
    }
    //当前电能示值
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = workstatus.item[0].currentEn.nNum;
    for(i=0;i<workstatus.item[0].currentEn.nNum;i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &workstatus.item[0].currentEn.nValue[i], sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("当前电能示值\n");
            return DATA_TYPE_UNMATCHED;
        }
    }
     //已充电量
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = workstatus.item[0].quantityEn.nNum;
    for(i=0;i<workstatus.item[0].quantityEn.nNum;i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &workstatus.item[0].quantityEn.nValue[i], sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("已充电量\n");
            return DATA_TYPE_UNMATCHED;
        }
    }
    //已充电时间
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &workstatus.item[0].haveChargedTime, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("已充电时间\n");
        return DATA_TYPE_UNMATCHED;
    }
    //计划充电功率
    dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &workstatus.item[0].planChargePower, sizeof(int32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("计划充电功率\n");
        return DATA_TYPE_UNMATCHED;
    }
     //当前充电功率
    dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &workstatus.item[0].curChargePower, sizeof(int32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("当前充电功率\n");
        return DATA_TYPE_UNMATCHED;
    }
    //电压
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = workstatus.item[0].volt.nNum;
    for(i=0;i<workstatus.item[0].volt.nNum;i++)
    {
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &workstatus.item[0].volt.nValue[i], sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
           
            return DATA_TYPE_UNMATCHED;
        }
    }
    //电流
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = workstatus.item[0].curr.nNum;
    for(i=0;i<workstatus.item[0].curr.nNum;i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &workstatus.item[0].curr.nValue[i], sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
           
            return DATA_TYPE_UNMATCHED;
        }
    }
    //充电桩状态
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &workstatus.item[0].pileState, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        
        return DATA_TYPE_UNMATCHED;
    }
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      0x47010200订单状态数据转换
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_power_characteristic_record(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_Power_Characteristic_Record powerrecord = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&powerrecord, sizeof(powerrecord)); 

    memcpy(&powerrecord, &srcBuf[sOffset], sizeof(powerrecord));
    sOffset += sizeof(powerrecord);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;
    //结构成员数
    dstBuf[dOffset++] = 0x02;

    //设备类型
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &powerrecord.devtype, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("设备类型\n");
        return DATA_TYPE_UNMATCHED;
    }
    //功率特征记录单元组
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = powerrecord.num;
    for(i=0;i<powerrecord.num;i++)
    {
        dstBuf[dOffset++] = DT_STRUCTURE;
        dstBuf[dOffset++] = 0x05;
        
        dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &powerrecord.powerunit[i].phase, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("相位信息\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &powerrecord.powerunit[i].type, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("负荷类型\n");
            return DATA_TYPE_UNMATCHED;
        }
                dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &powerrecord.powerunit[i].power, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("功率差值\n");
            return DATA_TYPE_UNMATCHED;
        }
                dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &powerrecord.powerunit[i].startminute, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("开始分钟数\n");
            return DATA_TYPE_UNMATCHED;
        }
                dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &powerrecord.powerunit[i].startsecond, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("开始秒数\n");
            return DATA_TYPE_UNMATCHED;
        }
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

OOP_DAR_E data_to_buf_limit_softrec(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SOFTREC_LIST data = {0};
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    //uint32 i =0;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_ARRAY;
    //结构成员数
    dstBuf[dOffset++] = 0x01;

    dstBuf[dOffset++] = DT_STRUCTURE;
    dstBuf[dOffset++] = 0x06;

    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    dstBuf[dOffset++] = 0x02;
    memcpy((uint8*)&dstBuf[dOffset],&data.info[0].type,2);
    dOffset =dOffset + 2;

    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    dstBuf[dOffset++] = 0x04;
    memcpy((uint8*)&dstBuf[dOffset],&data.info[0].factory,4);
    dOffset =dOffset + 4;

    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.info[0].softType , sizeof(data.info[0].softType));
    if(dar != DATA_SUCCESS)
    {
        return DATA_TYPE_UNMATCHED;
    }

    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    dstBuf[dOffset++] = 0x08;
    memcpy((uint8*)&dstBuf[dOffset],&data.info[0].date,8);
    dOffset =dOffset + 8;

    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.info[0].seq , sizeof(data.info[0].seq));
    if(dar != DATA_SUCCESS)
    {
        return DATA_TYPE_UNMATCHED;
    }

    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    dstBuf[dOffset++] = 0x10;
    memcpy((uint8*)&dstBuf[dOffset],&data.info[0].no,16);
    dOffset =dOffset + 16;
    
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


OOP_DAR_E data_to_buf_limit_stepprice(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_STEPPRICE_T data = {0};
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    uint32 i =0;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;
    //结构成员数
    dstBuf[dOffset++] = 0x03;

    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = data.nNum1;
    for( i =0; i < data.nNum1; i++)
    { 
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.sValue[i] , sizeof(data.sValue[i]));
        if(dar != DATA_SUCCESS)
        {
    
            return DATA_TYPE_UNMATCHED;
        }
    }

    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = data.nNum2;
    for( i =0; i < data.nNum1; i++)
    { 
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.sPrice[i] , sizeof(data.sPrice[i]));
        if(dar != DATA_SUCCESS)
        {
    
            return DATA_TYPE_UNMATCHED;
        }
    }

    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = data.nNum3;
    for( i =0; i < data.nNum1; i++)
    { 
        dstBuf[dOffset++] = DT_STRUCTURE;
        dstBuf[dOffset++] = 0x03;
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.yAccDay[i].mon , sizeof(data.yAccDay[i].mon));
        if(dar != DATA_SUCCESS)
        {
    
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.yAccDay[i].day , sizeof(data.yAccDay[i].day));
        if(dar != DATA_SUCCESS)
        {
    
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.yAccDay[i].hour , sizeof(data.yAccDay[i].hour));
        if(dar != DATA_SUCCESS)
        {
    
            return DATA_TYPE_UNMATCHED;
        }
    }
    
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      0x47010200订单状态数据转换
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_limit_charge(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_LIMITCHARGE_T data = {0};
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    if (pOadInfo->nIndex == 0)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;
        //结构成员数
        dstBuf[dOffset++] = 0x02;

        //
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.charge1 , sizeof(data.charge1));
        if(dar != DATA_SUCCESS)
        {

            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.charge2, sizeof(data.charge2));
        if(dar != DATA_SUCCESS)
        {

            return DATA_TYPE_UNMATCHED;
        }
    }
    else
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.charge2, sizeof(data.charge2));
        if(dar != DATA_SUCCESS)
        {

            return DATA_TYPE_UNMATCHED;
        }
    }
    

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

OOP_DAR_E data_to_buf_other_limit(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_OTHERLIMIT_T data = {0};
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;
    //结构成员数
    dstBuf[dOffset++] = 0x03;

    //
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.overChar , sizeof(data.overChar));
    if(dar != DATA_SUCCESS)
    {

        return DATA_TYPE_UNMATCHED;
    }
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.cornorChar, sizeof(data.cornorChar));
    if(dar != DATA_SUCCESS)
    {

        return DATA_TYPE_UNMATCHED;
    }
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.switchChar, sizeof(data.switchChar));
    if(dar != DATA_SUCCESS)
    {

        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      0x47010200订单状态数据转换
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_energy_characteristic_record(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_Energy_Characteristic_Record_Unit energyrecord = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&energyrecord, sizeof(energyrecord)); 

    memcpy(&energyrecord, &srcBuf[sOffset], sizeof(energyrecord));
    sOffset += sizeof(energyrecord);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;
    //结构成员数
    dstBuf[dOffset++] = 0x03;

    //设备类型
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &energyrecord.devtype, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("设备类型\n");
        return DATA_TYPE_UNMATCHED;
    }
    //功率特征记录单元组
    dstBuf[dOffset++] = DT_ARRAY;
    dstBuf[dOffset++] = energyrecord.vlotage.num;
    for(i=0;i<energyrecord.vlotage.num;i++)
    {
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &energyrecord.vlotage.voltageuint[i], sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("相位信息\n");
            return DATA_TYPE_UNMATCHED;
        }
    }
    for(i=0;i<energyrecord.energyuint.num;i++)
    {
        dstBuf[dOffset++] = DT_STRUCTURE;
        dstBuf[dOffset++] = 0x07;
        
        dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].phase, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("相位信息\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].energy, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("5分钟电量\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].activepower, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("有功\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].reactivepower, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("无功\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].current, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("总电流\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].currentoddhaimonic, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("电流奇次谐波有效值\n");
            return DATA_TYPE_UNMATCHED;
        }
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &energyrecord.energyuint.energyuint[i].currentevenhaimonic, sizeof(int32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("电流偶次谐波有效值\n");
            return DATA_TYPE_UNMATCHED;
        }
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      0x47020400充电状态数据转换
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_charge_service(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CHARGE_SERVICE_T chargeServ;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&chargeServ, sizeof(chargeServ)); 

    memcpy(&chargeServ, &srcBuf[sOffset], sizeof(chargeServ));
    sOffset += sizeof(chargeServ);

    //unsigned类型
    dstBuf[dOffset++] = DT_UNSIGNED;
    //状态
    dstBuf[dOffset++] = chargeServ.item[0].gunState;
    
    //避免越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      校时模式
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_timing_mod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //模式选择
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(%d)\n", i, dar, data);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      升级结果
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_update_result(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //升级结果
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(%d)\n", i, dar, data);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

OOP_DAR_E data_to_buf_class8_time_board(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_BROADCASTCLOCK_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;
            
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nMinDeviate, sizeof(data.nMinDeviate));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nMinDeviate(%d)\n", i, dar, data.nMinDeviate);
        return DATA_TYPE_UNMATCHED;
    }
    
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nMaxDeviate, sizeof(data.nMaxDeviate));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nMaxDeviate(%d)\n", i, dar, data.nMaxDeviate);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      精确对时
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_time_precise(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYNCCLOCK_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 5;
            
    //最近心跳时间总个数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nSum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nSum(%d)\n", i, dar, data.nSum);
        return DATA_TYPE_UNMATCHED;
    }
    
    //最大值剔除个数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nMaxDelNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nMaxDelNum(0x%08x)\n", i, dar, data.nMaxDelNum);
        return DATA_TYPE_UNMATCHED;
    }

    //最小值剔除个数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nMinDelNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nMinDelNum(%d)\n", i, dar, data.nMinDelNum);
        return DATA_TYPE_UNMATCHED;
    }        

    //通讯延时阈值
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nDelay, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nDelay(%d)\n", i, dar, data.nDelay);
        return DATA_TYPE_UNMATCHED;
    } 

    //最少有效个数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nValidNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nValidNum(%d)\n", i, dar, data.nValidNum);
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      卫星对时
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_sysnc_cycle(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYNCCYCLE_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;
            
    //北向同步周期
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.norperiod, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.norperiod(%d)\n", i, dar, data.norperiod);
        return DATA_TYPE_UNMATCHED;
    }
    
    //南向同步周期
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.souperiod, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.souperiod(0x%08x)\n", i, dar, data.souperiod);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, 
                        dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      异常电表信息
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_addr_octet(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_OCTETVAR16_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //时间转换
    dar = basic_data_to_buf(E_OOP_OCTETVAR16_T, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      终端地址
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_common(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_OCTETVAR16_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);


    dar = basic_data_to_buf(pOadInfo->pTab->eData, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      设备地理坐标，子结构体拼装报文
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 data_to_buf_position(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    int32 nRet = ERR_NORMAL;
    uint32  offset = *pOffset;
    POSITION_ data = {0};
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;
    
    //结构成员数
    dstBufTmp[offset++] = 4;
       
    //方位
    if(basic_data_to_buf(E_ENUM, dstBufTmp, dstLen-offset, &offset, &data.position, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }

    //度
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.degre, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }        
    
    //分
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.branch, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }   

    //秒
    if(basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.second, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }   

    *pOffset = offset;
     
    return ERR_OK;
}


OOP_DAR_E data_to_buf_log_info(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_LOG_INFO_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);
    
    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 7;
    //日志文件名称及路径
    dar = basic_data_to_buf(E_OOP_VISIBLEVAR_T, dstBuf, dstLen, &dOffset, &data.logpathname, sizeof(OOP_VISIBLEVAR_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
    //日志文件大小
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.logsize, sizeof(OOP_VISIBLEVAR_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }
//    //md5 值
//    dstBuf[dOffset++] = DT_OCTET_STRING;
//    if(data.logmd5.nNum!=0)
//    {
//        dstBuf[dOffset++] = data.logmd5.nNum;
//        memcpy(&dstBuf[dOffset],data.logmd5.value,data.logmd5.nNum);
//        dOffset+=data.logmd5.nNum;
//    }
//    else
//    {
//        dstBuf[dOffset++] = data.logmd5.nNum;
//    }
    
    if(data.logcheck.choice == DT_CHECKSUM)
    {
        dstBuf[dOffset++] = DT_CHECKSUM;
        
        if(data.logcheck.checksum.checkcode.nNum != 0)
        {
            dstBuf[dOffset++] = data.logcheck.checksum.checktype;
            dstBuf[dOffset++] = data.logcheck.checksum.checkcode.nNum;
            memcpy(&dstBuf[dOffset],data.logcheck.checksum.checkcode.value,data.logcheck.checksum.checkcode.nNum);
            dOffset+=data.logcheck.checksum.checkcode.nNum;
        }
        else
        {
            dstBuf[dOffset++] = data.logcheck.checksum.checktype;
            dstBuf[dOffset++] = data.logcheck.checksum.checkcode.nNum;
        }
    }
    else
    {
        dstBuf[dOffset++] = DT_OCTET_STRING;
        
        if(data.logcheck.md5.nNum != 0)
        {
            dstBuf[dOffset++] = data.logcheck.md5.nNum;
            memcpy(&dstBuf[dOffset],data.logcheck.md5.value,data.logcheck.md5.nNum);
            dOffset+=data.logcheck.md5.nNum;
        }
        else
        {
            dstBuf[dOffset++] = data.logcheck.md5.nNum;
        }
    }

    //容器创建时间
    dstBuf[dOffset++] = DT_DATETIME_S;
    memcpy_r(&dstBuf[dOffset],&data.creattime.year,sizeof(uint16));
    dOffset+= sizeof(uint16);
    dstBuf[dOffset++] = data.creattime.month;
    dstBuf[dOffset++] = data.creattime.day;
    dstBuf[dOffset++] = data.creattime.hour;
    dstBuf[dOffset++] = data.creattime.minute;
    dstBuf[dOffset++] = data.creattime.second;
    //日志类型    enum
    dstBuf[dOffset++] = DT_ENUM;
    dstBuf[dOffset++] = data.logtype;
    //容器名称 		visible-string，
    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    if(data.conname.nNum!=0)
    {
        dstBuf[dOffset++] = data.conname.nNum;
        memcpy(&dstBuf[dOffset],data.conname.value,data.conname.nNum);
        dOffset+=data.conname.nNum;
    }
    else
    {
        dstBuf[dOffset++] = data.conname.nNum;
    }
    dstBuf[dOffset++] = DT_VISIBLE_STRING;
    if(data.appname.nNum!=0)
    {
        dstBuf[dOffset++] = data.appname.nNum;
        memcpy(&dstBuf[dOffset],data.appname.value,data.appname.nNum);
        dOffset+=data.appname.nNum;
    }
    else
    {
        dstBuf[dOffset++] = data.appname.nNum;
    }
    //应用名称 		visible-string
   // PRTL_FMT_DEBUG("date_time_s yy %d MM %d dd %d hh %d mm%d ss %d \n",data.creattime.year,data.creattime.month,data.creattime.day,data.creattime.hour,data.creattime.minute,data.creattime.second);
 /*   dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data.creattime, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }*/

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar; 
}


/**
*********************************************************************
* @brief：      设备地理坐标，子结构体拼装报文
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 data_to_buf_position_new(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData
, uint32 srcLen)
{
    int32 nRet = ERR_NORMAL;
    uint32  offset = *pOffset;
    POSITION_NEW data = {0};
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;
    
    //结构成员数
    dstBufTmp[offset++] = 3;
       
    //方位
    if(basic_data_to_buf(E_ENUM, dstBufTmp, dstLen-offset, &offset, &data.position, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }

    //度
    if(basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.degre, sizeof(uint16)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }        
    
    //分
    if(basic_data_to_buf(E_FLOAT32, dstBufTmp, dstLen-offset, &offset, &data.branch, sizeof(float)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }     

    *pOffset = offset;
     
    return ERR_OK;
}

/**
*********************************************************************
* @brief：      终端地理坐标
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_coordinates(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_GEOGADD_A_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 3;

    if(1 == data.type)
    {
        //经度
        dar = data_to_buf_position_new(pOadInfo, dstBuf, dstLen, &dOffset, &data.newaddr.longitude, sizeof(POSITION_NEW));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }

        dar = data_to_buf_position_new(pOadInfo, dstBuf, dstLen, &dOffset, &data.newaddr.latitude, sizeof(POSITION_NEW));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }
        
        //高度
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &data.newaddr.height, sizeof(int));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.height(%d)\n", i, dar, data.newaddr.height);
            return DATA_TYPE_UNMATCHED;
        }
    }
    else
    {
        //经度
        dar = data_to_buf_position(pOadInfo, dstBuf, dstLen, &dOffset, &data.oldaddr.longitude, sizeof(POSITION_));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }
        
        //纬度
        dar = data_to_buf_position(pOadInfo, dstBuf, dstLen, &dOffset, &data.oldaddr.latitude, sizeof(POSITION_));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }

        //高度
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.oldaddr.height, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.height(%d)\n", i, dar, data.oldaddr.height);
            return DATA_TYPE_UNMATCHED;
        }        
    }
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      终端地理坐标
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
//OOP_DAR_E data_to_buf_class8_abnormal_meter_info(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
//{
//    OOP_DAR_E dar = DATA_SUCCESS;
//    uint32  sOffset = *convert->sOffset;
//    uint32  dOffset = *convert->dOffset;
//    ABNORMAL_METER_INFO_T data;
//    uint8 i = 0;
//    uint8 *srcBuf = (uint8*)convert->srcBuf;
//    uint32 srcLen = convert->srcLen;
//    uint8 *dstBuf = (uint8*)convert->dstBuf;
//    uint32 dstLen = convert->dstLen;
//
//    MEMZERO(&data, sizeof(data)); 
//
//    memcpy(&data, &srcBuf[sOffset], sizeof(data));
//    sOffset += sizeof(data);
//
//    //结构类型
//    dstBuf[dOffset++] = DT_STRUCTURE;
//    //成员数量
//    dstBuf[dOffset++] = 5;
//    
//    //序号
//    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.numer, sizeof(uint16));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),&data.numer(%d)\n", i, dar,&data.numer);
//        return DATA_TYPE_UNMATCHED;
//    }
//    
//    //电表地址
//    dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.addr, sizeof(OOP_TSA_T));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
//        return DATA_TYPE_UNMATCHED;
//    }
//
//    //事件类型
//    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.eventtype, sizeof(uint8));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
//        return DATA_TYPE_UNMATCHED;
//    }
//
//    //电表规约
//    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.prtl, sizeof(uint8));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
//        return DATA_TYPE_UNMATCHED;
//    }
//    
//    //结构类型
//    dstBuf[dOffset++] = DT_STRUCTURE;
//    //结构成员数
//    dstBuf[dOffset++] = 3;
//            
//    //经度
//    dar = data_to_buf_position(pOadInfo, dstBuf, dstLen, &dOffset, &data.geogadd.longitude, sizeof(POSITION_));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.longitude(%d)\n", i, dar, data.geogadd.longitude);
//        return DATA_TYPE_UNMATCHED;
//    }
//    
//    //纬度
//    dar = data_to_buf_position(pOadInfo, dstBuf, dstLen, &dOffset, &data.geogadd.latitude, sizeof(POSITION_));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.latitude(0x%08x)\n", i, dar, data.geogadd.latitude);
//        return DATA_TYPE_UNMATCHED;
//    }
//
//    //高度
//    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.geogadd.height, sizeof(uint32));
//    if(dar != DATA_SUCCESS)
//    {
//        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.height(%d)\n", i, dar, data.geogadd.height);
//        return DATA_TYPE_UNMATCHED;
//    }        
//
//    //避免每步都判断，放最后检查，但检查前可能已经越界
//    if((sOffset > srcLen) || (dOffset > dstLen))
//    {
//        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
//        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
//    }
//
//    *convert->dOffset = dOffset;
//    *convert->sOffset = sOffset;
//     
//    return dar;
//}

/**
*********************************************************************
* @brief：      终端终端组地址
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_group_addr(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_GRPADDR_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {    
        //地址
        dar = basic_data_to_buf(E_OOP_SA_T, dstBuf, dstLen, &dOffset, &data.sa[i], sizeof(data.sa[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        } 
    }      

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：       时区时段数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_time_region(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PERIOD_T data = {0};
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 5;

    //年时区数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.yPeriod, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.height(%d)\n", dar, data.yPeriod);
        return DATA_TYPE_UNMATCHED;
    }

    //日时段表数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriodMet, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.height(%d)\n", dar, data.dPeriodMet);
        return DATA_TYPE_UNMATCHED;
    }

    //日时段数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.height(%d)\n", dar, data.dPeriodMet);
        return DATA_TYPE_UNMATCHED;
    }

    //费率数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.rate, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.height(%d)\n", dar, data.rate);
        return DATA_TYPE_UNMATCHED;
    }

    //公共假日数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.pubHoliday, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.height(%d)\n", dar, data.rate);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      终端地理坐标
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_clock_src(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CLOCK_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;
            
    //时钟源
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.clock, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.longitude(%d)\n", i, dar, data.clock);
        return DATA_TYPE_UNMATCHED;
    }
    
    //状态
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.state, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.latitude(0x%08x)\n", i, dar, data.state);
        return DATA_TYPE_UNMATCHED;
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      LCD参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_LCD_param(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_LCD_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 7;
            
    //
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.disTime, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.disTime(%d)\n", i, dar, data.disTime);
        return DATA_TYPE_UNMATCHED;
    }
    
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.lightTime, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.lightTime(%d)\n", i, dar, data.lightTime);
        return DATA_TYPE_UNMATCHED;
    } 

    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.reTime, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.lightTime(%d)\n", i, dar, data.reTime);
        return DATA_TYPE_UNMATCHED;
    } 

    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.noPow, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.lightTime(%d)\n", i, dar, data.noPow);
        return DATA_TYPE_UNMATCHED;
    } 

    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.eDotNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.disTime(%d)\n", i, dar, data.eDotNum);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.pDotNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.disTime(%d)\n", i, dar, data.pDotNum);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nFlag, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.disTime(%d)\n", i, dar, data.nFlag);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      当前套时段表
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_time_zone_all(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TIMEZONE_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 3;

        //月
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i].mon, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.period.mon(%d)\n", i, dar, data.period[i].mon);
            return DATA_TYPE_UNMATCHED;
        }

        //日
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i].day, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.period.day(%d)\n", i, dar, data.period[i].day);
            return DATA_TYPE_UNMATCHED;
        }

        //日时段表号
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i].meterNum, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.period.meterNum(%d)\n", i, dar, data.period[i].meterNum);
            return DATA_TYPE_UNMATCHED;
        }
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      当前套时段表
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_time_zone_one(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TIMEZONE_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    if ((pOadInfo->nIndex > OOP_MAX_TIMEZONE) || (pOadInfo->nIndex == 0))
    {
        return ERR_NORMAL;
    }

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 3;

    i = pOadInfo->nIndex - 1;

    //月
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i].mon, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.period.mon(%d)\n", i, dar, data.period[i].mon);
        return DATA_TYPE_UNMATCHED;
    }

    //日
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i].day, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.period.day(%d)\n", i, dar, data.period[i].day);
        return DATA_TYPE_UNMATCHED;
    }

    //日时段表号
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i].meterNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.period.meterNum(%d)\n", i, dar, data.period[i].meterNum);
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      当前套时段表
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_time_zone(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    if (pOadInfo->nIndex == 0)
    {
        return data_to_buf_class8_time_zone_all(pOadInfo, convert);
    }
    else
    {
        return data_to_buf_class8_time_zone_one(pOadInfo, convert);
    }
}
/**
*********************************************************************
* @brief：      当前套时段表
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_pub_holiday(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PUBHOLIDAY_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 2;


        dar = basic_data_to_buf(E_DATE, dstBuf, dstLen, &dOffset, &data.holiday[i].date, sizeof(data.holiday[i].date));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }

        //日
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.holiday[i].meterNum, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }


    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}
/**
*********************************************************************
* @brief：      当前套时段表
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_pay_day(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PAYDAYS_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 2;


        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.cols[i].day, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }

        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.cols[i].hour, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }


    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      显式安全模式参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_day_period_all(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DAYPERIOD_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //数组类型
        dstBuf[dOffset++] = DT_ARRAY;

        //数组成员个数
        offlen = set_len_offset(data.dPeriod[i].nNum, lenBuf);
        memcpy(&dstBuf[dOffset], lenBuf, offlen);
        dOffset += offlen;

        for(j = 0; j < data.dPeriod[i].nNum; j++)
        {
            //结构类型
            dstBuf[dOffset++] = DT_STRUCTURE;

            //结构成员数
            dstBuf[dOffset++] = 3;
            
            //时
            dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod[i].period[j].hour, sizeof(uint8));
            if(dar != DATA_SUCCESS)
            {
                PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.dPeriod[i].period[j].hour(%d)\n", i, dar, data.dPeriod[i].period[j].hour);
                return DATA_TYPE_UNMATCHED;
            }

            //分
            dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod[i].period[j].min, sizeof(uint8));
            if(dar != DATA_SUCCESS)
            {
                PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.dPeriod[i].period[j].min(%d)\n", i, dar, data.dPeriod[i].period[j].min);
                return DATA_TYPE_UNMATCHED;
            }

            //费率号
            dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod[i].period[j].rateNO, sizeof(uint8));
            if(dar != DATA_SUCCESS)
            {
                PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.dPeriod[i].period[j].rateNO(%d)\n", i, dar, data.dPeriod[i].period[j].rateNO);
                return DATA_TYPE_UNMATCHED;
            }
        }      
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      显式安全模式参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_day_period_one(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DAYPERIOD_T data = {0};
    //uint8 offlen = 0;      //数组数量长度
    //uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    if ((pOadInfo->nIndex > OOP_MAX_DAYPERIODS) || (pOadInfo->nIndex == 0))
    {
        return ERR_NORMAL;
    }

    i = pOadInfo->nIndex - 1;

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    dstBuf[dOffset++] = data.dPeriod[i].nNum;

    for(j = 0; j < data.dPeriod[i].nNum; j++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 3;
        
        //时
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod[i].period[j].hour, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.dPeriod[i].period[j].hour(%d)\n", i, dar, data.dPeriod[i].period[j].hour);
            return DATA_TYPE_UNMATCHED;
        }

        //分
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod[i].period[j].min, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.dPeriod[i].period[j].min(%d)\n", i, dar, data.dPeriod[i].period[j].min);
            return DATA_TYPE_UNMATCHED;
        }

        //费率号
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.dPeriod[i].period[j].rateNO, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.dPeriod[i].period[j].rateNO(%d)\n", i, dar, data.dPeriod[i].period[j].rateNO);
            return DATA_TYPE_UNMATCHED;
        }
    }          

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      显式安全模式参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_day_period(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    if (pOadInfo->nIndex == 0)
    {
        return data_to_buf_class8_day_period_all(pOadInfo, convert);
    }
    else
    {
        return data_to_buf_class8_day_period_one(pOadInfo, convert);
    }
}

/**
*********************************************************************
* @brief：      当前套费率电价
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_rate_tariff(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_RATETARIFF_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    { 
        //时
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.nValue[i], sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nValue(%d)\n", i, dar, data.nValue[i]);
            return DATA_TYPE_UNMATCHED;
        }     
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      剔除功能
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_reject_from_group(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //是否剔除
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.nValue(%d)\n", i, dar, data);
        return DATA_TYPE_UNMATCHED;
    }           

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      电压合格率
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_volt_rate(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VOLTPARAM_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 4;
            
    //电压考核上限
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.uupVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.longitude(%d)\n", i, dar, data.uupVolt);
        return DATA_TYPE_UNMATCHED;
    }
    
    //电压考核下限
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.lldVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.latitude(0x%08x)\n", i, dar, data.lldVolt);
        return DATA_TYPE_UNMATCHED;
    }

    //电压合格上限
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.upVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.height(%d)\n", i, dar, data.upVolt);
        return DATA_TYPE_UNMATCHED;
    }        

    //电压合格下限
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.ldVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.height(%d)\n", i, dar, data.ldVolt);
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      TA模块信息
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_tamod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TASPCUSEMOD_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 11;
            
    //模块ID
    dar = basic_data_to_buf(E_OCTET_STR8_T, dstBuf, dstLen, &dOffset, &data.modID, sizeof(OOP_OCTETSTR8_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.modID(%d)\n", dar, data.modID);
        return DATA_TYPE_UNMATCHED;
    }
    
    //厂商代码
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, dstLen, &dOffset, &data.manufcode, sizeof(OOP_VISIBLESTR4_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.manufcode(%d)\n", dar, data.manufcode);
        return DATA_TYPE_UNMATCHED;
    }

    //设备编号
    dar = basic_data_to_buf(E_OOP_VISIBLESTR8_T, dstBuf, dstLen, &dOffset, &data.devcode, sizeof(OOP_VISIBLESTR8_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.devcode(%d)\n", dar, data.devcode);
        return DATA_TYPE_UNMATCHED;
    }        

    //运行区软件版本号
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, dstLen, &dOffset, &data.runsoftver, sizeof(OOP_VISIBLESTR4_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.runsoftver(%d)\n", dar, data.runsoftver);
        return DATA_TYPE_UNMATCHED;
    } 

    //运行区软件发布日期
    dar = basic_data_to_buf(E_DATE, dstBuf, dstLen, &dOffset, &data.runsoftdate, sizeof(OOP_DATE_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.runsoftdate(%d)\n", dar, data.runsoftdate);
        return DATA_TYPE_UNMATCHED;
    }     

    //备份区软件版本号
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, dstLen, &dOffset, &data.baksoftver, sizeof(OOP_VISIBLESTR4_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.baksoftver(%d)\n", dar, data.baksoftver);
        return DATA_TYPE_UNMATCHED;
    } 

    //备份区软件发布日期
    dar = basic_data_to_buf(E_DATE, dstBuf, dstLen, &dOffset, &data.baksoftdate, sizeof(OOP_DATE_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.baksoftdate(%d)\n", dar, data.baksoftdate);
        return DATA_TYPE_UNMATCHED;
    }  

    //配置容量信息码
    dar = basic_data_to_buf(E_OOP_VISIBLESTR11_T, dstBuf, dstLen, &dOffset, &data.cfgcapinfo, sizeof(OOP_VISIBLESTR11_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.cfgcapinfo(%d)\n", dar, data.cfgcapinfo);
        return DATA_TYPE_UNMATCHED;
    }        

    //通信协议版本号
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, dstLen, &dOffset, &data.protover, sizeof(OOP_VISIBLESTR4_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.protover(%d)\n", dar, data.protover);
        return DATA_TYPE_UNMATCHED;
    } 

    //软件版本号
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, dstLen, &dOffset, &data.hardver, sizeof(OOP_VISIBLESTR4_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.hardver(%d)\n", dar, data.hardver);
        return DATA_TYPE_UNMATCHED;
    } 

    //硬件发布日期
    dar = basic_data_to_buf(E_DATE, dstBuf, dstLen, &dOffset, &data.harddate, sizeof(OOP_DATE_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data.harddate(%d)\n", dar, data.harddate);
        return DATA_TYPE_UNMATCHED;
    }  

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：       获取阻抗模值
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_impeval(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32 offset = *pOffset;
    OOP_IMPE_VAL_T data = {0};
    uint8 i = 0;    
    uint8 *dstBufTmp = (uint8*)dstBuf;

    memcpy(&data, srcData, sizeof(data));

    //数组类型
    dstBufTmp[offset++] = DT_ARRAY;

    //数组成员数,肯定不会超过128，不需要A-XDR编码
    dstBufTmp[offset++] = data.nNum;

    if(data.nNum > OOP_TA_NUM)
    {
        PRTL_FMT_DEBUG("fatal error. oda(0x%08x), data.nNum(%d) > OOP_TA_NUM(%d)\n", pOadInfo->pTab->oad.value, data.nNum, OOP_TA_NUM);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }

    for(i = 0; i < data.nNum; i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBufTmp, dstLen, &offset, &data.impeval[i], sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.impeval(%d)\n", i, dar, data.impeval[i]);
            return DATA_TYPE_UNMATCHED;
        }
    }

    *pOffset = offset;
     
    return dar;    
}

/**
*********************************************************************
* @brief：       获取阻抗角度
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_impeang(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32 offset = *pOffset;
    OOP_IMPE_ANG_T data = {0};
    uint8 i = 0;    
    uint8 *dstBufTmp = (uint8*)dstBuf;

    memcpy(&data, srcData, sizeof(data));

    //数组类型
    dstBufTmp[offset++] = DT_ARRAY;

    //数组成员数,肯定不会超过128，不需要A-XDR编码
    dstBufTmp[offset++] = data.nNum;

    if(data.nNum > OOP_TA_NUM)
    {
        PRTL_FMT_DEBUG("fatal error. oda(0x%08x), data.nNum(%d) > OOP_TA_NUM(%d)\n", pOadInfo->pTab->oad.value, data.nNum, OOP_TA_NUM);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }

    for(i = 0; i < data.nNum; i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBufTmp, dstLen, &offset, &data.impeang[i], sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.impeang(%d)\n", i, dar, data.impeang[i]);
            return DATA_TYPE_UNMATCHED;
        }
    }

    *pOffset = offset;

    return dar;    
}

/**
*********************************************************************
* @brief：       获取阻抗频率
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_impefreq(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32 offset = *pOffset;
    OOP_IMPE_FREQ_T data = {0};
    uint8 i = 0;    
    uint8 *dstBufTmp = (uint8*)dstBuf;

    memcpy(&data, srcData, sizeof(data));

    //数组类型
    dstBufTmp[offset++] = DT_ARRAY;

    //数组成员数,肯定不会超过128，不需要A-XDR编码
    dstBufTmp[offset++] = data.nNum;

    if(data.nNum > OOP_TA_NUM)
    {
        PRTL_FMT_DEBUG("fatal error. oda(0x%08x), data.nNum(%d) > OOP_TA_NUM(%d)\n", pOadInfo->pTab->oad.value, data.nNum, OOP_TA_NUM);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }

    for(i = 0; i < data.nNum; i++)
    {
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBufTmp, dstLen, &offset, &data.impefreq[i], sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.impefreq(%d)\n", i, dar, data.impefreq[i]);
            return DATA_TYPE_UNMATCHED;
        }
    }

    *pOffset = offset;

    return dar;    
}


/**
*********************************************************************
* @brief：      TA模块工况信息
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_workstatus(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_WORKINFO_T data;
    uint8 i = 0;    
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员数
    dstBuf[dOffset++] = data.nNum;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 8;
                
        //电流回路状态
        dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.item[i].curloopstat, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.loopState(%d)\n", i, dar, data.item[i].curloopstat);
            return DATA_TYPE_UNMATCHED;
        }
        
        //温度
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.item[i].temp, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.workTemp(%d)\n", i, dar, data.item[i].temp);
            return DATA_TYPE_UNMATCHED;
        }

        //频率最大值
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.item[i].maxfreq, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.freqMax(%d)\n", i, dar, data.item[i].maxfreq);
            return DATA_TYPE_UNMATCHED;
        }        

        //频率最小值
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.item[i].minfreq, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.freqMin(%d)\n", i, dar, data.item[i].minfreq);
            return DATA_TYPE_UNMATCHED;
        } 

        //工频电流有效值
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.item[i].curvalid, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.workCurVal(%d)\n", i, dar, data.item[i].curvalid);
            return DATA_TYPE_UNMATCHED;
        } 

        //阻抗模值
        dar = data_to_buf_class8_impeval(pOadInfo, dstBuf, dstLen, &dOffset, &data.item[i].impval, sizeof(OOP_IMPE_VAL_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("data_to_buf_class8_impeval failed. [%d] dar(%d),data.impeVal(%d)\n", i, dar, data.item[i].impval);
            return DATA_TYPE_UNMATCHED;
        } 

        //阻抗角度
        dar = data_to_buf_class8_impeang(pOadInfo, dstBuf, dstLen, &dOffset, &data.item[i].impang, sizeof(OOP_IMPE_ANG_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("data_to_buf_class8_impeang failed. [%d] dar(%d),data.impeAng(%d)\n", i, dar, data.item[i].impang);
            return DATA_TYPE_UNMATCHED;
        } 

        //阻抗频率
        dar = data_to_buf_class8_impefreq(pOadInfo, dstBuf, dstLen, &dOffset, &data.item[i].impfrq, sizeof(OOP_IMPE_FREQ_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("data_to_buf_class8_impefreq failed. [%d] dar(%d),data.impeFreq(%d)\n", i, dar, data.item[i].impfrq);
            return DATA_TYPE_UNMATCHED;
        } 
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }
    
    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      TA模块换算及单位
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_taunit(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TAUNIT_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 5;
            
    //温度单位换算
    dar = basic_data_to_buf(E_SCALER_UNIT, dstBuf, dstLen, &dOffset, &data.unit1, sizeof(OOP_SCALER_UNIT_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.unit1(%d)\n", i, dar, data.unit1.unit);
        return DATA_TYPE_UNMATCHED;
    }

    //频率单位换算
    dar = basic_data_to_buf(E_SCALER_UNIT, dstBuf, dstLen, &dOffset, &data.unit2, sizeof(OOP_SCALER_UNIT_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.unit2(%d)\n", i, dar, data.unit2.unit);
        return DATA_TYPE_UNMATCHED;
    }

    //电流有效值单位换算
    dar = basic_data_to_buf(E_SCALER_UNIT, dstBuf, dstLen, &dOffset, &data.unit3, sizeof(OOP_SCALER_UNIT_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.unit3(%d)\n", i, dar, data.unit3.unit);
        return DATA_TYPE_UNMATCHED;
    }
    
    //阻抗模值单位换算
    dar = basic_data_to_buf(E_SCALER_UNIT, dstBuf, dstLen, &dOffset, &data.unit4, sizeof(OOP_SCALER_UNIT_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.unit4(%d)\n", i, dar, data.unit4.unit);
        return DATA_TYPE_UNMATCHED;
    }

    //阻抗角度单位换算
    dar = basic_data_to_buf(E_SCALER_UNIT, dstBuf, dstLen, &dOffset, &data.unit5, sizeof(OOP_SCALER_UNIT_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.unit5(%d)\n", i, dar, data.unit5.unit);
        return DATA_TYPE_UNMATCHED;
    }    

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      TA模块换算及单位
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_taversion(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CTINFO_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员数
    dstBuf[dOffset++] = data.nNum;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 6;   
        
//        //型号
//        dar = basic_data_to_buf(E_OOP_VISIBLEVAR_T, dstBuf, dstLen, &dOffset, &data.ver[i].szType, sizeof(OOP_VISIBLEVAR_T));
//        if(dar != DATA_SUCCESS)
//        {
//            PRTL_FMT_DEBUG("获取型号[%d] data-->buf dar(%d)\n", i, dar);
//            return DATA_TYPE_UNMATCHED;
//        }

        //设备ID
        dar = basic_data_to_buf(E_OOP_OCTETVAR256_T, dstBuf, dstLen, &dOffset, &data.item[i].id, sizeof(OOP_OCTETVAR256_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("获取型号[%d] data-->buf dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }
        
        /* 软件版本号 */
        dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, convert->dstLen, &dOffset, &data.item[i].szSoftVer, sizeof(OOP_VISIBLESTR4_T));
        if (dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("获取软件版本号[%d] data-->buf dar(%d)\n", i, dar);
            return dar;
        }
        
        /* 软件版本日期 */
        dar = basic_data_to_buf(E_OOP_VISIBLESTR6_T, dstBuf, convert->dstLen, &dOffset, &data.item[i].szSoftDate, sizeof(OOP_VISIBLESTR6_T));
        if (dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("获取软件版本日期[%d] data-->buf dar(%d)\n", i, dar);
            return dar;
        }
        
        /* 硬件版本号 */
        dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, convert->dstLen, &dOffset, &data.item[i].szHardVer, sizeof(OOP_VISIBLESTR4_T));
        if (dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("获取硬件版本号[%d] data-->buf dar(%d)\n", i, dar);
            return dar;
        }
        
        
        /* 硬件版本日期 */
        dar = basic_data_to_buf(E_OOP_VISIBLESTR6_T, dstBuf, convert->dstLen, &dOffset, &data.item[i].szHardDate, sizeof(OOP_VISIBLESTR6_T));
        if (dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("获取硬件版本日期[%d] data-->buf dar(%d)\n", i, dar);
            return dar;
        }

        /* 厂商编码 */
        dar = basic_data_to_buf(E_OOP_VISIBLESTR8_T, dstBuf, convert->dstLen, &dOffset, &data.item[i].szFactory, sizeof(OOP_VISIBLESTR8_T));
        if (dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("获取厂商代码[%d] data-->buf dar(%d)\n", i, dar);
            return dar;
        }
        
//        /* 厂家扩展信息 */
//        dar = basic_data_to_buf(E_OOP_VISIBLESTR8_T, dstBuf, convert->dstLen, &dOffset, &data.ver[i].szExtend, sizeof(OOP_VISIBLESTR8_T));
//        if (dar != DATA_SUCCESS)
//        {
//            PRTL_FMT_DEBUG("获取厂家扩展信息信息[%d] data-->buf dar(%d)\n", i, dar);
//            return dar;
//        }
    }
    
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      TA模块换算及单位
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_curloop_monitor(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CURLOOPCKENABLE_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 3;
            
    //A相使能
    dar = basic_data_to_buf(E_BOOL, dstBuf, dstLen, &dOffset, &data.phaseA, sizeof(BOOLEAN));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.phaseA(%d)\n", i, dar, data.phaseA);
        return DATA_TYPE_UNMATCHED;
    }

    //B相使能
    dar = basic_data_to_buf(E_BOOL, dstBuf, dstLen, &dOffset, &data.phaseB, sizeof(BOOLEAN));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.phaseB(%d)\n", i, dar, data.phaseB);
        return DATA_TYPE_UNMATCHED;
    }

    //C相使能
    dar = basic_data_to_buf(E_BOOL, dstBuf, dstLen, &dOffset, &data.phaseC, sizeof(BOOLEAN));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.phaseC(%d)\n", i, dar, data.phaseC);
        return DATA_TYPE_UNMATCHED;
    }    

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      最大需量周期
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_demand_period(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8  data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //资产编码
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      滑差时间
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_slip_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8  data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //时间
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      终端资产编码
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_asset_no(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLEVAR32_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //资产编码
    dar = basic_data_to_buf(E_OOP_VISIBLEVAR32_T, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      组合特征字
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_combine_word(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_BITSTR8_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //组合特征字
    dar = basic_data_to_buf(E_OOP_BITSTR8_T, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      额定电压
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_rated_volt(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLESTR6_T data = {{0}};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_OOP_VISIBLESTR6_T, dstBuf, dstLen, &dOffset, &data, sizeof(OOP_VISIBLESTR6_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      额定电流
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_rated_curr(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLESTR6_T data = {{0}};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_OOP_VISIBLESTR6_T, dstBuf, dstLen, &dOffset, &data, sizeof(OOP_VISIBLESTR6_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      最大电流
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_max_curr(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLESTR6_T data = {{0}};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_OOP_VISIBLESTR6_T, dstBuf, dstLen, &dOffset, &data, sizeof(OOP_VISIBLESTR6_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(级联参数)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_cascade(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    uint32 i = 0;
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CASCADE_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 8;

    //配置序号
    dar = basic_data_to_buf(E_BOOL, dstBuf, dstLen, &dOffset, &data.flag, sizeof(data.flag));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //级联通信端口号
    dar = basic_data_to_buf(E_OAD, dstBuf, dstLen, &dOffset, &data.port, sizeof(data.port));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //超时
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.tdelay, sizeof(data.tdelay));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //字节超时
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.bdelay, sizeof(data.bdelay));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //重发次数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.retry, sizeof(data.retry));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //巡测周期
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.cycle, sizeof(data.cycle));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //端口数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.casnum, sizeof(data.casnum));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //级联(被)终端地址
    dstBuf[dOffset++] = DT_ARRAY;

    if (data.casnum > OOP_MAX_CASCADE)
    {
        return DATA_TYPE_UNMATCHED;
    }
    dstBuf[dOffset++] = data.casnum;

    for (i = 0; i < data.casnum; i++)
    {
        //端口数
        dar = basic_data_to_buf(E_TSA, dstBuf, dstLen, &dOffset, &data.addr[i], sizeof(data.addr[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. i(%d), dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar; 
}

/**
*********************************************************************
* @brief：      广播校时参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_broadcast_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYNCTIME_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;
            
    //时间
    dar = basic_data_to_buf(E_TIME, dstBuf, dstLen, &dOffset, &data.time, sizeof(data.time));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }
    
    //是否启动
    dar = basic_data_to_buf(E_BOOL, dstBuf, dstLen, &dOffset, &data.bValid, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      广播校时参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_p2p_broadcast_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_P2PSYNCTIME_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 3;

    //时钟误差阈值
    dar = basic_data_to_buf(E_INTEGER, dstBuf, dstLen, &dOffset, &data.offset, sizeof(data.offset));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }

    //时间
    dar = basic_data_to_buf(E_TIME, dstBuf, dstLen, &dOffset, &data.time, sizeof(data.time));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }
    
    //是否启动
    dar = basic_data_to_buf(E_BOOL, dstBuf, dstLen, &dOffset, &data.bValid, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", 0, dar);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      广播校时参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_gprs_apn_res(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_APNGROUP_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint32 i = 0;
    uint32 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 8;
                
        //运营商代码
        dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.net[i].factory, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.net[i].factory(%d)\n", i, dar, data.net[i].factory);
            return DATA_TYPE_UNMATCHED;
        }
        
        //网络类型代码
        dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.net[i].network, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.net[i].network(%d)\n", i, dar, data.net[i].network);
            return DATA_TYPE_UNMATCHED;
        }

        //APN
        dar = basic_data_to_buf(E_OOP_VISIBLEVAR_T, dstBuf, dstLen, &dOffset, &data.net[i].apn.apn, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }     

        //APN用户名
        dar = basic_data_to_buf(E_OOP_VISIBLEVAR_T, dstBuf, dstLen, &dOffset, &data.net[i].apn.username, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        } 

        //APN密码
        dar = basic_data_to_buf(E_OOP_VISIBLEVAR_T, dstBuf, dstLen, &dOffset, &data.net[i].apn.pwd, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
            return DATA_TYPE_UNMATCHED;
        }   

        //代理服务器端口
        dstBuf[dOffset++] = DT_OCTET_STRING;
        dstBuf[dOffset++] = 4;
        memcpy(&dstBuf[dOffset], &data.net[i].apn.proxyip[0], 4);
        dOffset += 4;

        //代理服务器端口
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.net[i].apn.proxyport, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.net[i].apn.proxyport(%d)\n", i, dar, data.net[i].apn.proxyport);
            return DATA_TYPE_UNMATCHED;
        }  

        //数组类型
        dstBuf[dOffset++] = DT_ARRAY;

        //数组成员个数
        offlen = set_len_offset(data.net[i].master.nNum, lenBuf);
        memcpy(&dstBuf[dOffset], lenBuf, offlen);
        dOffset += offlen;

        for (j = 0; j < data.net[i].master.nNum; j++)
        {
            //结构类型
            dstBuf[dOffset++] = DT_STRUCTURE;

            //结构成员数
            dstBuf[dOffset++] = 2;

            //IP
            dstBuf[dOffset++] = DT_OCTET_STRING;
            dstBuf[dOffset++] = 4;
            memcpy(&dstBuf[dOffset], &data.net[i].master.master[j].ip[0], 4);
            dOffset += 4;

            //端口
            dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.net[i].master.master[j].port, sizeof(uint16));
            if(dar != DATA_SUCCESS)
            {
                PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.net[i].master.master[j].port(%d)\n", i, dar, data.net[i].master.master[j].port);
                return DATA_TYPE_UNMATCHED;
            }  
        }

    }   

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      广播校时参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_load_aware(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DEVFREZDATAS_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 6;
                
        //设备类号
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.data[i].devClsID, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.data[i].devClsID(%d)\n", i, dar, data.data[i].devClsID);
            return DATA_TYPE_UNMATCHED;
        }  

        //冻结周期内有功用电量
        dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.data[i].nEnergy, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.data[i].nEnergy(%d)\n", i, dar, data.data[i].nEnergy);
            return DATA_TYPE_UNMATCHED;
        }

        //冻结周期内设备运行平均功率
        dar = basic_data_to_buf(E_DOUBLE_LONG, dstBuf, dstLen, &dOffset, &data.data[i].nPower, sizeof(int));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.data[i].nPower(%d)\n", i, dar, data.data[i].nPower);
            return DATA_TYPE_UNMATCHED;
        }  
//增加了判断是否为NULL，否则主站召测时我们会将NULL变为0
        if(data.data[i].startTime==0xFE)
        {
            dstBuf[dOffset++] = DT_NULL;
        }
        else
        {
        //起动时间
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.data[i].startTime, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.data[i].startTime(%d)\n", i, dar, data.data[i].startTime);
            return DATA_TYPE_UNMATCHED;
        }    
        }
        if(data.data[i].stopTime==0xFE)
        {
            dstBuf[dOffset++] = DT_NULL;
        }
        else
        {
        //停止时间
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.data[i].stopTime, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.data[i].stopTime(%d)\n", i, dar, data.data[i].stopTime);
            return DATA_TYPE_UNMATCHED;
        } 
        }
        if(data.data[i].nCount == 0xFE)
        {
            dstBuf[dOffset++] = DT_NULL;
        }
        else
        {
        //合并启停数
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.data[i].nCount, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.data[i].nCount(%d)\n", i, dar, data.data[i].nCount);
            return DATA_TYPE_UNMATCHED;
        }
        }
        }   

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      安全模式选择
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_security_flag(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SECURITYFLAG_E data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //安全模式选择
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(%d)\n", i, dar, data);
        return DATA_TYPE_UNMATCHED;
    }        

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      显式安全模式参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_security_mod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SCURITYMODE_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 2;
        
        //对象标识
        dar = basic_data_to_buf(E_OI, dstBuf, dstLen, &dOffset, &data.mode[i].object, sizeof(OI));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),OI(0x%04x)\n", i, dar, data.mode[i].object);
            return DATA_TYPE_UNMATCHED;
        }

        //权限
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.mode[i].access, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(0x%04x)\n", i, dar, data.mode[i].access);
            return DATA_TYPE_UNMATCHED;
        }        
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}
  
/**
*********************************************************************
* @brief：      遥控告警配置
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_yk_config(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TELECON_PARAM_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;

    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.limit, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),limit(%d)\n", dar, data.limit);
        return DATA_TYPE_UNMATCHED;
    }  

    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.delay, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),delay(%d)\n", dar, data.delay);
        return DATA_TYPE_UNMATCHED;
    }
        
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      购电控配置单元
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_dk_config(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CFGUNIT_810C_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 8;

    dar = basic_data_to_buf(E_OI, dstBuf, dstLen, &dOffset, &data.object, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),object(%d)\n", dar, data.object);
        return DATA_TYPE_UNMATCHED;
    }  

    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.number, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),delay(%d)\n", dar, data.number);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.flag, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),delay(%d)\n", dar, data.flag);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.type, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),delay(%d)\n", dar, data.flag);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_data_to_buf(E_LONG64, dstBuf, dstLen, &dOffset, &data.purElectricity, sizeof(int64));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),limit(%ll)\n", dar, data.purElectricity);
        return DATA_TYPE_UNMATCHED;
    } 

    dar = basic_data_to_buf(E_LONG64, dstBuf, dstLen, &dOffset, &data.alarmLimit, sizeof(int64));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),limit(%ll)\n", dar, data.alarmLimit);
        return DATA_TYPE_UNMATCHED;
    }  

    dar = basic_data_to_buf(E_LONG64, dstBuf, dstLen, &dOffset, &data.tripLimit, sizeof(int64));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),limit(%ll)\n", dar, data.alarmLimit);
        return DATA_TYPE_UNMATCHED;
    } 

    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.mode, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),delay(%d)\n", dar, data.mode);
        return DATA_TYPE_UNMATCHED;
    }
        
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      遥控告警状态
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_ykalarm_state(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

#ifdef PRODUCT_ZCU_1
    OOP_BITSTR16_T data;
    memcpy_r(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);
    dar = basic_data_to_buf(E_OOP_BITSTR16_T, dstBuf, dstLen, &dOffset, &data.nValue, sizeof(OOP_BITSTR16_T));
#else
    OOP_BITSTR8_T data;
    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);
    dar = basic_data_to_buf(E_OOP_BITSTR8_T, dstBuf, dstLen, &dOffset, &data.nValue, sizeof(OOP_BITSTR8_T));
#endif
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data(0x%x)\n", dar, data.nValue);
        return DATA_TYPE_UNMATCHED;
    }      

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      保电状态
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_guard_state(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data(0x%x)\n", dar, data);
        return DATA_TYPE_UNMATCHED;
    }      

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      保电状态
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_guard_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint16 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data(0x%x)\n", dar, data);
        return DATA_TYPE_UNMATCHED;
    }      

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      广播校时参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_auto_guard_interval(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PRTTIME_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 2;
                
        //起始时间
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.item[i].start, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.item[i].start(%d)\n", i, dar, data.item[i].start);
            return DATA_TYPE_UNMATCHED;
        }
        
        //结束时间
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.item[i].end, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),data.item[i].end(%d)\n", i, dar, data.item[i].end);
            return DATA_TYPE_UNMATCHED;
        }
    }   

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      催费告警状态
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_payment_state(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data(0x%x)\n", dar, data);
        return DATA_TYPE_UNMATCHED;
    }      

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      广播校时参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_payment_para(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CALLFEE_T data;
    OOP_VISIBLEVAR1K_T visibeData;
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    MEMZERO(&data, sizeof(data));
    MEMZERO(&visibeData, sizeof(visibeData));

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    visibeData.nNum = data.nLen;
    memcpy(&visibeData.value[0], &data.info[0], data.nLen);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;
            
    //告警时段
    dar = basic_data_to_buf(E_OCTET_STR3_T, dstBuf, dstLen, &dOffset, &data.period[0], sizeof(data.period));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d), visibeData.nNum(%d)\n", i, dar, visibeData.nNum);
        PRTL_FMT_DEBUG(visibeData.value, visibeData.nNum, "basic_data_to_buf failed. [%d] dar(%d), visibeData.value:");
        return DATA_TYPE_UNMATCHED;
    }
    
    //告警信息
    dar = basic_data_to_buf(E_VISIBLE_STRING, dstBuf, dstLen, &dOffset, &visibeData, sizeof(visibeData));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d), visibeData.nNum(%d)\n", i, dar, visibeData.nNum);
        PRTL_FMT_DEBUG(visibeData.value, visibeData.nNum, "basic_data_to_buf failed. [%d] dar(%d), visibeData.value:");
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      终端保安定值
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_keep_value(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint32 i = 0;
    int64 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);
            
    //告警时段
    dar = basic_data_to_buf(E_LONG64, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d)\n", i, dar);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      显式安全模式参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_powcon_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_POWCON_TIME_T data;
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    MEMZERO(&data, sizeof(data));

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(12, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < 12; i++)
    {    
        //时间
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.period[i], sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),period(0x%04x)\n", i, dar, data.period[i]);
            return DATA_TYPE_UNMATCHED;
        }        
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      显式安全模式参数
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_powcon_warn(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_POWCON_WARNING_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //功控告警时间
        dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.time[i], sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(0x%04x)\n", i, dar, data.time[i]);
            return DATA_TYPE_UNMATCHED;
        }        
    }       

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      电控定值
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset     构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_power_value(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    int64 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //功控告警时间
    dar = basic_data_to_buf(E_DOUBLE_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data, sizeof(int64));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nDepth(0x%04x)\n", i, dar, data);
        return DATA_TYPE_UNMATCHED;
    }            

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      遥控输出状态
* @param[in] ： srcBuf     源数据区，通常是一个变量地址
*               srcLen     源数据长度，通常是变量大小
*               dstLen     目的数据长度，698报文的buffer长度

* @param[out] ：pOffset    构造该数据后的目的数据区偏移
*               dstData    目的数据区，698报文buffer
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_ykcmd_state(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_BITSTR8_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = basic_data_to_buf(E_OOP_BITSTR8_T, dstBuf, dstLen, &dOffset, &data.nValue, sizeof(OOP_BITSTR8_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d),data(0x%x)\n", dar, data.nValue);
        return DATA_TYPE_UNMATCHED;
    }      

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(证书版本)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_inner_factory_code(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar   = DATA_OTHER_REASON;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8  *srcBuf = (uint8 *)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8  *dstBuf  = (uint8 *)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    OOP_VISIBLESTR4_T data;
    MEMZERO(&data, sizeof(data));

    /* 入参检查 */
    if ((pOadInfo == NULL) || (convert->srcBuf == NULL) || (convert->dstBuf == NULL) || (convert->sOffset == NULL))
    {
        PRTL_FMT_DEBUG("data_to_buf_class21 error, ERR_PTR\n");
        return DATA_READ_WRITE_DENIED;
    }

    if(convert->srcLen != sizeof(OOP_VISIBLESTR4_T))
    {
        dar = DATA_OTHER_REASON;
        return dar;
    }
    memcpy((uint8*)&data, &srcBuf[sOffset], convert->srcLen);
    sOffset += sizeof(OOP_VISIBLESTR4_T);

    /* 厂商代码 */
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, convert->dstLen, &dOffset, &data, sizeof(OOP_VISIBLESTR4_T));
    if (dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("获取厂商代码data-->buf err\n");
        return dar;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}
/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(证书版本)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_inner_soft_version(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar   = DATA_OTHER_REASON;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8  *srcBuf = (uint8 *)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8  *dstBuf  = (uint8 *)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    OOP_INNER_SOFT_VERSION_T data;
    MEMZERO(&data, sizeof(data));

    /* 入参检查 */
    if ((pOadInfo == NULL) || (convert->srcBuf == NULL) || (convert->dstBuf == NULL) || (convert->sOffset == NULL))
    {
        PRTL_FMT_DEBUG("data_to_buf_class21 error, ERR_PTR\n");
        return DATA_READ_WRITE_DENIED;
    }

    if(convert->srcLen != sizeof(OOP_INNER_SOFT_VERSION_T))
    {
        dar = DATA_OTHER_REASON;
        return dar;
    }
    memcpy((uint8*)&data, &srcBuf[sOffset], convert->srcLen);
    sOffset += sizeof(OOP_INNER_SOFT_VERSION_T);

    dstBuf[dOffset++] = DT_STRUCTURE;

    /* 结构成员数 */
    dstBuf[dOffset++] = 2;

    /* 软件版本号 */
    dar = basic_data_to_buf(E_OOP_VISIBLESTR4_T, dstBuf, convert->dstLen, &dOffset, &data.szSoftVer, sizeof(OOP_VISIBLESTR4_T));
    if (dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("获取软件版本号data-->buf err\n");
        return dar;
    }

    /* 软件版本日期 */
    dar = basic_data_to_buf(E_OOP_VISIBLESTR6_T, dstBuf, convert->dstLen, &dOffset, &data.szSoftDate, sizeof(OOP_VISIBLESTR6_T));
    if (dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("获取软件版本日期data-->buf err\n");
        return dar;
    }


    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_inner_app_id(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_INNER_APP_ID_LIST_T data;
    uint8 offlen = 0;      //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //数组类型
    dstBuf[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBuf[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBuf[dOffset++] = DT_STRUCTURE;

        //结构成员数
        dstBuf[dOffset++] = 2;
                
        //组件名称
        dar = basic_data_to_buf(E_OOP_VISIBLEVAR_T, dstBuf, dstLen, &dOffset, &data.innerAppID[i].appName, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d),nPeriod(%d)\n", i, dar, data.innerAppID[i].appName);
            return DATA_TYPE_UNMATCHED;
        }

        //APP_ID
        if(basic_data_to_buf(E_OOP_OCTETVAR256_T, dstBuf, dstLen, &dOffset, &data.innerAppID[i].appID, sizeof(OOP_OCTETVAR256_T)) < 0)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }         
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_inner_mac(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_OCTETVAR64_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //MAC
    if (basic_data_to_buf(E_OOP_OCTETVAR64_T, dstBuf, dstLen, &dOffset, &data, sizeof(OOP_OCTETVAR64_T)) < 0)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }         

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     获取读记录任务监控参数
* @param[in]： pRSD          - 行选择
               pCSD          - 列选择
* @param[out]：pPlanTypeInfo - 目的数据
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
int32 read_log_param_get(OOP_PRSD_T *pOopRsd, OOP_RCSD_T *pOopRcsd, APDU_INFO_T *pApduInfo, uint8 *logtype , RELY_INFO_T *pRelyInfo)
{
    int32 nRet = ERR_NORMAL;
    RELY_INFO_T    relyInfo = {0};

    switch (pOopRsd->choice)
    {
    case 1://方法1
    case 2://方法2
        {       
            if(pOopRsd->choice == 1)
            {
                if ((pOopRsd->sel1.value.type == DT_LONG_UNSIGNED)
                    || (pOopRsd->sel1.value.type == DT_UNSIGNED)
                    || (pOopRsd->sel1.value.type == DT_ENUM))
                {
                    *logtype = pOopRsd->sel1.value.bVal;
                   
                }
                else
                {
                    PRTL_FMT_LOGCC("pOopRsd->sel1.value.type != DT_LONG_UNSIGNED\n");
                }
            }
            else
            {
                nRet =  ERR_NORMAL;
            }
            nRet = ERR_OK;
        }
        break;

    default:
        nRet = ERR_NORMAL;
        break;
    }

    if (nRet == ERR_OK)
    {
        relyInfo.oopRcsd = *pOopRcsd;
        relyInfo.bpBreakInfo = pApduInfo->bpBreakInfo;
        *pRelyInfo     = relyInfo;
    }

    return nRet;
}

/**
*********************************************************************
* @name：       frozen_rectable_rec_get
* @brief：      读记录方式获取冻结记录表
* @param[in] ：pOdaInfo        OAD信息
               inData         输入报文
               inLen          输入报文长度
* @return    ：输出报文实际长度
* @author    : 贺宁
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_logInfo_record(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
    {
        uint16 i = 0;
        OOP_DAR_E  nRet = DATA_OTHER_REASON;
        uint32 offset = 4;
        uint16 csdStart = 0, csdLen = 0;
        uint16 outOffset = 0;
        uint16 inDataLenTmp = InDataLen;
        uint32 sOffset = 0;
        uint32 dOffset = 0;
        BP_INFO_T breakInfo;
//        OOP_DAR_E dar = DATA_SUCCESS;
        uint8 lognum = 0;
        DATA_CONVERT_T convert;
        MEMZERO(&convert, sizeof(convert)); 
        OOP_LOG_INFO_T loginfo[OOP_MAX_LOGS];
        uint8 sendbuf[100] = {0};
        int ret;
        uint16 recvlen = 0,count = 0,lognumoffset = 0;;
        uint8 recvbuf[1024] = {0};
        BOOL      isBufFull = FALSE;
        uint32 maxBufLen;
        maxBufLen = pApduInfo->connectionInfo.ApplSplitLen - cal_excludeLen(pApduInfo->connectionInfo);
    
        /* 类型不存在 */
        if (pOadInfo->pTab->oad.nObjID != 0xF400)
        {
            return DATA_OBJECT_UNAVAILABLE;
        }
    
        switch (pOadInfo->pTab->oad.attID)
        {
        case 2:
            {
                OOP_PRSD_T oopRsd;
                OOP_RCSD_T oopRcsd;
                uint16 headLen = 0;
                
                RELY_INFO_T  relyInfo;
                uint8 logtype;
    
                /* 清0处理 */
                MEMZERO(&oopRsd, sizeof(oopRsd));
                MEMZERO(&oopRcsd, sizeof(oopRcsd));
                
                MEMZERO(&relyInfo, sizeof(relyInfo));
    
                /*处理RSD*/
                nRet = apdu_rsd_fromfmt698(inData, inDataLenTmp, &offset, &oopRsd, sizeof(oopRsd));
                PRTL_FMT_LOGCC("oopRsd.choice = %d\n", oopRsd.choice);
                PRTL_FMT_LOGCC("oopRsd.sel1.oad.value = 0x%08x\n", oopRsd.sel1.oad.value);
                PRTL_FMT_LOGCC("oopRsd.sel1.value.wVal = %d\n", oopRsd.sel1.value.wVal);
                PRTL_FMT_LOGCC("offset = %d\n", offset);
                if (nRet != DATA_SUCCESS)
                {
                    PRTL_FMT_TRACE("RSD解析错误\n");
    
                    /*应对电科院协议一致性测试*/
                    uint16 testOffset = 4;
                    uint16 inCsdOff = 0, inCsdLen = 0;
                    apdu_next_dpos_get(inData, &testOffset, InDataLen, DT_RSD, TRUE);
                    inCsdOff = testOffset;
                    apdu_next_dpos_get(inData, &testOffset, InDataLen, DT_RCSD, TRUE);
                    inCsdLen = testOffset - inCsdOff;
                    memcpy(outData->pResultData, inData, 4);
                    memcpy(outData->pResultData + 4, inData + inCsdOff, inCsdLen);
                    outData->resultDataLen = 4 + inCsdLen;
    
                    outData->pResultData[outData->resultDataLen++] = 1;                   //后面优化下，outData->resultDataLen与下面统一
                    if (apdu_rcsd_fromfmt698((uint8 *)inData, InDataLen, &offset, &oopRcsd, sizeof(oopRcsd)) != DATA_SUCCESS)
                    {
                        outData->pResultData[outData->resultDataLen++] = 0;
    
                    }
                    else
                    {
                        outData->pResultData[outData->resultDataLen++] = 1;
                        for (i = 0; i < oopRcsd.nNum; i++)
                        {
                            outData->pResultData[outData->resultDataLen++] = NULL_DATA;
                        }
                    }
    
                    return DATA_SUCCESS;
                }
                else
                {
                    inDataLenTmp -= offset;  //除去RSD和OAD后的长度
                }
    
                /*处理RCSD*/
                csdStart = offset;
                if (apdu_rcsd_fromfmt698(inData, InDataLen, &offset, &oopRcsd, sizeof(oopRcsd)) != DATA_SUCCESS)
                {
                    PRTL_FMT_TRACE("CSD解析错误!\n");
                    return DATA_TYPE_UNMATCHED;
                }
    
                /*填写OAD+RCSD+记录结果1 并记下偏移headLen*/
                outData->resultDataLen = 0;
                csdLen = offset-csdStart;
                memcpy(outData->pResultData, inData, 4);
                outOffset = 4;
    
                if (csdLen == 1)
                {
                    //如果rcsd为空，填充OAD60350200
                    outData->pResultData[outOffset ++] = 0x01;
                    outData->pResultData[outOffset ++] = 0x00;
                    outData->pResultData[outOffset ++] = 0xF4;
                    outData->pResultData[outOffset ++] = 0x07;
                    outData->pResultData[outOffset ++] = 0x02;
                    outData->pResultData[outOffset ++] = 0x00;
                }
                else
                {
                    memcpy(&outData->pResultData[outOffset], &inData[csdStart], csdLen);
                    outOffset += csdLen;
                }
                outData->pResultData[outOffset++] = 1;
                outData->pResultData[outOffset ++] = DT_ARRAY;                         //类型
                lognumoffset = outOffset; 
                outData->resultDataLen += outOffset;
                headLen = outOffset;
    
                PRTL_BUF_DEBUG(&outData->pResultData[0], headLen, "填写OAD+RCSD+记录结果1 并记下偏移headLen head:");
    
                /*记录型档案接口提供输入参数*/
                if (read_log_param_get(&oopRsd, &oopRcsd, pApduInfo, &logtype, &relyInfo) != ERR_OK)
                {
                    return DATA_READ_WRITE_DENIED;
                }
    
                /* 依赖信息中存下OAD列表的指针 */

                memset(&loginfo,0,sizeof(OOP_LOG_INFO_T)*OOP_MAX_LOGS);
                uint8 option = 0;
                sendbuf[0] = 1; //日志类型     [1] LOGTYPE，
                sendbuf[1] = logtype; 
                ret = appmain_send_syncmsg_time(MSG_APPAMIN_LOGINFO_GET,sendbuf,2,recvbuf,sizeof(recvbuf),&recvlen, 60);
                if(ret!=ERR_OK)
                {
                    PRTL_FMT_DEBUG("获取全部日志信息失败 ret %d\n",ret);
                    return 0;
                }
                offset=0;
                count = recvbuf[offset++];
                for(i=0;i<count;i++)
                {
                    loginfo[i].logpathname.nNum = recvbuf[offset++];
                    memcpy(loginfo[i].logpathname.value,&recvbuf[offset],loginfo[i].logpathname.nNum);
                    offset+=loginfo[i].logpathname.nNum;
                    memcpy_r(&loginfo[i].logsize,&recvbuf[offset],sizeof(uint32));
                    offset+=sizeof(uint32);
                    if(recvbuf[offset++]==1)
                    {
                        int checkNum = recvbuf[offset++];
                        if(checkNum == 32)   //当前处理 若校验长度为32位 默认为SM3编码
                        {
                            loginfo[i].logcheck.choice = DT_CHECKSUM;
                            loginfo[i].logcheck.checksum.checktype = 3;  //SM3编码
                            loginfo[i].logcheck.checksum.checkcode.nNum = checkNum;
                            memcpy(loginfo[i].logcheck.checksum.checkcode.value,&recvbuf[offset],checkNum);
                            offset += checkNum;
                        }
                        else
                        {
                            loginfo[i].logcheck.choice = DT_OCTET_STRING;
                            loginfo[i].logcheck.md5.nNum = checkNum;
                            memcpy(loginfo[i].logcheck.md5.value,&recvbuf[offset],checkNum);
                            offset += checkNum;
                        }
//                        loginfo[i].logmd5.nNum = recvbuf[offset++];
//                        memcpy(loginfo[i].logmd5.value,&recvbuf[offset],loginfo[i].logmd5.nNum);
//                        offset+=loginfo[i].logmd5.nNum;   
                    }
                    memcpy_r(&loginfo[i].creattime.year,&recvbuf[offset],sizeof(uint16));
                    offset+=sizeof(uint16);
                    loginfo[i].creattime.month = recvbuf[offset++];
                    loginfo[i].creattime.day = recvbuf[offset++];
                    loginfo[i].creattime.hour = recvbuf[offset++];
                    loginfo[i].creattime.minute = recvbuf[offset++];
                    loginfo[i].creattime.second = recvbuf[offset++];
                    loginfo[i].logtype = recvbuf[offset++];
                    option = recvbuf[offset++];
                    if(option != 0)
                    {
                     loginfo[i].conname.nNum = recvbuf[offset++];
                     memcpy(loginfo[i].conname.value,&recvbuf[offset],loginfo[i].conname.nNum);
                     offset+=loginfo[i].conname.nNum;
                    }
                    option = recvbuf[offset++];
                    if(option != 0)
                    {
                     loginfo[i].appname.nNum = recvbuf[offset++];
                     memcpy(loginfo[i].appname.value,&recvbuf[offset],loginfo[i].appname.nNum);
                     offset+=loginfo[i].appname.nNum;
                    }  
                }
            offset=outOffset;
            for(i=0;i<count;i++)
            {
                if (slicing_is_comtinue_oop_meter(pApduInfo->bpBreakInfo, i))
                {
                    continue;
                }   
                //转换成报文数据
                convert.srcBuf = &loginfo[i];
                convert.srcLen = sizeof(OOP_CONTAINER_T);
                convert.sOffset = &sOffset;

                convert.dstBuf = &outData->pResultData[offset];
                convert.dstLen = outDataMax - offset;
                convert.dOffset = &dOffset;

                //记录断点信息
                breakInfo.index = i;

                nRet = data_to_buf_log_info(pOadInfo, &convert);  //入参
                if (nRet == DATA_SUCCESS)
                {
                    headLen += dOffset;
                    if (headLen <= maxBufLen)
                    {
                        memcpy(&outData->pResultData[offset], convert.dstBuf, dOffset);
                        offset += dOffset;
                        outData->resultDataLen = offset;
                        PRTL_BUF_LOGCC(convert.dstBuf, dOffset, "第%d个日志信息报文:", i);
                        lognum ++;
                        dOffset = 0;
                        sOffset = 0;
                    }
                    else
                    {
                        dOffset = 0;
                        sOffset = 0;
                        isBufFull = TRUE;
                        PRTL_FMT_LOGCC("class11_invoke_get_container isBufFull == TRUE \n");
                    }
                }
                else
                {
                    continue;
                }
                if ((isBufFull) && (offset > 0))
                {
                    break;
                }
            }
            if (!isBufFull)
            {
                if (pApduInfo->bpBreakInfo->appSlicingFlag == 0x01)
                {
                    breakInfo.appSlicingFlag = 0x01;
                    breakInfo.isEnd = 0x01;                           //末尾帧
                    breakInfo.seq = pApduInfo->bpBreakInfo->seq + 1;  //序号加1
                    breakInfo.objPre = 0x01;                          //对象属性
                }
                else
                {
                    /*清除断点信息*/
                    memset(&breakInfo, 0, sizeof(BP_INFO_T));
                }
            }
            else
            {
                breakInfo.reqType = pApduInfo->reqType;
                breakInfo.appSlicingFlag = 0x01;
                breakInfo.isEnd = 0x00;                              //不是末尾帧
                breakInfo.objPre = 0x01;                             //对象属性
                if (pApduInfo->bpBreakInfo->appSlicingFlag == 0x00)
                {
                    breakInfo.seq = BRK_SEQ_START;                   //首次序号
                }
                else
                {
                    breakInfo.seq = pApduInfo->bpBreakInfo->seq + 1;  //序号加1
                }
            }
            //刷新断点信息
            memcpy(pApduInfo->bpBreakInfo, &breakInfo, sizeof(BP_INFO_T));

            PRTL_BUF_DEBUG(outData->pResultData, offset, "整个日志信息报文:");
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->appSlicingFlag = %d\n", pApduInfo->bpBreakInfo->appSlicingFlag);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->index = %d\n", pApduInfo->bpBreakInfo->index);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->isEnd = %d\n", pApduInfo->bpBreakInfo->isEnd);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->objPre = %d\n", pApduInfo->bpBreakInfo->objPre);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->seq = %d\n", pApduInfo->bpBreakInfo->seq);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->reqType = %d\n", pApduInfo->bpBreakInfo->reqType);
            if (lognum > 0)
            {
                nRet = DATA_SUCCESS;
                outData->pResultData[lognumoffset] = lognum;   
                outData->resultDataLen = offset;
            }
            else
            {
                nRet = DATA_SUCCESS;
                outData->pResultData[lognumoffset+1] = 0;  
                outData->resultDataLen = offset+1;
                return nRet;
            }
            
            }
            break;
        default:
            {
                return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
            /* 数据和报文转换 */
        return nRet;
    }


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_logInfo_record11(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret;
    OOP_DAR_E dar = DATA_SUCCESS;
    OOP_DAR_E nRet = DATA_OTHER_REASON;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 dOffset = 0,bufAllLen=0;
    BP_INFO_T breakInfo;
    MEMZERO(&breakInfo, sizeof(BP_INFO_T));
    uint32    maxBufLen = 0;
    uint32 offset  = 0;    
    uint8 sendbuf[100] = {0};
    uint16 recvlen = 0,count = 0,i,lognumoffset = 0;
    uint8 recvbuf[1024] = {0};
    MEMZERO(&convert, sizeof(convert)); 
    BOOL      isBufFull = FALSE;
    uint8 lognum = 0;
    maxBufLen = pApduInfo->connectionInfo.ApplSplitLen - cal_excludeLen(pApduInfo->connectionInfo);

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF4000200:
        {
            OOP_LOG_INFO_T loginfo[OOP_MAX_LOGS];
            memset(&loginfo,0,sizeof(OOP_LOG_INFO_T)*OOP_MAX_LOGS);
            uint8 option = 0;
            sendbuf[0] = 1; //日志类型     [1] LOGTYPE，
            sendbuf[1] = 0; //全部日志（0），
            ret = appmain_send_syncmsg_time(MSG_APPAMIN_LOGINFO_GET,sendbuf,2,recvbuf,sizeof(recvbuf),&recvlen, 60);
            if(ret!=ERR_OK)
            {
                PRTL_FMT_DEBUG("获取全部日志信息失败 ret %d\n",ret);
                return 0;
            }
            count = recvbuf[offset++];
            for(i=0;i<count;i++)
            {
                loginfo[i].logpathname.nNum = recvbuf[offset++];
                memcpy(loginfo[i].logpathname.value,&recvbuf[offset],loginfo[i].logpathname.nNum);
                offset+=loginfo[i].logpathname.nNum;
                memcpy_r(&loginfo[i].logsize,&recvbuf[offset],sizeof(uint32));
                offset+=sizeof(uint32);
                if(recvbuf[offset++]==1)
                {
//                    loginfo[i].logmd5.nNum = recvbuf[offset++];
//                    memcpy(loginfo[i].logmd5.value,&recvbuf[offset],loginfo[i].logmd5.nNum);
//                    offset+=loginfo[i].logmd5.nNum;   
                    int checkNum = recvbuf[offset++];
                    if(checkNum == 32)   //当前处理 若校验长度为32位 默认为SM3编码
                    {
                        loginfo[i].logcheck.choice = DT_CHECKSUM;
                        loginfo[i].logcheck.checksum.checktype = 3;  //SM3编码
                        loginfo[i].logcheck.checksum.checkcode.nNum = checkNum;
                        memcpy(loginfo[i].logcheck.checksum.checkcode.value,&recvbuf[offset],checkNum);
                        offset += checkNum;
                    }
                    else
                    {
                        loginfo[i].logcheck.choice = DT_OCTET_STRING;
                        loginfo[i].logcheck.md5.nNum = checkNum;
                        memcpy(loginfo[i].logcheck.md5.value,&recvbuf[offset],checkNum);
                        offset += checkNum;
                    }

                }
                memcpy_r(&loginfo[i].creattime.year,&recvbuf[offset],sizeof(uint16));
                offset+=sizeof(uint16);
                loginfo[i].creattime.month = recvbuf[offset++];
                loginfo[i].creattime.day = recvbuf[offset++];
                loginfo[i].creattime.hour = recvbuf[offset++];
                loginfo[i].creattime.minute = recvbuf[offset++];
                loginfo[i].creattime.second = recvbuf[offset++];
                loginfo[i].logtype = recvbuf[offset++];
                option = recvbuf[offset++];
                if(option != 0)
                {
                 loginfo[i].conname.nNum = recvbuf[offset++];
                 memcpy(loginfo[i].conname.value,&recvbuf[offset],loginfo[i].conname.nNum);
                 offset+=loginfo[i].conname.nNum;
                }
                option = recvbuf[offset++];
                if(option != 0)
                {
                 loginfo[i].appname.nNum = recvbuf[offset++];
                 memcpy(loginfo[i].appname.value,&recvbuf[offset],loginfo[i].appname.nNum);
                 offset+=loginfo[i].appname.nNum;
                }  
            }
            offset=0;
            memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));   //拷贝OAD
            offset += sizeof(OOP_OAD_U);
            outData->pResultData[offset ++] = 0x01;                             //结果
            outData->pResultData[offset ++] = DT_ARRAY;                         //类型
            lognumoffset = offset;                                        
            outData->pResultData[offset ++] = 0x00;                             //数量，先填0
            bufAllLen = offset;
            for(i=0;i<count;i++)
            {
                if (slicing_is_comtinue_oop_meter(pApduInfo->bpBreakInfo, i))
                {
                    continue;
                }   
                //转换成报文数据
                convert.srcBuf = &loginfo[i];
                convert.srcLen = sizeof(OOP_CONTAINER_T);
                convert.sOffset = &sOffset;

                convert.dstBuf = &outData->pResultData[offset];
                convert.dstLen = outDataMax - offset;
                convert.dOffset = &dOffset;

                //记录断点信息
                breakInfo.index = i;

                nRet = data_to_buf_log_info(pOadInfo, &convert);  //入参
                if (nRet == DATA_SUCCESS)
                {
                    bufAllLen += dOffset;
                    if (bufAllLen <= maxBufLen)
                    {
                        memcpy(&outData->pResultData[offset], convert.dstBuf, dOffset);
                        offset += dOffset;
                        outData->resultDataLen = offset;
                        PRTL_BUF_LOGCC(convert.dstBuf, dOffset, "第%d个日志信息报文:", i);
                        lognum ++;
                        dOffset = 0;
                        sOffset = 0;
                    }
                    else
                    {
                        dOffset = 0;
                        sOffset = 0;
                        isBufFull = TRUE;
                        PRTL_FMT_LOGCC("class11_invoke_get_container isBufFull == TRUE \n");
                    }
                }
                else
                {
                    continue;
                }
                if ((isBufFull) && (offset > 0))
                {
                    break;
                }
            }
            if (!isBufFull)
            {
                if (pApduInfo->bpBreakInfo->appSlicingFlag == 0x01)
                {
                    breakInfo.appSlicingFlag = 0x01;
                    breakInfo.isEnd = 0x01;                           //末尾帧
                    breakInfo.seq = pApduInfo->bpBreakInfo->seq + 1;  //序号加1
                    breakInfo.objPre = 0x01;                          //对象属性
                }
                else
                {
                    /*清除断点信息*/
                    memset(&breakInfo, 0, sizeof(BP_INFO_T));
                }
            }
            else
            {
                breakInfo.reqType = pApduInfo->reqType;
                breakInfo.appSlicingFlag = 0x01;
                breakInfo.isEnd = 0x00;                              //不是末尾帧
                breakInfo.objPre = 0x01;                             //对象属性
                if (pApduInfo->bpBreakInfo->appSlicingFlag == 0x00)
                {
                    breakInfo.seq = BRK_SEQ_START;                   //首次序号
                }
                else
                {
                    breakInfo.seq = pApduInfo->bpBreakInfo->seq + 1;  //序号加1
                }
            }

            //刷新断点信息
            memcpy(pApduInfo->bpBreakInfo, &breakInfo, sizeof(BP_INFO_T));

            PRTL_BUF_DEBUG(outData->pResultData, offset, "整个日志信息报文:");
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->appSlicingFlag = %d\n", pApduInfo->bpBreakInfo->appSlicingFlag);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->index = %d\n", pApduInfo->bpBreakInfo->index);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->isEnd = %d\n", pApduInfo->bpBreakInfo->isEnd);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->objPre = %d\n", pApduInfo->bpBreakInfo->objPre);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->seq = %d\n", pApduInfo->bpBreakInfo->seq);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->reqType = %d\n", pApduInfo->bpBreakInfo->reqType);
            if (lognum > 0)
            {
                nRet = DATA_SUCCESS;
                outData->pResultData[lognumoffset] = lognum;   
                outData->resultDataLen = offset;
            }
            else
            {
                nRet = DATA_SUCCESS;
                outData->pResultData[lognumoffset] = 0;  
                outData->resultDataLen = offset;
            }
            return nRet;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;


}


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_logInfo_normal(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret;
    OOP_DAR_E dar = DATA_SUCCESS;
    OOP_DAR_E nRet = DATA_OTHER_REASON;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 dOffset = 0,bufAllLen=0;
    BP_INFO_T breakInfo;
    MEMZERO(&breakInfo, sizeof(BP_INFO_T));
    uint32    maxBufLen = 0;
    uint32 offset  = 0;    
    uint8 sendbuf[100] = {0};
    uint16 recvlen = 0,count = 0,i,lognumoffset = 0;
    uint8 recvbuf[1024] = {0};
    MEMZERO(&convert, sizeof(convert)); 
    BOOL      isBufFull = FALSE;
    uint8 lognum = 0;
    maxBufLen = pApduInfo->connectionInfo.ApplSplitLen - cal_excludeLen(pApduInfo->connectionInfo);

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF4000200:
        {
            OOP_LOG_INFO_T loginfo[OOP_MAX_LOGS];
            memset(&loginfo,0,sizeof(OOP_LOG_INFO_T)*OOP_MAX_LOGS);
            uint8 option = 0;
            sendbuf[0] = 1; //日志类型     [1] LOGTYPE，
            sendbuf[1] = 0; //全部日志（0），
            ret = appmain_send_syncmsg_time(MSG_APPAMIN_LOGINFO_GET,sendbuf,2,recvbuf,sizeof(recvbuf),&recvlen, 60);
            if(ret!=ERR_OK)
            {
                PRTL_FMT_DEBUG("获取全部日志信息失败 ret %d\n",ret);
                return 0;
            }
            count = recvbuf[offset++];
            for(i=0;i<count;i++)
            {
                loginfo[i].logpathname.nNum = recvbuf[offset++];
                memcpy(loginfo[i].logpathname.value,&recvbuf[offset],loginfo[i].logpathname.nNum);
                offset+=loginfo[i].logpathname.nNum;
                memcpy_r(&loginfo[i].logsize,&recvbuf[offset],sizeof(uint32));
                offset+=sizeof(uint32);
                if(recvbuf[offset++]==1)
                {
//                    loginfo[i].logmd5.nNum = recvbuf[offset++];
//                    memcpy(loginfo[i].logmd5.value,&recvbuf[offset],loginfo[i].logmd5.nNum);
//                    offset+=loginfo[i].logmd5.nNum;   
                    int checkNum = recvbuf[offset++];
                    if(checkNum == 32)   //当前处理 若校验长度为32位 默认为SM3编码
                    {
                        loginfo[i].logcheck.choice = DT_CHECKSUM;
                        loginfo[i].logcheck.checksum.checktype = 3;  //SM3编码
                        loginfo[i].logcheck.checksum.checkcode.nNum = checkNum;
                        memcpy(loginfo[i].logcheck.checksum.checkcode.value,&recvbuf[offset],checkNum);
                        offset += checkNum;
                    }
                    else
                    {
                        loginfo[i].logcheck.choice = DT_OCTET_STRING;
                        loginfo[i].logcheck.md5.nNum = checkNum;
                        memcpy(loginfo[i].logcheck.md5.value,&recvbuf[offset],checkNum);
                        offset += checkNum;
                    }
                }
                memcpy_r(&loginfo[i].creattime.year,&recvbuf[offset],sizeof(uint16));
                offset+=sizeof(uint16);
                loginfo[i].creattime.month = recvbuf[offset++];
                loginfo[i].creattime.day = recvbuf[offset++];
                loginfo[i].creattime.hour = recvbuf[offset++];
                loginfo[i].creattime.minute = recvbuf[offset++];
                loginfo[i].creattime.second = recvbuf[offset++];
                loginfo[i].logtype = recvbuf[offset++];
                option = recvbuf[offset++];
                if(option != 0)
                {
                 loginfo[i].conname.nNum = recvbuf[offset++];
                 memcpy(loginfo[i].conname.value,&recvbuf[offset],loginfo[i].conname.nNum);
                 offset+=loginfo[i].conname.nNum;
                }
                option = recvbuf[offset++];
                if(option != 0)
                {
                 loginfo[i].appname.nNum = recvbuf[offset++];
                 memcpy(loginfo[i].appname.value,&recvbuf[offset],loginfo[i].appname.nNum);
                 offset+=loginfo[i].appname.nNum;
                }  
            }
            offset=0;
            memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));   //拷贝OAD
            offset += sizeof(OOP_OAD_U);
            outData->pResultData[offset ++] = 0x01;                             //结果
            outData->pResultData[offset ++] = DT_ARRAY;                         //类型
            lognumoffset = offset;                                        
            outData->pResultData[offset ++] = 0x00;                             //数量，先填0
            bufAllLen = offset;
            for(i=0;i<count;i++)
            {
                if (slicing_is_comtinue_oop_meter(pApduInfo->bpBreakInfo, i))
                {
                    continue;
                }   
                //转换成报文数据
                convert.srcBuf = &loginfo[i];
                convert.srcLen = sizeof(OOP_CONTAINER_T);
                convert.sOffset = &sOffset;

                convert.dstBuf = &outData->pResultData[offset];
                convert.dstLen = outDataMax - offset;
                convert.dOffset = &dOffset;

                //记录断点信息
                breakInfo.index = i;

                nRet = data_to_buf_log_info(pOadInfo, &convert);  //入参
                if (nRet == DATA_SUCCESS)
                {
                    bufAllLen += dOffset;
                    if (bufAllLen <= maxBufLen)
                    {
                        memcpy(&outData->pResultData[offset], convert.dstBuf, dOffset);
                        offset += dOffset;
                        outData->resultDataLen = offset;
                        PRTL_BUF_LOGCC(convert.dstBuf, dOffset, "第%d个日志信息报文:", i);
                        lognum ++;
                        dOffset = 0;
                        sOffset = 0;
                    }
                    else
                    {
                        dOffset = 0;
                        sOffset = 0;
                        isBufFull = TRUE;
                        PRTL_FMT_LOGCC("class11_invoke_get_container isBufFull == TRUE \n");
                    }
                }
                else
                {
                    continue;
                }
                if ((isBufFull) && (offset > 0))
                {
                    break;
                }
            }
            if (!isBufFull)
            {
                if (pApduInfo->bpBreakInfo->appSlicingFlag == 0x01)
                {
                    breakInfo.appSlicingFlag = 0x01;
                    breakInfo.isEnd = 0x01;                           //末尾帧
                    breakInfo.seq = pApduInfo->bpBreakInfo->seq + 1;  //序号加1
                    breakInfo.objPre = 0x01;                          //对象属性
                }
                else
                {
                    /*清除断点信息*/
                    memset(&breakInfo, 0, sizeof(BP_INFO_T));
                }
            }
            else
            {
                breakInfo.reqType = pApduInfo->reqType;
                breakInfo.appSlicingFlag = 0x01;
                breakInfo.isEnd = 0x00;                              //不是末尾帧
                breakInfo.objPre = 0x01;                             //对象属性
                if (pApduInfo->bpBreakInfo->appSlicingFlag == 0x00)
                {
                    breakInfo.seq = BRK_SEQ_START;                   //首次序号
                }
                else
                {
                    breakInfo.seq = pApduInfo->bpBreakInfo->seq + 1;  //序号加1
                }
            }

            //刷新断点信息
            memcpy(pApduInfo->bpBreakInfo, &breakInfo, sizeof(BP_INFO_T));

            PRTL_BUF_DEBUG(outData->pResultData, offset, "整个日志信息报文:");
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->appSlicingFlag = %d\n", pApduInfo->bpBreakInfo->appSlicingFlag);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->index = %d\n", pApduInfo->bpBreakInfo->index);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->isEnd = %d\n", pApduInfo->bpBreakInfo->isEnd);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->objPre = %d\n", pApduInfo->bpBreakInfo->objPre);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->seq = %d\n", pApduInfo->bpBreakInfo->seq);
            PRTL_FMT_DEBUG("记下断点信息 bpBreakInfo->reqType = %d\n", pApduInfo->bpBreakInfo->reqType);
            if (lognum > 0)
            {
                nRet = DATA_SUCCESS;
                outData->pResultData[lognumoffset] = lognum;   
                outData->resultDataLen = offset;
            }
            else
            {
                nRet = DATA_SUCCESS;
                outData->pResultData[lognumoffset] = 0;  
                outData->resultDataLen = offset;
            }
            return nRet;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time_normal(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40000200:
        {
            OOP_DATETIME_S_T data = {0};
            DateTimeHex_t dataHex;
            memset(&dataHex,0,sizeof(DateTimeHex_t));
            systime_get((DateTimeHex_t*)&dataHex);
            memcpy(&data, &dataHex, sizeof(DateTimeHex_t));
            memrev((uint8*)&data, 2);      //OOP_DATETIME_S_T的年高底位反转
            PRTL_FMT_LOGCC("class8_invoke_get_time : data.year = %d\n", data.year);
            PRTL_FMT_LOGCC("class8_invoke_get_time : data.month = %d\n", data.month);
            PRTL_FMT_LOGCC("class8_invoke_get_time : data.day = %d\n", data.day);
            PRTL_FMT_LOGCC("class8_invoke_get_time : data.hour = %d\n", data.hour);
            PRTL_FMT_LOGCC("class8_invoke_get_time : data.minute = %d\n", data.minute);
            PRTL_FMT_LOGCC("class8_invoke_get_time : data.second = %d\n", data.second);
            

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get_time_zone_switch
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_LCD_param(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40070200:
        {
            OOP_LCD_T LCDdata = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(LCDdata), (uint8*)&LCDdata, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }   
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &LCDdata, sizeof(LCDdata));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }      

            //转换成报文数据
            convert.srcBuf = &LCDdata;
            convert.srcLen = sizeof(LCDdata);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：       class8_invoke_get_time_zone_switch
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time_zone_switch(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40080200:
        {
            OOP_DATETIME_S_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(data), (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }   
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }      

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get_day_step_switch
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_day_step_switch(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40090200:
        {
            OOP_DATETIME_S_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(data), (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }   
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }      

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get_day_step_switch
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_min_step_switch(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x400A0200:
    case 0x400B0200:
        {
            OOP_DATETIME_S_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(data), (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }   
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }      

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class11_invoke_get_oop_meter_record
* @brief：     class11的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time_record(OAD_INFO_T *pOdaInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    uint16 i = 0;
    OOP_DAR_E  nRet = DATA_OTHER_REASON;
    uint32 offset = 4;
    uint16 csdStart = 0, csdLen = 0;
    uint16 outOffset = 0;
    uint16 inDataLenTmp = InDataLen;

    /* 类型不存在 */
    if (pOdaInfo->pTab->oad.nObjID != 0x4000)
    {
        return DATA_OBJECT_UNAVAILABLE;
    }

    switch (pOdaInfo->pTab->oad.attID)
    {
    case 2:
        {
            OOP_PRSD_T oopRsd;
            OOP_RCSD_T oopRcsd;
            uint16 headLen = 0;
            RELY_INFO_T  relyInfo;
            RECORD_BUF_T outRecordBuf;

            /* 清0处理 */
            MEMZERO(&oopRsd, sizeof(oopRsd));
            MEMZERO(&oopRcsd, sizeof(oopRcsd));
            MEMZERO(&relyInfo, sizeof(relyInfo));
            MEMZERO(&outRecordBuf, sizeof(outRecordBuf));

            outRecordBuf.recordBuf = (uint8 *)malloc(pApduInfo->connectionInfo.ApplSplitLen);
            memset(outRecordBuf.recordBuf, 0xee, pApduInfo->connectionInfo.ApplSplitLen);

            /*处理RSD*/
            nRet = apdu_rsd_fromfmt698(inData, inDataLenTmp, &offset, &oopRsd, sizeof(oopRsd));
            PRTL_FMT_LOGCC("oopRsd.choice = %d\n", oopRsd.choice);
            PRTL_FMT_LOGCC("oopRsd.sel1.oad.value = 0x%08x\n", oopRsd.sel1.oad.value);
            PRTL_FMT_LOGCC("oopRsd.sel1.value.wVal = %d\n", oopRsd.sel1.value.wVal);
            PRTL_FMT_LOGCC("offset = %d\n", offset);
            if (nRet != DATA_SUCCESS)
            {
                PRTL_FMT_TRACE("RSD解析错误\n");

                /*应对电科院协议一致性测试*/
                uint16 testOffset = 4;
                uint16 inCsdOff = 0, inCsdLen = 0;
                apdu_next_dpos_get(inData, &testOffset, InDataLen, DT_RSD, TRUE);
                inCsdOff = testOffset;
                apdu_next_dpos_get(inData, &testOffset, InDataLen, DT_RCSD, TRUE);
                inCsdLen = testOffset - inCsdOff;
                memcpy(outData->pResultData, inData, 4);
                memcpy(outData->pResultData + 4, inData + inCsdOff, inCsdLen);
                outData->resultDataLen = 4 + inCsdLen;

                outData->pResultData[outData->resultDataLen++] = 1;                   //后面优化下，outData->resultDataLen与下面统一
                if (apdu_rcsd_fromfmt698((uint8 *)inData, InDataLen, &offset, &oopRcsd, sizeof(oopRcsd)) != DATA_SUCCESS)
                {
                    outData->pResultData[outData->resultDataLen++] = 0;

                }
                else
                {
                    outData->pResultData[outData->resultDataLen++] = 1;
                    for (i = 0; i < oopRcsd.nNum; i++)
                    {
                        outData->pResultData[outData->resultDataLen++] = NULL_DATA;
                    }
                }

                free(outRecordBuf.recordBuf);
                outRecordBuf.recordBuf = NULL;
                return DATA_SUCCESS;
            }
            else
            {
                inDataLenTmp -= offset;  //除去RSD和OAD后的长度
            }

            /*处理RCSD*/
            csdStart = offset;
            if (apdu_rcsd_fromfmt698(inData, InDataLen, &offset, &oopRcsd, sizeof(oopRcsd)) != DATA_SUCCESS)
            {
                PRTL_FMT_TRACE("CSD解析错误!\n");
                free(outRecordBuf.recordBuf);
                outRecordBuf.recordBuf = NULL;
                return DATA_TYPE_UNMATCHED;
            }

            /*填写OAD+RCSD+记录结果1 并记下偏移headLen*/
            outData->resultDataLen = 0;
            csdLen = offset-csdStart;
            memcpy(outData->pResultData, inData, 4);
            outOffset = 4;

            if (csdLen == 1)
            {
                //如果rcsd为空，填充OAD60010200
                outData->pResultData[outOffset ++] = 0x01;
                outData->pResultData[outOffset ++] = 0x00;
                outData->pResultData[outOffset ++] = 0x60;
                outData->pResultData[outOffset ++] = 0x01;
                outData->pResultData[outOffset ++] = 0x02;
                outData->pResultData[outOffset ++] = 0x00;
            }
            else
            {
                memcpy(&outData->pResultData[outOffset], &inData[csdStart], csdLen);
                outOffset += csdLen;
            }
            outData->pResultData[outOffset++] = 0;
            outData->resultDataLen += outOffset;
            headLen = outOffset;
            PRTL_BUF_LOGCC(&outData->pResultData[0], headLen, "填写OAD+RCSD+记录结果0 并记下偏移headLen head:");

            //暂时没有招时间用记录方法的需求，填255错误码
            outData->pResultData[outOffset++] = DATA_OTHER_REASON;
            outData->resultDataLen += 1;
            PRTL_BUF_LOGCC(&outData->pResultData[0], outOffset, "完整报文:");

            free(outRecordBuf.recordBuf);
            outRecordBuf.recordBuf = NULL;
            return DATA_SUCCESS;
        }
        break;
    default:
        {
            return DATA_OBJECT_UNAVAILABLE;
        }
        break;
    }

    return nRet;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_wallet(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x202c0200:
        {
            OOP_DWORD2_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);

                //数据中心出错返回NULL
                return oop_null_data_res(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            }
            PRTL_FMT_LOGCC("class8_invoke_get_wallet : data.nValue1[%d], data.nValue1[%d]\n", data.nValue1, data.nValue1);          

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_server_addr(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x202a0200:
        {
            OOP_DWORD2_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);

                //数据中心出错返回NULL
                return oop_null_data_res(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            }
            PRTL_FMT_LOGCC("class8_invoke_get_wallet : data.nValue1[%d], data.nValue1[%d]\n", data.nValue1, data.nValue1);          

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class11_invoke_get_oop_meter
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_logInfo(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 inLen, RESULT_DATA_T *outData, uint16 outDataMax)
{

    if(pOadInfo->isRec == TRUE)
    {
        return class8_invoke_get_logInfo_record(pOadInfo, pApduInfo, inData, inLen, outData, outDataMax);
    }else
    {
        return class8_invoke_get_logInfo_normal(pOadInfo, pApduInfo, inData, inLen, outData, outDataMax);
    }

    
    return DATA_OBJECT_UNDEFINED;
}


/**
*********************************************************************
* @name：      class11_invoke_get_oop_meter
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_secInfo(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 inLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    OOP_OCTETVAR1K_T data = {0};

    uint8 *pAddr = NULL;
    uint8  addrLen = 0;

    MEMZERO(&convert, sizeof(convert)); 

    addrLen = app_get_localaddr(&pAddr);
    if (addrLen == 0)
    {
        PRTL_FMT_DEBUG("获取地址失败 oad[0x%08X]\n", pOadInfo->pTab->oad.value);
        return DATA_TYPE_UNMATCHED;
    }

    ret = sec_get_app_tag(pAddr, addrLen, &data);
    if (ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("获取标识信息失败 ret[%d], oad[0x%08X]\n", ret, pOadInfo->pTab->oad.value);
        return DATA_TYPE_UNMATCHED;
    }

    //转换成报文数据
    convert.srcBuf = &data;
    convert.srcLen = sizeof(data);
    convert.sOffset = &sOffset;
    
    convert.dstBuf = &outData->pResultData[5];
    convert.dstLen = outDataMax;
    convert.dOffset = &outData->resultDataLen;

    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class11_invoke_get_oop_meter
* @brief：     class11的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 inLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pApduInfo->reqType)
    {
    case 0x01:
    case 0x02:
    case 0x06:
        return class8_invoke_get_time_normal(pOadInfo, pApduInfo, inData, inLen, outData, outDataMax);
        break;
    case 0x03:
    case 0x04:
        return class8_invoke_get_time_record(pOadInfo, pApduInfo, inData, inLen, outData, outDataMax);
        break;  
    default:
        break;
    }

    PRTL_FMT_DEBUG("invoke_get_time failed. oad(0x%08x), reqType(%d)\n", pOadInfo->pTab->oad.value, pApduInfo->reqType);
    
    return DATA_OBJECT_UNDEFINED;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_timing_mod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40000300:
        {
            uint8 data = 0;
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }
            PRTL_FMT_LOGCC("class8_invoke_get_timing_mod : data = %d\n", data);          

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_time_precise
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time_precise(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40000400:
        {
            OOP_SYNCCLOCK_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_time_precise : data.nSum = %d\n", data.nSum);
            PRTL_FMT_LOGCC("class8_invoke_get_time_precise : data.nMaxDelNum = %d\n", data.nMaxDelNum);
            PRTL_FMT_LOGCC("class8_invoke_get_time_precise : data.nMinDelNum = %d\n", data.nMinDelNum);
            PRTL_FMT_LOGCC("class8_invoke_get_time_precise : data.nDelay = %d\n", data.nDelay);
            PRTL_FMT_LOGCC("class8_invoke_get_time_precise : data.nValidNum = %d\n", data.nValidNum);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_sync_clcle
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_sync_cycle(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, 
                                       uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40000600:
        {
            OOP_SYNCCYCLE_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if ((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_sync_cycle : data.norperiod = %d\n", data.norperiod);
            PRTL_FMT_LOGCC("class8_invoke_get_sync_cycle : data.souperiod = %d\n", data.souperiod);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_addr_octet(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    normal.oad.value = pOadInfo->pTab->oad.value;

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40020200:
        {
            normal.oad.value = 0x40010200;
        }
    case 0x40010200:
    case 0x40030200:
        {
            OOP_OCTETVAR16_T data = {0};
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen = 6;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_addr_octet : data.nNum = %d\n", data.nNum);
            PRTL_BUF_LOGCC(&data.value[0], data.nNum, "class8_invoke_get_addr_octet : data.value:");

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_coordinates(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40040200:
        {
            OOP_GEOGADD_A_T data;
            uint8 buf[320] = {0};
            GPS_T tGps;
            MEMZERO(&data, sizeof(OOP_GEOGADD_A_T));
            MEMZERO(&tGps, sizeof(GPS_T));

            if(2 == app_get_timingmode())
            {
                data.type = 1;
                tGps.ststus = 0;
                tGps.mode = 4;
                if(0 != appmain_get_ppp_gps(1, buf, 320))
                {
                    appmsg_gps_split(buf, &tGps);
                }
                if(1 != tGps.ststus || 4 == tGps.mode)
                {
                    if(0 != appmain_get_ppp_gps(2, buf, 320))
                    {
                        appmsg_gps_split(buf, &tGps);
                    }
                }
                if(1 == tGps.ststus && 4 != tGps.mode)
                {
                    data.newaddr.height = tGps.position.height;
                    data.newaddr.longitude.position = tGps.position.longitude.position;
                    data.newaddr.longitude.degre = tGps.position.longitude.degre;
                    data.newaddr.longitude.branch = tGps.position.longitude.branch;
                    
                    data.newaddr.latitude.position = tGps.position.latitude.position;
                    data.newaddr.latitude.degre = tGps.position.latitude.degre;
                    data.newaddr.latitude.branch = tGps.position.latitude.branch;
                }
                else
                {
                    /* 查询不到取临时数据 送检用 */
                    ret = appmain_get_gps_tempposition(&data);
                    if(0 != ret)
                    {
                        PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                                       ret, normal.logicId, normal.infoNum, normal.oad.value);
                    }
                }
            }
            else
            {
                /* 不设置就查询数据中心 */
                normal.oad.value = 0x40040200;
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(OOP_GEOGADD_A_T), (uint8*)&data, &len);
                if(0 != ret)
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                                   ret, normal.logicId, normal.infoNum, normal.oad.value);
                }
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_group_addr
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_group_addr(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0; 
    uint32 i = 0;   

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40050200:
        {
            OOP_GRPADDR_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_group_addr : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_BUF_LOGCC(data.sa[i].add, data.sa[i].len, "class8_invoke_get_group_addr : data:");
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_time_region
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time_region(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0; 

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x400C0200:
        {
            OOP_PERIOD_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }   
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_clock_src(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;  

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40060200:
        {
            OOP_CLOCK_T data = {0};

            //数据先固定
            data.clock = 0x01;
            data.state = 0x00;

            // normal.oad.value = pOadInfo->pTab->oad.value;
            // ret = nomal_data_read(pApduInfo->hUdp, normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            // if((ret != ERR_OK) || (len == 0))
            // {
            //  PRTL_FMT_DEBUG("nomal_data_read failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
            //      ret, normal.logicId, normal.infoNum, normal.oad.value);
            //  return DATA_OTHER_REASON;
            // }

            PRTL_FMT_LOGCC("class8_invoke_get_coordinates : data.clock = %d\n", data.clock);
            PRTL_FMT_LOGCC("class8_invoke_get_coordinates : data.state = %d\n", data.state);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_time_zone
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_time_zone(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E      dar = DATA_SUCCESS;
    NOMAL_OAD_T    normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    #if MSG_AC_PARA_READ == 0
    uint32 len = 0; 
    int    ret = ERR_OK;
    #endif
    uint32 i = 0;  

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40140200:
    case 0x40150200:
        {
            OOP_TIMEZONE_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }

            PRTL_FMT_LOGCC("class8_invoke_get_time_zone : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                    PRTL_FMT_LOGCC("class8_invoke_get_time_zone : data.period[%d].mon:%d\n", 
                        i,  data.period[i].mon);
                    PRTL_FMT_LOGCC("class8_invoke_get_time_zone : data.period[%d].day:%d\n", 
                        i, data.period[i].day);
                    PRTL_FMT_LOGCC("class8_invoke_get_time_zone : data.period[%d].meterNum:%d\n", 
                        i, data.period[i].meterNum);
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_day_period
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_day_period(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    #if MSG_AC_PARA_READ == 0
    uint32 len = 0; 
    int    ret = ERR_OK;
    #endif
    uint32 i = 0;  
    uint32 j = 0; 

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40160200:
    case 0x40170200:
        {
            OOP_DAYPERIOD_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }

            PRTL_FMT_LOGCC("class8_invoke_get_day_period : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                for (j = 0; j < data.dPeriod[i].nNum; j++)
                {
                    PRTL_FMT_LOGCC("class8_invoke_get_day_period : data.dPeriod[%d].period[%d].hour:%d\n", 
                        i, j, data.dPeriod[i].period[j].hour);
                    PRTL_FMT_LOGCC("class8_invoke_get_day_period : data.dPeriod[%d].period[%d].min:%d\n", 
                        i, j, data.dPeriod[i].period[j].min);
                    PRTL_FMT_LOGCC("class8_invoke_get_day_period : data.dPeriod[%d].period[%d].rateNO:%d\n", 
                        i, j, data.dPeriod[i].period[j].rateNO);
                }
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_rate_tariff
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_rate_tariff(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0; 
    uint32 i = 0;   

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40180200:
        case 0x40190200:
        {
            OOP_RATETARIFF_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_rate_tariff : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_get_rate_tariff : data.nValue[%d]:%d\n", 
                    i, data.nValue[i]);
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_reject_from_group
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_reject_from_group(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40240200:
        {
            uint8 data = 0;
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_reject_from_group : data = %d\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_volt_rate
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_volt_rate(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40300200:
        {
            OOP_VOLTPARAM_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_volt_rate : data.uupVolt = %d\n", data.uupVolt);
            PRTL_FMT_LOGCC("class8_invoke_get_volt_rate : data.lldVolt = %d\n", data.lldVolt);
            PRTL_FMT_LOGCC("class8_invoke_get_volt_rate : data.upVolt = %d\n", data.upVolt);
            PRTL_FMT_LOGCC("class8_invoke_get_volt_rate : data.ldVolt = %d\n", data.ldVolt);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_tamod
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_tamod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40400200:
        {
            OOP_TASPCUSEMOD_T data;
            MEMZERO(&data, sizeof(data));
            
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_workstatus
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_workstatus(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40400300:
        {
            OOP_WORKINFO_T data;
            MEMZERO(&data, sizeof(data));

            //normal.logicId = 2; //回路巡检仪逻辑地址2
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_taunit
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_taunit(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40400400:
        {
            OOP_TAUNIT_T data;
            MEMZERO(&data, sizeof(data));
            
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_taunit
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_taversion(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40400500:
        {
            OOP_CTINFO_T data;
            MEMZERO(&data, sizeof(data));
            
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_taunit
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_curloop_monitor(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40410200:
        {
            OOP_CURLOOPCKENABLE_T data = {0};
            
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_demand_period(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E      dar = DATA_SUCCESS;
    DATA_CONVERT_T convert;
    uint32         sOffset = 0;
    uint32         offset  = 0;
    #if MSG_AC_PARA_READ == 0
    uint32         len = 0;  
    int            ret = ERR_OK;  
    NOMAL_OAD_T    normal = {0};
    #endif

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41000200:
        {
            uint8 data = {0};
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                normal.oad.value = pOadInfo->pTab->oad.value;
                ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }


            PRTL_FMT_LOGCC("class8_invoke_get_demand_period : data = %d\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_slip_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E      dar = DATA_SUCCESS;
    DATA_CONVERT_T convert;
    uint32         sOffset = 0;
    uint32         offset  = 0;
    #if MSG_AC_PARA_READ == 0
    uint32         len = 0; 
    int            ret = ERR_OK; 
    NOMAL_OAD_T    normal = {0}; 
    #endif 

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41010200:
        {
            uint8 data = {0};
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                normal.oad.value = pOadInfo->pTab->oad.value;
                ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }

            PRTL_FMT_LOGCC("class8_invoke_get_slip_time : data = %d\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_asset_no(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41030200:
        {
            OOP_VISIBLEVAR32_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_asset_no : data.nNum = %d\n", data.nNum);
            PRTL_BUF_LOGCC(&data.value[0], data.nNum, "class8_invoke_get_asset_no : data:");

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_rated_volt(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41040200:
        {
            OOP_VISIBLESTR6_T data = {{0}};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_rated_curr(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41050200:
        {
            OOP_VISIBLESTR6_T data = {{0}};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_max_curr(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41060200:
        {
            OOP_VISIBLESTR6_T data = {{0}};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_combine_word(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41120200:
    case 0x41130200:
    case 0x41140200:
        {
            OOP_BITSTR8_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(data), (uint8*)&data, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }   
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }
            }   

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_broadcast_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x42040200:
        {
            OOP_SYNCTIME_T data;
            MEMZERO(&data, sizeof(OOP_SYNCTIME_T)); 
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                    
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen += offset;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_broadcast_time : data.time.hour = %d\n", data.time.hour);
            PRTL_FMT_LOGCC("class8_invoke_get_broadcast_time : data.time.minute = %d\n", data.time.minute);
            PRTL_FMT_LOGCC("class8_invoke_get_broadcast_time : data.time.second = %d\n", data.time.second);
            PRTL_FMT_LOGCC("class8_invoke_get_broadcast_time : data.bValid = %d\n", data.bValid);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_p2p_broadcast_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x42040300:
        {
            OOP_P2PSYNCTIME_T data;
            MEMZERO(&data, sizeof(OOP_P2PSYNCTIME_T)); 
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_p2p_broadcast_time : data.offset = %d\n", data.offset);
            PRTL_FMT_LOGCC("class8_invoke_get_p2p_broadcast_time : data.time.hour = %d\n", data.time.hour);
            PRTL_FMT_LOGCC("class8_invoke_get_p2p_broadcast_time : data.time.minute = %d\n", data.time.minute);
            PRTL_FMT_LOGCC("class8_invoke_get_p2p_broadcast_time : data.time.second = %d\n", data.time.second);
            PRTL_FMT_LOGCC("class8_invoke_get_p2p_broadcast_time : data.bValid = %d\n", data.bValid);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_cascade(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x42020200:
        {
            OOP_CASCADE_T data;
            uint32 i = 0;
            MEMZERO(&data, sizeof(OOP_CASCADE_T)); 
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);

                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen += offset;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.flag = %d\n", data.flag);
            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.port = 0x%08x\n", data.port.value);
            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.tdelay = %d\n", data.tdelay);
            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.bdelay = %d\n", data.bdelay);
            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.retry = %d\n", data.retry);
            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.cycle = %d\n", data.cycle);
            PRTL_FMT_LOGCC("class8_invoke_get_cascade : data.casnum = %d\n", data.casnum);
            for (i = 0; i < data.casnum; i++)
            {
                PRTL_BUF_LOGCC(data.addr[i].add, data.addr[i].len, "class8_invoke_get_cascade data.addr:");
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_gprs_apn_res(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0; 
    uint32 i = 0;  
    uint32 j = 0; 

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x45200200:
        {
            OOP_APNGROUP_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_gprs_apn_res : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_get_gprs_apn_res : data.net[%d].factory = %d\n", i, data.net[i].factory);
                PRTL_FMT_LOGCC("class8_invoke_get_gprs_apn_res : data.net[%d].network = %d\n", i, data.net[i].network);
                PRTL_BUF_LOGCC(&data.net[i].apn.apn.value[0], data.net[i].apn.apn.nNum, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.apn:", i);
                PRTL_BUF_LOGCC(&data.net[i].apn.username.value[0], data.net[i].apn.username.nNum, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.username:", i);
                PRTL_BUF_LOGCC(&data.net[i].apn.pwd.value[0], data.net[i].apn.pwd.nNum, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.pwd:", i);
                PRTL_BUF_LOGCC(&data.net[i].apn.proxyip[0], 4, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.proxyip:");
                PRTL_FMT_LOGCC("class8_invoke_get_gprs_apn_res : data.net[%d].apn.proxyport = %d\n", i, data.net[i].apn.proxyport);
                PRTL_FMT_LOGCC("class8_invoke_get_gprs_apn_res : data.net[%d].master.nNum = %d\n", i, data.net[i].master.nNum);
                for (j = 0; j < data.net[i].master.nNum; j++)
                {
                    PRTL_BUF_LOGCC(&data.net[i].master.master[j].ip[0], 4, "class8_invoke_set_gprs_apn_res : data.net[%d].master.master[%d].ip:", i, j);
                    PRTL_FMT_LOGCC("class8_invoke_get_gprs_apn_res : data.net[%d].master.master[%d].port = %d\n", i, j, data.net[i].master.master[j].port);
                }
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_security_flag(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1010200:
        {
            OOP_SECURITYFLAG_E dataGet = 0;
            normal.oad.value = 0xF1010200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&dataGet, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_security_flag : dataGet = %d\n", dataGet);

            //转换成报文数据
            convert.srcBuf = &dataGet;
            convert.srcLen = sizeof(dataGet);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_security_mod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0; 
    uint32 i = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1010300:
        {
            OOP_SCURITYMODE_T data = {0};
            normal.oad.value = 0xF1010300;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_security_mod : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_get_security_mod : data.mode[%d].object = 0x%04x\n", i, data.mode[i].object);
                PRTL_FMT_LOGCC("class8_invoke_get_security_mod : data.mode[%d].access = 0x%04x\n", i, data.mode[i].access);
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_inner_factory_code(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    OOP_VISIBLESTR4_T data;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 dOffset = 0;
    uint32 len = 0;    

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    //读出数据 //TODO 不确定属性，直接用方法存
    normal.oad.value = pOadInfo->pTab->oad.value;
    
    ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(OOP_VISIBLESTR4_T), (uint8*)&data, &len);
    if (ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
            ret, normal.logicId, normal.infoNum, normal.oad.value);
        memcpy(data.value, &g_tVer.factory[0], 4);
    }

    //OAD与返回数据
    memcpy(&outData->pResultData[dOffset], inData, sizeof(OOP_OAD_U));
    dOffset += sizeof(OOP_OAD_U);

    outData->pResultData[dOffset++] = 1;

    //转换成报文数据
    convert.srcBuf = &data;
    convert.srcLen = sizeof(data);
    convert.sOffset = &sOffset;
    
    convert.dstBuf = outData->pResultData;
    convert.dstLen = outDataMax;
    convert.dOffset = &dOffset;
    
    dar = data_to_buf_class8_inner_factory_code(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    outData->resultDataLen = dOffset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_inner_factory_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    NOMAL_OAD_T normal = {0};
    int ret = 0;
    uint32 len = 0;

    MEMZERO(&convert, sizeof(convert)); 
    MEMZERO(&normal, sizeof(normal)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0xFFF00600:
        {
            OOP_DATETIME_S_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
    
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(OOP_DATETIME_S_T), (uint8*)&data, &len);
            if (ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_DATA_BLOCK_UNAVAILABLE;
            }

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：APP_ID
* @param[out]：
* @return    ：错误码
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
int get_devinfo_app_id(OOP_INNER_APP_ID_LIST_T *data)
{
    DIR	          *dirp = NULL;
    struct dirent *entp;
    uint32         appNum = 0;
    OOP_INNER_APP_ID_LIST_T dataTmp;
    
    MEMZERO(&dataTmp, sizeof(OOP_INNER_APP_ID_LIST_T));

    if ((dirp = opendir(DEVINFO_DIR)) == NULL)
    {
        PRTL_FMT_DEBUG("dir[%s] open err.\n", DEVINFO_DIR);
        return -1;
    }

    while ((entp = readdir(dirp)) != NULL)
    {
        if((strcmp(entp->d_name, ".") == 0) || ((strcmp(entp->d_name, "..") == 0)))
        {
            continue;
        }
        
        PRTL_FMT_TRACE("appname:%s\n", entp->d_name);
        dataTmp.innerAppID[appNum].appName.nNum = strlen(entp->d_name);
        memcpy(dataTmp.innerAppID[appNum].appName.value, entp->d_name, strlen(entp->d_name));

        DEVINFO_DEVICE_T* dev = (DEVINFO_DEVICE_T*) hal_device_get(HW_DEVICE_ID_DEVINFO);
        if(NULL == dev)
        {
            PRTL_FMT_DEBUG("devinfo hal_device_get error \n");
        }
        else
        {
            if(dev->devinfo_read_appid(dev, entp->d_name, (char*)dataTmp.innerAppID[appNum].appID.value, APP_ID_LEN) < 0)
            {
                PRTL_FMT_DEBUG("devinfo devinfo_read_appid error \n");
            }
            else
            {
                dataTmp.innerAppID[appNum].appID.nNum = APP_ID_LEN;
            }
            hal_device_release((HW_DEVICE *)dev);
        }

        appNum ++;
    }

    dataTmp.nNum = appNum;

    closedir(dirp);

    *data = dataTmp;

    return 0;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_inner_app_id(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    OOP_INNER_APP_ID_LIST_T data;
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 dOffset = 0;
    uint32 i = 0;    

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    ret = get_devinfo_app_id(&data);
    if (ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("get_devinfo_app_id failed. ret(%d)\n",
            ret);
        return DATA_READ_WRITE_DENIED;
    }

    PRTL_FMT_TRACE("class8_invoke_get_inner_app_id data.nNum = %d\n", data.nNum);
    for (i = 0; i < data.nNum; i++)
    {
        PRTL_FMT_TRACE("data.innerAppID[%d].appName[%s]\n", i, data.innerAppID[i].appName.value);
        PRTL_BUF_TRACE(data.innerAppID[i].appID.value, data.innerAppID[i].appID.nNum, "data.innerAppID[%d].appID:\n", i);
    }

    //OAD与返回数据
    memcpy(&outData->pResultData[dOffset], inData, sizeof(OOP_OAD_U));
    dOffset += sizeof(OOP_OAD_U);

    outData->pResultData[dOffset++] = 1;

    //转换成报文数据
    convert.srcBuf = &data;
    convert.srcLen = sizeof(data);
    convert.sOffset = &sOffset;
    
    convert.dstBuf = outData->pResultData;
    convert.dstLen = outDataMax;
    convert.dOffset = &dOffset;
    
    dar = data_to_buf_class8_inner_app_id(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    outData->resultDataLen = dOffset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_rmt_shake
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-8-3
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_rmt_shake(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    NOMAL_OAD_T normal;
    uint32 offset  = 0;
    uint32 len = 0; 
    uint8  bGetData = TRUE;   
    uint32 shaketime = 0;

    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    if(0x49080200 != pOadInfo->pTab->oad.value)
    {
        return DATA_OBJECT_UNAVAILABLE;
    }

    //读出数据
    normal.oad.value = pOadInfo->pTab->oad.value;
    ret = db_read_nomal(pApduInfo->hUdp, &normal, 4, (uint8*)&shaketime, &len);
    if(ret != ERR_OK || len != 4)
    {
        PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
        bGetData = FALSE;
    }

    /* 填写报文开头处的OAD */
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset = sizeof(OOP_OAD_U);
    /* 填写数据结果0x01 */
    outData->pResultData[offset++] = 0x01;
    if(FALSE == bGetData)
    {
        outData->pResultData[offset++] = 0;
    }
    else
    {
        outData->pResultData[offset++] = DT_DOUBLE_LONG_UNSIGNED;
        memcpy_r(outData->pResultData + offset, &shaketime, 4);
        offset += 4;
    }
    
    outData->resultDataLen = offset;
    return DATA_SUCCESS;
}
/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-11-11
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_charge_service_status(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;    
    uint8 data = 0;
    uint8  bGetData = TRUE;

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x47020200:
        case 0x47020300:
        case 0x47020400:
        {
        
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8 *)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                bGetData = FALSE;
            }
            PRTL_FMT_LOGCC("class8_invoke_get_charge_service_status : data = %d\n", data);          

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;

            break;
        }
        default:
        {
            break;
        }
    }
    
       /* 填写报文开头处的OAD */
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset = sizeof(OOP_OAD_U);
    /* 填写数据结果0x01 */
    outData->pResultData[offset++] = 0x01;
    if(FALSE == bGetData)
    {
        outData->pResultData[offset++] = 0;
    }
    else
    {
        outData->pResultData[offset++] = DT_UNSIGNED;
        memcpy_r(outData->pResultData + offset, &data, 1);
        offset += 1;
    }
    
    outData->resultDataLen = offset;
    return DATA_SUCCESS;
}

/**
*********************************************************************
* @name：      class8_invoke_get_pile_work_status
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-8-3
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_pile_work_status(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    NOMAL_OAD_T normal;
    uint32 offset  = 0;
    uint32 sOffset =0;
    uint32 len = 0; 
    uint8  bGetData = TRUE;   
    PILE_WORK_STATUS_T workstatus;
    DATA_CONVERT_T convert;
    OOP_DAR_E dar = DATA_SUCCESS;

    MEMZERO(&convert, sizeof(convert));
    MEMZERO(&normal, sizeof(NOMAL_OAD_T)); 

    if(0x47010200 != pOadInfo->pTab->oad.value)
    {
        return DATA_OBJECT_UNAVAILABLE;
    }

    //读出数据
    normal.oad.value = pOadInfo->pTab->oad.value;
    ret = db_read_nomal(pApduInfo->hUdp, &normal, 4, (uint8*)&workstatus, &len);
    PRTL_FMT_DEBUG("routingAssets[0]:%d, routingAssets[1]:%d,routingAssets[2]:%d\n",
                        workstatus.routingAssets[0], workstatus.routingAssets[1], workstatus.routingAssets[2]);
    if(ret != ERR_OK || len != sizeof(PILE_WORK_STATUS_T))
    {
        PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
        bGetData = FALSE;
    }

    /* 填写报文开头处的OAD */
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset = sizeof(OOP_OAD_U);
    /* 填写数据结果0x01 */
    outData->pResultData[offset++] = 0x01;
    if(FALSE == bGetData)
    {
        outData->pResultData[offset++] = 0;
    }
    else
    {
         //转换成报文数据
            convert.srcBuf = &workstatus;
            convert.srcLen = sizeof(workstatus);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;

         dar = data_to_buf_class8(pOadInfo, &convert);
         if(dar != DATA_SUCCESS)
         {
             PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
             return dar;
         }

    }   
    outData->resultDataLen = offset;
    return DATA_SUCCESS;
}

/**
*********************************************************************
* @name：      class8_invoke_get_oia_47
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-11-11
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_47(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4701:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_pile_work_status(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:
                {
                    break;
                }
            }
        }
        case 0x4702:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                case 0x03:
                case 0x04:
                {
                    return class8_invoke_get_charge_service_status(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:
                {
                    break;
                }
            }
        }
        default:
        {
            return DATA_OBJECT_UNAVAILABLE;
        }
    }

    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_get_oia_20
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_20(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x202A:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_server_addr(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;          
            default:
                break;
            }
        }
        break;
    case 0x202C:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_wallet(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;          
            default:
                break;
            }
        }
        break;
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_get_oia_40
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_40(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4000:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x03:
                {
                    return class8_invoke_get_timing_mod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x04:
                {
                    return class8_invoke_get_time_precise(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x06:
                {
                    return class8_invoke_get_sync_cycle(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4001:
        case 0x4002:
        case 0x4003:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_addr_octet(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:  break;
            }
            break;
        }
        case 0x4004:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_coordinates(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:  break;
            }
            break;
        }
        case 0x4005:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_group_addr(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4007:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_LCD_param(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4008:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_time_zone_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:  break;
            }
            break;
        }
        case 0x4009:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_day_step_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x400A:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_min_step_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x400B:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_min_step_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x400C:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_time_region(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }   
                default:  break;
            }
            break;
        }
        case 0x4006:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_clock_src(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4014:
        case 0x4015:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_time_zone(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4016:
        case 0x4017:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_day_period(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4018:
        case 0x4019:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_rate_tariff(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4024:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_reject_from_group(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4030:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_volt_rate(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }
        case 0x4040: //TA专用模块
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02: //模块信息
                {
                    return class8_invoke_get_tamod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x03: //工况信息
                {
                    return class8_invoke_get_workstatus(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x04: //换算及单位
                {
                    return class8_invoke_get_taunit(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }   
                case 0x05: //版本信息
                {
                    return class8_invoke_get_taversion(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }               
                default: break;
            }
            break;
        }
        case 0x4041: //电流回路监测使能
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02: //模块信息
                {
                    return class8_invoke_get_curloop_monitor(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
            break;
        }

        default: return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}


/**
*********************************************************************
* @name：      class8_invoke_get_oia_41
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_41(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x4100:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_demand_period(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                break;
            }
        }
    case 0x4101:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_slip_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                break;
            }
        }    
    case 0x4103:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_asset_no(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                break;
            }
        }
    case 0x4104: //额定电压
      {
          switch (pOadInfo->pTab->oad.attID)
          {
          case 0x02:
              {
                  return class8_invoke_get_rated_volt(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
              }
              break;
          
          default:
              return DATA_OBJECT_UNAVAILABLE;
              break;
          }
      }
      break;    
    case 0x4105: //额定电流
      {
          switch (pOadInfo->pTab->oad.attID)
          {
          case 0x02:
              {
                  return class8_invoke_get_rated_curr(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
              }
              break;
          
          default:
              return DATA_OBJECT_UNAVAILABLE;
              break;
          }
      }
      break;        
    case 0x4106: //最大电流
      {
          switch (pOadInfo->pTab->oad.attID)
          {
          case 0x02:
              {
                  return class8_invoke_get_max_curr(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
              }
              break;
          
          default:
              return DATA_OBJECT_UNAVAILABLE;
              break;
          }
      }
      break;   

    case 0x4112: //组合特征字
    case 0x4113: //组合特征字
    case 0x4114: //组合特征字
      {
          switch (pOadInfo->pTab->oad.attID)
          {
          case 0x02:
              {
                  return class8_invoke_get_combine_word(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
              }
              break;
          
          default:
              return DATA_OBJECT_UNAVAILABLE;
              break;
          }
      }
      break; 
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_42(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x4202:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_cascade(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                break;
            }
        }
    case 0x4204:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_broadcast_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x03:
                {
                    return class8_invoke_get_p2p_broadcast_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;            
            default:
                break;
            }
        }

    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}

/**
*********************************************************************
* @name：      class8_invoke_get_oia_45
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_45(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x4520:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_gprs_apn_res(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                break;
            }
        }

    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}

/**
*********************************************************************
* @name：      class8_invoke_get_oia_49
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度
* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-8-3
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_49(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4908:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                    return class8_invoke_get_rmt_shake(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                default:  return DATA_OBJECT_UNAVAILABLE;
            }
        }
        default: return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_get_oia_4E
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度
* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-8-3
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_4E(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    #ifdef AREA_ZHEJIANG
        case 0x4E07: //拓扑识别关系
            {
                switch (pOadInfo->pTab->oad.attID)
                {
                case 0x02: 
                    {
                        return class8_invoke_get_cbir_result(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                    }
                    break;

                default:
                    break;
                }
            }
    #endif
    #ifdef AREA_FUJIAN
        case 0x4E01: 
        case 0x4E02: 
        case 0x4E03: 
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02: 
            {
                return class8_invoke_get_oia_4e_fj(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            }
            break;

            default:
                break;
            }
        }
    #endif
        default: return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_f1(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xF101:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_security_flag(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x03:
                {
                    return class8_invoke_get_security_mod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;               
            default:
                break;
            }
            
        }
        break;

    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_f4(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xF400:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_logInfo(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
               
                default:break;
                
            }
        }break;

    case 0xF406:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_get_secInfo(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }

                default:break;         
            }
        }break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_ff(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xFFF0:
        {
            switch (pOadInfo->pTab->oad.attID)
            {  
                case 0x04:
                {
                    return class8_invoke_get_inner_factory_code(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x06:
                {
                    return class8_invoke_get_inner_factory_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:  break;
            }
            
        }
        break;
    case 0xFFF2:
        {
            switch (pOadInfo->pTab->oad.attID)
            {  
            case 0x04:
                {
                    return class8_invoke_get_inner_app_id(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;               
            default:
                break;
            }
            
        }
        break;
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_yk_config(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80000200:
        {
            OOP_TELECON_PARAM_T data = {0};
            normal.oad.value = 0x80000200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen += offset;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_yk_config : data.limit = %d\n", data.limit);
            PRTL_FMT_LOGCC("class8_invoke_get_yk_config : data.delay = %d\n", data.delay);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_ykalarm_state(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80000400:
        {
        #ifdef PRODUCT_ZCU_1
            OOP_BITSTR16_T data = {0};
        #else
            OOP_BITSTR8_T data = {0};
        #endif
            normal.oad.value = 0x80000400;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_ykalarm_state : data.nValue = 0x%x\n", data.nValue);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_ykcmd_state(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80000500:
        {
        #ifdef PRODUCT_ZCU_1
            OOP_BITSTR16_T data = {0};
        #else
            OOP_BITSTR8_T data = {0};
        #endif
            
            normal.oad.value = 0x80000500;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_ykalarm_state : data.nValue = 0x%x\n", data.nValue);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_guard_state(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80010200:
        {
            uint8 data = 0;
            normal.oad.value = 0x80010200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_guard_state : data = 0x%x\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_guard_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80010300:
        {
            uint16 data = 0;
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen += offset;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_ykalarm_state : data = 0x%x\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    case 0x80010400:
        {
            uint16 data = 0;
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen += offset;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_ykalarm_state : data = 0x%x\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_auto_guard_interval(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80010500:
        {
            OOP_PRTTIME_T data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen += offset;
                return DATA_SUCCESS;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_ykalarm_state : data = 0x%x\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_payment_state(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80020200:
        {
            uint8 data = {0};
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_get_ykalarm_state : data = 0x%x\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_payment_para(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80020300:
        {
            OOP_CALLFEE_T data;
            MEMZERO(&data, sizeof(data));
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_BUF_LOGCC(&data.period[0], 3, "class8_invoke_get_payment_para data.period:");
            PRTL_BUF_LOGCC(&data.info[0], data.nLen, "class8_invoke_get_payment_para data.info:");

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_keep_value
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_keep_value(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81000200:
        {
            int64 data;
            MEMZERO(&data, sizeof(data));
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                data = 99900000000LL;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_keep_value data: %d\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_powcon_time
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_powcon_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81010200:
        {
            uint32 i = 0;
            OOP_POWCON_TIME_T data;
            MEMZERO(&data, sizeof(data));
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen = 6;
                return DATA_SUCCESS;
            }

            for (i = 0; i < 12; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_get_powcon_time : data[%d] = %d\n", i, data.period[i]);
            }


            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_powcon_warn
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_powcon_warn(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81020200:
        {
            uint32 i = 0;
            OOP_POWCON_WARNING_T data;
            MEMZERO(&data, sizeof(data));
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x01;
                outData->pResultData[offset ++] = 0x00;
                outData->resultDataLen = 6;
                return DATA_SUCCESS;
            }

            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_get_powcon_time : data[%d] = %d\n", i, data.time[i]);
            }


            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_power_value
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_power_value(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81100200:
        {
            int64 data;
            MEMZERO(&data, sizeof(data));
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_power_value : data[%d] = %d\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_get_gdk_config
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_gdk_config(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;   

    MEMZERO(&convert, sizeof(convert)); 

    //读出数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x810c0200:
        {
            OOP_CFGUNIT_810C_T data;
            MEMZERO(&data, sizeof(data));
            normal.oad.value = pOadInfo->pTab->oad.value;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            PRTL_FMT_LOGCC("class8_invoke_get_gdk_config : data[%d] = %d\n", data);

            //转换成报文数据
            convert.srcBuf = &data;
            convert.srcLen = sizeof(data);
            convert.sOffset = &sOffset;
            
            convert.dstBuf = &outData->pResultData[5];
            convert.dstLen = outDataMax;
            convert.dOffset = &outData->resultDataLen;
        }
        break;
    
    default:
        break;
    }
    
    /* 数据和报文转换 */
    dar = data_to_buf_class8(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("data_to_buf_class8 failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    /* 填写报文开头处的OAD和数据结果0x01*/
    memcpy(outData->pResultData, inData, sizeof(OOP_OAD_U));
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x01;
    outData->resultDataLen += offset;

    return dar;
}


/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_80(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x8000:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_yk_config(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x03:
                {
                    //return class8_invoke_get_security_mod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;  
            case 0x04:
                {
                    sleep(2); //延时2s操作
                    return class8_invoke_get_ykalarm_state(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x05:
                {
                    sleep(2); //延时2s操作
                    return class8_invoke_get_ykcmd_state(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;       
            default:
                break;
            }
            
        }
        break;
    case 0x8001:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    sleep(2); //延时2s操作
                    return class8_invoke_get_guard_state(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x03:
            case 0x04:
                {
                    return class8_invoke_get_guard_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;  
            case 0x05:
                {
                    return class8_invoke_get_auto_guard_interval(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;      
            default:
                break;
            }
            
        }
        break;
    case 0x8002:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    sleep(2); //延时2s操作
                    return class8_invoke_get_payment_state(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x03:
                {
                    return class8_invoke_get_payment_para(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;            
            default:
                break;
            }
        }
        break;
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get_oia_81(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x8100:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_keep_value(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;     
            default:
                break;
            }
            
        }
        break;
    case 0x8101:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_powcon_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;     
            default:
                break;
            }
            
        }
    case 0x8102:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_powcon_warn(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;     
            default:
                break;
            }
            
        }
        break;
    case 0x810c:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_gdk_config(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;     
            default:
                break;
            }
            
        }
        break;
    case 0x8110:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_get_power_value(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;     
            default:
                break;
            }
            
        }
        break;
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @brief：      设置时间
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DATETIME_S_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //时间
    dar = basic_buf_to_data(E_DATETIME_S, srcBuf, srcLen, &sOffset, &data, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      设置时间
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_sys_update(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYS_UPDATE_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //升级后版本
    dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.sysVersion, sizeof(OOP_VISIBLEVAR_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.updateType, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        return DATA_READ_WRITE_DENIED;
    }
    if(srcBuf[sOffset++] != 6)
    {
        return DATA_READ_WRITE_DENIED;
    }
    dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.fileinfo.name, sizeof(data.fileinfo.name));
    if (dar != DATA_SUCCESS)
    {
        return DATA_READ_WRITE_DENIED;
    }
    dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.fileinfo.type, sizeof(data.fileinfo.name));
    if (dar != DATA_SUCCESS)
    {
        return DATA_READ_WRITE_DENIED;
    }
    dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.fileinfo.path, sizeof(data.fileinfo.path));
    if (dar != DATA_SUCCESS)
    {
        return DATA_READ_WRITE_DENIED;
    }
    dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.fileinfo.size, sizeof(data.fileinfo.size));
    if (dar != DATA_SUCCESS)
    {
        return DATA_READ_WRITE_DENIED;
    }
    
    uint8 checktype = srcBuf[sOffset];
    PRTL_FMT_DEBUG("校验类型%d\n", checktype);
    if(checktype == DT_CHECKSUM)
    {
        dar = basic_buf_to_data(E_CHECKSUM, srcBuf, srcLen,&sOffset, &data.fileinfo.checkcode.checksum, sizeof(data.fileinfo.checkcode.checksum));
        if (dar != DATA_SUCCESS)
        {
            return DATA_READ_WRITE_DENIED;
        }
        PRTL_BUF_DEBUG(data.fileinfo.checkcode.checksum.checkcode.value, data.fileinfo.checkcode.checksum.checkcode.nNum,"校验值：\n");
    }
    else
    {
        dar = basic_buf_to_data(E_OCTET_STRING, srcBuf, srcLen,&sOffset, &data.fileinfo.checkcode.md5, sizeof(data.fileinfo.checkcode.md5));
        if (dar != DATA_SUCCESS)
        {
            return DATA_READ_WRITE_DENIED;
        }
        PRTL_BUF_DEBUG(data.fileinfo.checkcode.md5.value, data.fileinfo.checkcode.md5.nNum,"校验值：\n");
    }
    data.fileinfo.checkcode.choice = checktype;
    
    uint8 tmpoffset = sOffset;
    if(srcBuf[tmpoffset]==DT_STRUCTURE)
    {
        sOffset++;
        if(srcBuf[sOffset++] != 4)
        {
            return DATA_READ_WRITE_DENIED;
        }
        dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.fileinfo.sign.name, sizeof(data.fileinfo.sign.name));
        if (dar != DATA_SUCCESS)
        {
            return DATA_READ_WRITE_DENIED;
        }
        dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.fileinfo.sign.path, sizeof(data.fileinfo.sign.path));
        if (dar != DATA_SUCCESS)
        {
            return DATA_READ_WRITE_DENIED;
        }
        dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.fileinfo.sign.size, sizeof(data.fileinfo.sign.size));
        if (dar != DATA_SUCCESS)
        {
            return DATA_READ_WRITE_DENIED;
        }
//        dar = basic_buf_to_data(E_OCTET_STRING, srcBuf, srcLen, &sOffset, &data.fileinfo.sign.md5, sizeof(data.fileinfo.sign.md5));
//        if (dar != DATA_SUCCESS)
//        {
//            return DATA_READ_WRITE_DENIED;
//        }
        
        checktype = srcBuf[sOffset];
        PRTL_FMT_DEBUG("校验类型%d\n", checktype);
        if(checktype == DT_CHECKSUM)
        {
            dar = basic_buf_to_data(E_CHECKSUM, srcBuf, srcLen,&sOffset, &data.fileinfo.sign.checkcode.checksum, sizeof(data.fileinfo.sign.checkcode.checksum));
            if (dar != DATA_SUCCESS)
            {
                return DATA_READ_WRITE_DENIED;
            }
            PRTL_BUF_DEBUG(data.fileinfo.sign.checkcode.checksum.checkcode.value, data.fileinfo.sign.checkcode.checksum.checkcode.nNum,"校验值：\n");
        }
        else
        {
            dar = basic_buf_to_data(E_OCTET_STRING, srcBuf, srcLen,&sOffset, &data.fileinfo.sign.checkcode.md5, sizeof(data.fileinfo.sign.checkcode.md5));
            if (dar != DATA_SUCCESS)
            {
                return DATA_READ_WRITE_DENIED;
            }
            PRTL_BUF_DEBUG(data.fileinfo.sign.checkcode.md5.value, data.fileinfo.sign.checkcode.md5.nNum,"校验值：\n");
        }
        data.fileinfo.sign.checkcode.choice = checktype;
    }else if(srcBuf[tmpoffset]==DT_NULL)
        {
        sOffset++;
    }else {
        return DATA_READ_WRITE_DENIED;
    }
    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     遥控跳闸参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_telecon_trip(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TELECON_TRIP_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 4)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //继电器序号
        dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.trip[i].nRelayIdx.value, sizeof(OOP_OAD_U));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }   
        //告警延时
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.trip[i].nWarnDelay, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }   
        //限电时间
        dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.trip[i].nTripTime, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 
        //自动合闸
        dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.trip[i].bAutoClose, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }   
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}

/**
*********************************************************************
* @brief：     遥控跳闸参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_telecon_close(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TELECON_CLOSE_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //继电器序号
        dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.close[i].nRelayIdx, sizeof(OOP_OAD_U));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }   
        //告警延时
        dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.close[i].nState, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }    
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}

/**
*********************************************************************
* @name：      buf_to_data_class8_payment_on
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_payment_on(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CALLFEE_T data;
    OOP_VISIBLEVAR1K_T visbleData;
    OOP_OCTETSTR32_T octetStr;
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //告警时段
    dar = basic_buf_to_data(E_OCTET_STR3_T, srcBuf, srcLen, &sOffset, &octetStr, sizeof(OOP_OCTETSTR32_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   
    memcpy(&data.period[0], &octetStr.nValue[0], 3);

    //告警信息
    dar = basic_buf_to_data(E_VISIBLE_STRING, srcBuf, srcLen, &sOffset, &visbleData, sizeof(visbleData));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    memcpy(&data.info[0], &visbleData.value[0], visbleData.nNum);
    data.nLen = visbleData.nNum;   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}

/**
*********************************************************************
* @name：      buf_to_data_class8_clear_scuritymod
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_clear_scuritymod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data;
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //告警时段
    dar = basic_buf_to_data(E_INTEGER, srcBuf, srcLen, &sOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}

/**
*********************************************************************
* @brief：     增加显式安全模式参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_add_scuritymod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    SECURITYMODE data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //对象标识
    dar = basic_buf_to_data(E_OI, srcBuf, srcLen, &sOffset, &data.object, sizeof(OI));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //权限
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.access, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }      

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.object = 0x%04x\n", data.object);
    PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.access = 0x%04x\n", data.access);
     
    return dar;
}

/**
*********************************************************************
* @brief：     删除显式安全模式参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_del_scuritymod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OI data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //对象标识
    dar = basic_buf_to_data(E_OI, srcBuf, srcLen, &sOffset, &data, sizeof(OI));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.object = 0x%04x\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：     批量增加显式安全模式参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_add_scuritymod_list(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SCURITYMODE_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }  
        
        //对象标识
        dar = basic_buf_to_data(E_OI, srcBuf, srcLen, &sOffset, &data.mode[i].object, sizeof(OI));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        
        //权限
        dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.mode[i].access, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }      
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.nNum = %d\n", data.nNum);
    for (i = 0; i < data.nNum; i++)
    {
        PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.mode[%d].object = 0x%04x\n", i, data.mode[i].object);
        PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.mode[%d].access = 0x%04x\n", i, data.mode[i].access);
    }
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置钱包文件
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_wallet(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DWORD2_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nValue1, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nValue2, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      设置校时模式
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_timing_mod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //校时模式
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_flag : data = 0x%x\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置精确对时参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_time_precise(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYNCCLOCK_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 5)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //最近心跳时间总个数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nSum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //最大值剔除个数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nMaxDelNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //最小值剔除个数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nMinDelNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    //通讯延时阈值
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nDelay, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    //最少有效个数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nValidNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置精确对时参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_sync_cycle(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYNCCYCLE_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //北向同步周期
    dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.norperiod, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //南向同步周期
    dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.souperiod, sizeof(uint32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }


    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, 
                        dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：     设置终端地址
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_addr_octet(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_OCTETVAR16_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //地址
    dar = basic_buf_to_data(E_OOP_OCTETVAR16_T, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     地理坐标 报文中解析出子结构体
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_postion(const OAD_INFO_T *pOdaInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    int32 nRet = ERR_NORMAL;
    uint32  offset = *pOffset;
    POSITION_ data = {0};
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if(srcBufTmp[offset++] != DT_STRUCTURE)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }

    //结构成员数
    if(srcBufTmp[offset++] != 4)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
        
    //方位     经度:{0：E,1：W}   纬度:{0：S,1：N}
    if(basic_buf_to_data(E_ENUM, srcBufTmp, srcLen-offset, &offset, &data.position, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }

    //度
    if(basic_buf_to_data(E_UNSIGNED, srcBufTmp, srcLen-offset, &offset, &data.degre, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }  

    //分
    if(basic_buf_to_data(E_UNSIGNED, srcBufTmp, srcLen-offset, &offset, &data.branch, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }   

    //秒
    if(basic_buf_to_data(E_UNSIGNED, srcBufTmp, srcLen-offset, &offset, &data.second, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }      

    memcpy(dstData, &data, dstLen);
    *pOffset = offset;
     
    return ERR_OK;
}

/**
*********************************************************************
* @brief：     地理坐标 报文中解析出子结构体
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_postion_new(const OAD_INFO_T *pOdaInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, 
void *dstData, uint32 dstLen)
{
    int32 nRet = ERR_NORMAL;
    uint32  offset = *pOffset;
    POSITION_NEW data = {0};
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if(srcBufTmp[offset++] != DT_STRUCTURE)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }

    //结构成员数
    if(srcBufTmp[offset++] != 3)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }
        
    //方位     经度:{0：E,1：W}   纬度:{0：S,1：N}
    if(basic_buf_to_data(E_ENUM, srcBufTmp, srcLen-offset, &offset, &data.position, sizeof(uint8)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }

    //度
    if(basic_buf_to_data(E_LONG_UNSIGNED, srcBufTmp, srcLen-offset, &offset, &data.degre, sizeof(uint16)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }  

    //分
    if(basic_buf_to_data(E_FLOAT32, srcBufTmp, srcLen-offset, &offset, &data.branch, sizeof(float32)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }    

    memcpy(dstData, &data, dstLen);
    *pOffset = offset;
     
    return ERR_OK;
}

/**
*********************************************************************
* @brief：     设置终端地址
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_coordinates(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_GEOGADD_A_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //判断协议类型
    if(3 == srcBuf[sOffset + 1])
    {
        data.type = 1;

        //经度
        dar = buf_to_data_postion_new(pOadInfo, srcBuf, srcLen, &sOffset, &data.newaddr.longitude, sizeof(POSITION_NEW));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //经度
        dar = buf_to_data_postion_new(pOadInfo, srcBuf, srcLen, &sOffset, &data.newaddr.latitude, sizeof(POSITION_NEW));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //高度
        dar = basic_buf_to_data(E_DOUBLE_LONG, srcBuf, srcLen, &sOffset, &data.newaddr.height, sizeof(int));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
    }
    else
    {
        data.type = 0;
        //经度
        dar = buf_to_data_postion(pOadInfo, srcBuf, srcLen, &sOffset, &data.oldaddr.longitude, sizeof(POSITION_));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        
        //纬度
        dar = buf_to_data_postion(pOadInfo, srcBuf, srcLen, &sOffset, &data.oldaddr.latitude, sizeof(POSITION_));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //高度
        dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.oldaddr.height, sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
    }
    
    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);
    
    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置终端组地址
* @param[in]： ppOadInfo    - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf       - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：    =0           - 成功
               !=0          - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_group_addr(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_GRPADDR_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //冻结周期
        dar = basic_buf_to_data(E_OOP_SA_T, srcBuf, srcLen, &sOffset, &data.sa[i], sizeof(data.sa[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }       
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      时区时段数
* @param[in]： ppOadInfo    - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf       - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：    =0           - 成功
               !=0          - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_time_region(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PERIOD_T data = {0};
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 5)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //年时区数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.yPeriod, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //日时段表数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.dPeriodMet, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //日时段数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.dPeriod, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //费率数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.rate, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //公共假日数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.pubHoliday, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     当前套时区表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_time_zone_all(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TIMEZONE_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        
        //结构成员数
        if(srcBuf[sOffset++] != 3)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }  
        
        //月
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[i].mon, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 

        //日
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[i].day, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }     

        //日时段表号
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[i].meterNum, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }           
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     当前套时区表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_time_zone_one(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    TIMEZONE data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //月
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.mon, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    } 

    //日
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.day, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    //日时段表号
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.meterNum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }           

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     当前套时区表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_time_zone(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    if (pOadInfo->nIndex == 0)
    {
        return buf_to_data_class8_time_zone_all(pOadInfo, convert);
    }
    else
    {
        return buf_to_data_class8_time_zone_one(pOadInfo, convert);
    }
}

/**
*********************************************************************
* @brief：     当前套日时段表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_day_period_all(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_DAYPERIOD_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {   
        //数组类型
        if(srcBuf[sOffset++] != DT_ARRAY)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //数组成员个数
        data.dPeriod[i].nNum = get_len_offset(&srcBuf[sOffset], &offlen);
        sOffset += offlen;

        for(j = 0; j < data.dPeriod[i].nNum; j++)
        {
            //结构类型
            if(srcBuf[sOffset++] != DT_STRUCTURE)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
                return DATA_TYPE_UNMATCHED;
            }

            //结构成员数
            if(srcBuf[sOffset++] != 3)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
                return DATA_TYPE_UNMATCHED;
            }  

            //时
            dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.dPeriod[i].period[j].hour, sizeof(uint8));
            if(dar != DATA_SUCCESS)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
                return DATA_TYPE_UNMATCHED;
            } 

            //分
            dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.dPeriod[i].period[j].min, sizeof(uint8));
            if(dar != DATA_SUCCESS)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
                return DATA_TYPE_UNMATCHED;
            } 

            //秒
            dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.dPeriod[i].period[j].rateNO, sizeof(uint8));
            if(dar != DATA_SUCCESS)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
                return DATA_TYPE_UNMATCHED;
            } 
        }     
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     当前套日时段表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_day_period_one(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    DAYPERIOD data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(j = 0; j < data.nNum; j++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 3)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }  

        //时
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[j].hour, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 

        //分
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[j].min, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 

        //秒
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[j].rateNO, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     当前套日时段表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_day_period(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    if (pOadInfo->nIndex == 0)
    {
        return buf_to_data_class8_day_period_all(pOadInfo, convert);
    }
    else
    {
        return buf_to_data_class8_day_period_one(pOadInfo, convert);
    }
}

/**
*********************************************************************
* @brief：     设置当前套费率电价
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_rate_tariff(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_RATETARIFF_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    if(data.nNum > OOP_MAX_RATES)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array num failed. sOffset(%d)", sOffset);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }

    for(i = 0; i < data.nNum; i++)
    {     
        //权限
        dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.nValue[i], sizeof(uint32));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }      
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置剔除功能
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_reject_from_group(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //是否剔除
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }      

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置电压合格率参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_volt_rate(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VOLTPARAM_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 4)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //电压考核上限
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.uupVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //电压考核下限
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.lldVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //电压合格上限
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.upVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    //电压合格下限
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.ldVolt, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      设置电流回路监测使能参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_curloop_monitor(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CURLOOPCKENABLE_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //A相使能
    dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.phaseA, sizeof(BOOLEAN));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), phaseA(%d)\n", dar, data.phaseA);
        return DATA_TYPE_UNMATCHED;
    }
    
    //B相使能
    dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.phaseB, sizeof(BOOLEAN));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), phaseB(%d)\n", dar, data.phaseB);
        return DATA_TYPE_UNMATCHED;
    }

    //C相使能
    dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.phaseC, sizeof(BOOLEAN));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), phaseC(%d)\n", dar, data.phaseC);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      最大需量周期
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_demand_max(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //校时模式
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_demand_max : data = 0x%x\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：      滑差时间
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_slip_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //校时模式
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_demand_max : data = 0x%x\n", data);
     
    return dar;
}


/**
*********************************************************************
* @brief：     资产设备管理编码
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_asset_no(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLEVAR32_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //高度
    dar = basic_buf_to_data(E_OOP_VISIBLEVAR32_T, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     组合特征字
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_combine_word(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_BITSTR8_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //特征字
    dar = basic_buf_to_data(E_OOP_BITSTR8_T, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     认证密码
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_authentication_code(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLEVAR32_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //认证密码
    dar = basic_buf_to_data(E_OOP_VISIBLEVAR32_T, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     认证密码
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_vol(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLESTR6_T data = {0};
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //认证密码
    dar = basic_buf_to_data(E_OOP_VISIBLESTR6_T, srcBuf, srcLen, &sOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }     

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     级联通讯数据
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_cascade(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_CASCADE_T data;
    uint32 i = 0;
    uint32 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    uint32 nNum   = 0;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 8)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    } 

    //级联标记
    dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.flag, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //端口号
    dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.port, sizeof(OOP_OAD_U));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //超时
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.tdelay, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //字节超时
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.bdelay, sizeof(OOP_VISIBLEVAR_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    //重发次数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.retry, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }      

    //巡测周期
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.cycle, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    //端口数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.casnum, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    } 

    //结构类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组数量
    nNum = srcBuf[sOffset++];

    for (j = 0; j < nNum; j++)
    { 
        //地址
        dar = basic_buf_to_data(E_TSA, srcBuf, srcLen, &sOffset, &data.addr[i], sizeof(OOP_TSA_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     广播校时参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_broadcast_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SYNCTIME_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //冻结周期
    dar = basic_buf_to_data(E_TIME, srcBuf, srcLen, &sOffset, &data.time, sizeof(data.time));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //关联对象属性
    dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.bValid, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     广播校时参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_p2p_broadcast_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_P2PSYNCTIME_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    uint8 timeflag =1;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //冻结周期
    dar = basic_buf_to_data(E_INTEGER, srcBuf, srcLen, &sOffset, &data.offset, sizeof(data.offset));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //冻结周期
    if(srcBuf[sOffset++] == DT_NULL)
    {
        timeflag = 0;
    }
    else
    {
        dar = basic_buf_to_data(E_TIME, srcBuf, srcLen, &sOffset, &data.time, sizeof(data.time));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
    }
    
    //关联对象属性
    dar = basic_buf_to_data(E_BOOL, srcBuf, srcLen, &sOffset, &data.bValid, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    if(timeflag == 0)
    {
        data.bValid = 0;
    }
    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     公网远程通信多接入点备用通道
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_gprs_apn_res(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_APNGROUP_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint32 i = 0;
    uint32 j = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;
    uint32 len    = 0;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if (srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for (i = 0; i < data.nNum; i++)
    { 
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 8)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        } 

        //运营商代码
        dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.net[i].factory, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        
        //网络类型代码
        dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.net[i].network, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //APN
        dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.net[i].apn.apn, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }  

        //APN用户名
        dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.net[i].apn.username, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }      

        //APN密码
        dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.net[i].apn.pwd, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }  

        //代理服务器地址
        if (srcBuf[sOffset++] != DT_OCTET_STRING)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        len = srcBuf[sOffset++];
        if (len > 4)
        {
            return DATA_SCOPE_OF_ACCESS_VIOLATED;
        }   
        memcpy(&data.net[i].apn.proxyip[0], &srcBuf[sOffset], len);
        sOffset += len;

        //代理服务器端口
        dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.net[i].apn.proxyport, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        } 

        //结构类型
        if(srcBuf[sOffset++] != DT_ARRAY)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //数组数量
        data.net[i].master.nNum = srcBuf[sOffset++];

        for (j = 0; j < data.net[i].master.nNum; j++)
        {
            //结构类型
            if(srcBuf[sOffset++] != DT_STRUCTURE)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
                return DATA_TYPE_UNMATCHED;
            }

            //结构成员数
            if(srcBuf[sOffset++] != 2)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
                return DATA_TYPE_UNMATCHED;
            }
            
            //IP
            if (srcBuf[sOffset++] != DT_OCTET_STRING)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
                return DATA_TYPE_UNMATCHED;
            }
            len = srcBuf[sOffset++];
            if (len > 4)
            {
                return DATA_SCOPE_OF_ACCESS_VIOLATED;
            }  
            memcpy(&data.net[i].master.master[j].ip[0], &srcBuf[sOffset], len);
            sOffset += len;

            //端口
            dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.net[i].master.master[j].port, sizeof(uint16));
            if(dar != DATA_SUCCESS)
            {
                PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
                return DATA_TYPE_UNMATCHED;
            } 
        }
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}


/**
*********************************************************************
* @brief：      设置安全模式
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_security_flag(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SECURITYFLAG_E data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //开关量属性标志
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data, sizeof(OOP_SECURITYFLAG_E));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_flag : data = 0x%x\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：     设置显式安全模式参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_security_mod(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_SCURITYMODE_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }  
        
        //对象标识
        dar = basic_buf_to_data(E_OI, srcBuf, srcLen, &sOffset, &data.mode[i].object, sizeof(OI));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        
        //权限
        dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.mode[i].access, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }      
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.nNum = %d\n", data.nNum);
    for (i = 0; i < data.nNum; i++)
    {
        PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.mode[%d].object = 0x%04x\n", i, data.mode[i].object);
        PRTL_FMT_LOGCC("buf_to_data_class8_security_mod : data.mode[%d].access = 0x%04x\n", i, data.mode[i].access);
    }
     
    return dar;
}

/**
*********************************************************************
* @brief：     遥控配置参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_yk_config(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_TELECON_PARAM_T data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }  
    
    //继电器拉闸电流门限值
    dar = basic_buf_to_data(E_DOUBLE_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.limit, sizeof(int32));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //超电流门限保护延时时间
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data.delay, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_yk_config : data.limit = %d\n", data.limit);
    PRTL_FMT_LOGCC("buf_to_data_class8_yk_config : data.delay = %d\n", data.delay);
     
    return dar;
}

/**
*********************************************************************
* @brief：     允许与主站最大无通信时长
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_no_comm_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint16 data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //允许与主站最大无通信时长
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_no_comm_time : data = %d\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：     上电自动保电时长
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_power_on_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint16 data;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //上电自动保电时长
    dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBuf, srcLen, &sOffset, &data, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_no_comm_time : data = %d\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：     自动保电时段
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_prt_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PRTTIME_T data;
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //数组类型
    if (srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }  
        
        //起始时间
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.item[i].start, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }
        
        //结束时间
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.item[i].end, sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }  
    } 

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     自动保电时段
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_keep_value(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    int64 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 
        
    //保安定值
    dar = basic_buf_to_data(E_LONG64, srcBuf, srcLen, &sOffset, &data, sizeof(int64));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     终端功控时段
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_powcon_time(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_POWCON_TIME_T data;
    uint32 num = 0;
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    num = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;
    if (num != 12)
    {
        PRTL_FMT_DEBUG("get_len_offset failed. num = %d", num);
        return DATA_TYPE_UNMATCHED;
    }
    for(i = 0; i < num; i++)
    {    
        //对象标识
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.period[i], sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }    
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     功控告警时间
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_powcon_warn(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_POWCON_WARNING_T data;
    uint8 offlen = 0;      //数组数量长度
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;
    if(data.nNum > OOP_MAX_TURN)
    {
        PRTL_FMT_DEBUG("数组越界\n");
        return DATA_SCOPE_OF_ACCESS_VIOLATED;
    }
    for(i = 0; i < data.nNum; i++)
    {    
        //时间
        dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.time[i], sizeof(uint8));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }    
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     电控定值
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_power_value(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    int64 data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data)); 
        
    //保安定值
    dar = basic_buf_to_data(E_LONG64, srcBuf, srcLen, &sOffset, &data, sizeof(int64));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     buf_to_data_class19_set_inner_factory_code
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_set_inner_factory_code(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_VISIBLESTR4_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //厂商代码
    dar = basic_buf_to_data(E_OOP_VISIBLESTR4_T, srcBuf, srcLen, &sOffset, &data, sizeof(OOP_VISIBLESTR4_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_BUF_TRACE(&data.value[0], 8, "buf_to_data_class19_set_inner_factory_code szFactory:");

    return dar;
}

/**
*********************************************************************
* @brief：     buf_to_data_class8_set_inner_app_id
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_set_inner_app_id(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_INNER_APP_ID_LIST_T data = {0};
    uint8 offlen = 0;      //数组数量长度
    uint32 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    //数组类型
    if(srcBuf[sOffset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check array type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBuf[sOffset], &offlen);
    sOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBuf[sOffset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBuf[sOffset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
            return DATA_TYPE_UNMATCHED;
        }

        //组件名称
        dar = basic_buf_to_data(E_OOP_VISIBLEVAR_T, srcBuf, srcLen, &sOffset, &data.innerAppID[i].appName, sizeof(OOP_VISIBLEVAR_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
            return DATA_TYPE_UNMATCHED;
        } 

        //APP_ID
        dar = basic_buf_to_data(E_OOP_OCTETVAR256_T, srcBuf, srcLen, &sOffset, &data.innerAppID[i].appID, sizeof(OOP_OCTETVAR256_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_buf_to_data failed. dar(%d), offset(%d)\n", dar, sOffset);
            return DATA_TYPE_UNMATCHED;
        }  
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    return dar;
}

/**
*********************************************************************
* @brief：      SAL 安全应用数据链路层参数
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_security_sal(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    uint8 data = 0;
    uint8 i = 0;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));

    
    //开关量属性标志
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. [%d] dar(%d), sOffset(%d)\n", i, dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }   

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;

    PRTL_FMT_LOGCC("buf_to_data_class8_security_sal : data = 0x%x\n", data);
     
    return dar;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(class22)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_set(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x202c0200:   //钱包文件
        {
            return buf_to_data_class8_wallet(pOadInfo,  convert);
        }break;

        case 0x40000200:   //设置时间
        case 0x40080200:   //备用套时区表切换时间
        case 0x40090200:   //备用套时区表切换时间
        case 0x400A0200:   //备用套时区表切换时间
        case 0xFFF00600:
        {
            return buf_to_data_class8_time(pOadInfo,  convert);
        }break;

        case 0x40000300:   //设置校时模式
        {
            return buf_to_data_class8_timing_mod(pOadInfo,  convert);
        }break;

        case 0x40000400:   //精度校时
        {
            return buf_to_data_class8_time_precise(pOadInfo,  convert);
        }break;

        case 0x40000600:   //时间同步周期
        {
            return buf_to_data_class8_sync_cycle(pOadInfo,  convert);
        }break;

        case 0x40030200:
        case 0x40020200:
        case 0x40010200:   //终端地址
        {
            return buf_to_data_class8_addr_octet(pOadInfo,  convert);
        }break;
        
        case 0x40040200:   //地理坐标
        {
            return buf_to_data_class8_coordinates(pOadInfo,  convert);
        }break;

        case 0x40050200:   //组地址
        {
            return buf_to_data_class8_group_addr(pOadInfo,  convert);
        }break;

        case 0x400C0200:   //时段时区数
        {
            return buf_to_data_class8_time_region(pOadInfo,  convert);
        }break;
        
        case 0x40140200:   //当前套时区表
        case 0x40150200:   //备用套时区表
        {
            return buf_to_data_class8_time_zone(pOadInfo,  convert);
        }break;

        case 0x40160200:   //当前套日时段表
        case 0x40170200:   //当前套日时段表
        {
            return buf_to_data_class8_day_period(pOadInfo,  convert);
        }break;

        case 0x40180200:   //当前套费率电价
        case 0x40190200:   //当前套费率电价
        {
            return buf_to_data_class8_rate_tariff(pOadInfo,  convert);
        }break;

        case 0x40240200:   //剔除
        {
            return buf_to_data_class8_reject_from_group(pOadInfo,  convert);
        }break;

        case 0x40300200:   //电压合格率
        {
            return buf_to_data_class8_volt_rate(pOadInfo,  convert);
        }break;

        case 0x40410200:   //电流回路监测使能
        {
            return buf_to_data_class8_curloop_monitor(pOadInfo,  convert);
        }break;        

        case 0x41000200:   //需量周期
        {
            return buf_to_data_class8_demand_max(pOadInfo,  convert);
        }break;
        
        case 0x41010200:   //滑差时间
        {
            return buf_to_data_class8_slip_time(pOadInfo,  convert);
        }break;
        
        case 0x41030200:   //设备资产管理编码
        {
            return buf_to_data_class8_asset_no(pOadInfo,  convert);
        }break;

        case 0x41040200:   //额定电压
        {
            return buf_to_data_class8_vol(pOadInfo,  convert);
        }break;

        case 0x41120200:   //组合特征字
        case 0x41130200:   //组合特征字
        case 0x41140200:   //组合特征字
        {
            return buf_to_data_class8_combine_word(pOadInfo,  convert);
        }break;
        
        case 0x42020200:   //级联参数
        {
            return buf_to_data_class8_cascade(pOadInfo,  convert);
        }break;

        case 0x42040200:   //广播校时
        {
            return buf_to_data_class8_broadcast_time(pOadInfo,  convert);
        }break;

        case 0x42040300:   //广播校时
        {
            return buf_to_data_class8_p2p_broadcast_time(pOadInfo,  convert);
        }break;

        case 0x44010200:   //认证密码
        {
            return buf_to_data_class8_authentication_code(pOadInfo,  convert);
        }break;

        case 0x45200200:   //公网远程通信多接入点备用通道
        {
            return buf_to_data_class8_gprs_apn_res(pOadInfo,  convert);
        }break;

        case 0x80000200:   //遥控配置参数
        {
            return buf_to_data_class8_yk_config(pOadInfo,  convert);
        }break;

        case 0x80010300:   //允许与主站最大无通信时长
        {
            return buf_to_data_class8_no_comm_time(pOadInfo,  convert);
        }break;

        case 0x80010400:   //允许与主站最大无通信时长
        {
            return buf_to_data_class8_power_on_time(pOadInfo,  convert);
        }break;

        case 0x80010500:   //允许与主站最大无通信时长
        {
            return buf_to_data_class8_prt_time(pOadInfo,  convert);
        }break;

        case 0x81000200:   //允许与主站最大无通信时长
        {
            return buf_to_data_class8_keep_value(pOadInfo,  convert);
        }break;

        case 0x81010200:   //终端功控时段
        {
            return buf_to_data_class8_powcon_time(pOadInfo,  convert);
        }break;

        case 0x81020200:   //功控告警时间
        {
            return buf_to_data_class8_powcon_warn(pOadInfo,  convert);
        }break;

        case 0x81100200:   //功控告警时间
        {
            return buf_to_data_class8_power_value(pOadInfo,  convert);
        }break;

        case 0xf1010200:   //设置安全模式
        {
            return buf_to_data_class8_security_flag(pOadInfo,  convert);
        }break;

        case 0xf1010300:   //设置显式安全模式参数
        {
            return buf_to_data_class8_security_mod(pOadInfo,  convert);
        }break;
        case 0xf1010400:   //SAL 安全应用数据链路层参数
        {
            return buf_to_data_class8_security_sal(pOadInfo,  convert);
        }break;
#ifdef AREA_HUNAN
        case 0x60E10200:   //温湿度传感器
        case 0x60E20200:   //烟雾传感器
        case 0x60E30200:   //水浸传感器
        case 0x60E40200:   //变压器桩头温度传感器
        {
            return buf_to_data_class8_sensor_param(pOadInfo,  convert);
        }break;
#endif
        default:
        {
            return DATA_READ_WRITE_DENIED;
        }break;
    }

    return DATA_SUCCESS;
}

/**
*********************************************************************
* @name：      class8_invoke_set_wallet
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_wallet(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x202c0200:
        {
            OOP_DWORD2_T dataSet;
            memcpy(&dataSet, convert.dstBuf, dOffset);
            normal.oad.value = 0x202c0200;
            PRTL_FMT_LOGCC("class8_invoke_get_wallet : dataSet.nValue1[%d], dataSet.nValue1[%d]\n", dataSet.nValue1, dataSet.nValue1);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataSet, sizeof(OOP_DWORD2_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_security_flag
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40000200:
        {
            uint32 offset = 0;
            OOP_DATETIME_S_T data = {0};
            DateTimeHex_t dateHex ;
            memset(&dateHex,0,sizeof(DateTimeHex_t));
            
            time_t timep;
            time(&timep);
            OOP_DATETIME_S_T curData = {0};
            DT_Time2DateTimeShort(timep, &curData);
            
            memcpy(&data, convert.dstBuf, dOffset);
            PRTL_FMT_LOGCC("class8_invoke_set_time : curData.year = %hu\n", curData.year);
            PRTL_FMT_LOGCC("class8_invoke_set_time : curData.month = %d\n", curData.month);
            PRTL_FMT_LOGCC("class8_invoke_set_time : curData.day = %d\n", curData.day);
            PRTL_FMT_LOGCC("class8_invoke_set_time : curData.hour = %d\n", curData.hour);
            PRTL_FMT_LOGCC("class8_invoke_set_time : curData.minute = %d\n", curData.minute);
            PRTL_FMT_LOGCC("class8_invoke_set_time : curData.second = %d\n", curData.second);
            datetime_s_data_to_buf(data, &offset, (uint8 *)&dateHex);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.year = 0x%02x\n", dateHex.year_h);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.year = 0x%02x\n", dateHex.year_l);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.month = %d\n", dateHex.month);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.day = %d\n", dateHex.day);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.hour = %d\n", dateHex.hour);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.minute = %d\n", dateHex.min);
            PRTL_FMT_LOGCC("class8_invoke_set_time : dateHex.second = %d\n", dateHex.sec);

            if ((dateHex.month > 12) 
                ||(dateHex.day > 31)
                ||(dateHex.month == 2 && dateHex.day > 29)
                ||(dateHex.hour > 23)
                ||(dateHex.min > 59)
                ||(dateHex.sec > 59))
            {
                return DATA_SCOPE_OF_ACCESS_VIOLATED;
            }

            if(FALSE == systime_set((DateTimeHex_t*)&dateHex))
            {
                return DATA_SCOPE_OF_ACCESS_VIOLATED;
            }

            sta_time_update_fset(TRUE);

            CheckERC_3114(pApduInfo->hUdp, curData, data); 

            //取消高级APP规约给交采模块对时功能，应该交采APP会根据对时事件触发交采APP对时，功能重复
            // int32     ret = 0;
            // ret = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(OOP_DATETIME_S_T));
            // if (ret != DATA_SUCCESS)
            // {
            //     PRTL_FMT_DEBUG("puAmr_acMeter_set failed. oad(0x%08x). ret[%d]\n", pOadInfo->pTab->oad.value, ret);
            // }          
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_timing_mod
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_timing_mod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40000300:
        {
            uint8 dataSet;
            memcpy(&dataSet, convert.dstBuf, dOffset);
            normal.oad.value = 0x40000300;
            normal.classtag = CLASS_DATA_INIT;
            PRTL_FMT_LOGCC("class8_invoke_set_timing_mod : dataSet = 0x%x\n", dataSet);
            if ((dataSet > 2) && (dataSet != 255))
            {
                return DATA_SCOPE_OF_ACCESS_VIOLATED;
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataSet, sizeof(uint8));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_time_zone_switch
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time_zone_switch(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40080200:
        {
            OOP_DATETIME_S_T dataSet;
            memcpy(&dataSet, convert.dstBuf, dOffset);
            normal.oad.value = 0x40080200;
            normal.classtag = CLASS_DATA_INIT;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataSet, sizeof(dataSet));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &dataSet, sizeof(dataSet));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_day_step_switch
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_day_step_switch(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40090200:
        {
            OOP_DATETIME_S_T dataSet;
            memcpy(&dataSet, convert.dstBuf, dOffset);
            normal.oad.value = 0x40090200;
            normal.classtag = CLASS_DATA_INIT;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataSet, sizeof(dataSet));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &dataSet, sizeof(dataSet));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_min_step_switch
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_min_step_switch(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x400A0200:
        {
            OOP_DATETIME_S_T dataSet;
            memcpy(&dataSet, convert.dstBuf, dOffset);
            normal.oad.value = 0x400A0200;
            normal.classtag = CLASS_DATA_INIT;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataSet, sizeof(dataSet));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &dataSet, sizeof(dataSet));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_time_pricse
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time_pricse(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40000400:
        {
            OOP_SYNCCLOCK_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;
            PRTL_FMT_LOGCC("class8_invoke_set_time_pricse : data.nSum = %d\n", data.nSum);
            PRTL_FMT_LOGCC("class8_invoke_set_time_pricse : data.nMaxDelNum = %d\n", data.nMaxDelNum);
            PRTL_FMT_LOGCC("class8_invoke_set_time_pricse : data.nMinDelNum = %d\n", data.nMinDelNum);
            PRTL_FMT_LOGCC("class8_invoke_set_time_pricse : data.nDelay = %d\n", data.nDelay);
            PRTL_FMT_LOGCC("class8_invoke_set_time_pricse : data.nValidNum = %d\n", data.nValidNum);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_time_pricse
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_sync_cycle(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, 
                                       uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", 
                       dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40000600:
        {
            OOP_SYNCCYCLE_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;
            PRTL_FMT_LOGCC("class8_invoke_set_sync_cycle : data.norperiod = %d\n", data.norperiod);
            PRTL_FMT_LOGCC("class8_invoke_set_sync_cycle : data.souperiod = %d\n", data.souperiod);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
        default: return DATA_OBJECT_UNAVAILABLE;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_set_addr_octet
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_addr_octet(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    normal.oad.value = pOadInfo->pTab->oad.value;

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40020200:
        {
            normal.oad.value = 0x40010200;
        }
    case 0x40010200:
    case 0x40030200:
        {
            OOP_OCTETVAR16_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.classtag = CLASS_DATA_UNINIT;
            PRTL_FMT_LOGCC("class8_invoke_set_addr_octet : data.nNum = %d\n", data.nNum);
            PRTL_BUF_LOGCC(&data.value[0], data.nNum, "class8_invoke_set_addr_octet : data.value:");

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_set_coordinates
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_coordinates(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40040200:
        {
            OOP_GEOGADD_A_T tGPS;
            
            memset(&normal, 0, sizeof(NOMAL_OAD_T));
            memcpy(&tGPS, convert.dstBuf, dOffset);
            normal.oad.value = 0x40040200;
            normal.classtag = CLASS_DATA_INIT;
            
            if((0 == tGPS.type && (tGPS.oldaddr.longitude.position > 1 || tGPS.oldaddr.latitude.position > 1)) ||
               (1 == tGPS.type && (tGPS.newaddr.longitude.position > 1 || tGPS.newaddr.latitude.position > 1)))
            {
                PRTL_FMT_DEBUG("there are only 0 and 1 in longitude and latitude\n");
                return DATA_TIMEFLAG_INVALID;
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&tGPS, sizeof(OOP_GEOGADD_A_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
        default:  return DATA_OBJECT_UNAVAILABLE;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_group_addr
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_group_addr(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40050200:
        {
            uint32 i = 0;
            OOP_GRPADDR_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;

            PRTL_FMT_LOGCC("class8_invoke_set_group_addr : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_BUF_LOGCC(data.sa[i].add, data.sa[i].len, "class8_invoke_set_group_addr : data:");
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_time_region
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time_region(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x400C0200:
        {
            OOP_PERIOD_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_time_zone_all
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time_zone_all(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40140200:
    case 0x40150200:
        {
            uint32 i = 0;
            OOP_TIMEZONE_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_time_zone : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                    PRTL_FMT_LOGCC("class8_invoke_set_time_zone : data.period[%d].mon:%d\n", 
                        i,  data.period[i].mon);
                    PRTL_FMT_LOGCC("class8_invoke_set_time_zone : data.period[%d].day:%d\n", 
                        i, data.period[i].day);
                    PRTL_FMT_LOGCC("class8_invoke_set_time_zone : data.period[%d].meterNum:%d\n", 
                        i, data.period[i].meterNum);
            }

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_time_zone_one
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time_zone_one(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    if ((pOadInfo->nIndex > OOP_MAX_TIMEZONE) || (pOadInfo->nIndex == 0))
    {
        return DATA_OBJECT_UNDEFINED;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40140200:
    case 0x40150200:
        {
            uint32 i = 0;
            uint32 len = 0;
            OOP_TIMEZONE_T dataAll;
            TIMEZONE data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_time_zone_one : data.mon:%d\n", data.mon);
            PRTL_FMT_LOGCC("class8_invoke_set_time_zone_one : data.day:%d\n", data.day);
            PRTL_FMT_LOGCC("class8_invoke_set_time_zone_one : data.meterNum:%d\n", data.meterNum);

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(dataAll), (uint8*)&dataAll, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }

                i = pOadInfo->nIndex - 1;
                memcpy(&dataAll.period[i], &data, sizeof(TIMEZONE));

                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataAll, sizeof(dataAll));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &dataAll, sizeof(dataAll));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }

                i = pOadInfo->nIndex - 1;
                memcpy(&dataAll.period[i], &data, sizeof(TIMEZONE));

                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &dataAll, sizeof(dataAll));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_group_addr
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_time_zone(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    if (pOadInfo->nIndex == 0)
    {
        return class8_invoke_set_time_zone_all(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
    }
    else
    {
        return class8_invoke_set_time_zone_one(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
    }
}

/**
*********************************************************************
* @name：      class8_invoke_set_day_period_all
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_day_period_all(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40160200:
    case 0x40170200:
        {
            uint32 i = 0;
            uint32 j = 0;
            OOP_DAYPERIOD_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                for (j = 0; j < data.dPeriod[i].nNum; j++)
                {
                    PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.dPeriod[%d].period[%d].hour:%d\n", 
                        i, j, data.dPeriod[i].period[j].hour);
                    PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.dPeriod[%d].period[%d].min:%d\n", 
                        i, j, data.dPeriod[i].period[j].min);
                    PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.dPeriod[%d].period[%d].rateNO:%d\n", 
                        i, j, data.dPeriod[i].period[j].rateNO);
                }
            }

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_day_period_one
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_day_period_one(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40160200:
    case 0x40170200:
        {
            uint32 i = 0;
            uint32 j = 0;
            uint32 len = 0;
            OOP_DAYPERIOD_T dataAll = {0};
            DAYPERIOD data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            for (j = 0; j < data.nNum; j++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.period[%d].hour:%d\n", 
                    j, data.period[j].hour);
                PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.period[%d].min:%d\n", 
                    j, data.period[j].min);
                PRTL_FMT_LOGCC("class8_invoke_set_day_period : data.period[%d].rateNO:%d\n", 
                    j, data.period[j].rateNO);
            }

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(dataAll), (uint8*)&dataAll, &len);
                if((ret != ERR_OK) || (len == 0))
                {
                    PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }

                i = pOadInfo->nIndex - 1;
                if (pOadInfo->nIndex > dataAll.nNum)
                {
                    dataAll.nNum = pOadInfo->nIndex;
                }
                memcpy(&dataAll.dPeriod[i], &data, sizeof(DAYPERIOD));

                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataAll, sizeof(dataAll));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_get(pOadInfo->pTab->oad, &dataAll, sizeof(dataAll));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_get failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }

                i = pOadInfo->nIndex - 1;
                if (pOadInfo->nIndex > dataAll.nNum)
                {
                    dataAll.nNum = pOadInfo->nIndex;
                }
                memcpy(&dataAll.dPeriod[i], &data, sizeof(DAYPERIOD));

                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &dataAll, sizeof(dataAll));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_group_addr
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_day_period(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    if (pOadInfo->nIndex == 0)
    {
        return class8_invoke_set_day_period_all(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
    }
    else
    {
        return class8_invoke_set_day_period_one(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
    }
}

/**
*********************************************************************
* @name：      class8_invoke_set_group_addr
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_rate_tariff(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40180200:
        case 0x40190200:
        {
            uint32 i = 0;
            OOP_RATETARIFF_T data;
            OOP_RATETARIFF_T data4018;
            uint32           len = 0;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_rate_tariff : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_rate_tariff : data:%d\n", data.nValue[i]);
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
            /* 设置备用套查询一下当前, 如果没有就写入 */
            normal.oad.value = 0x40180200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(data4018), (uint8*)&data4018, &len);
            if(0 != ret)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_reject_from_group
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_reject_from_group(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40240200:
        {
            uint8 data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_reject_from_group : data = %d\n", data);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_volt_rate
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_volt_rate(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40300200:
        {
            OOP_VOLTPARAM_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;
            PRTL_FMT_LOGCC("class8_invoke_set_volt_rate : data.uupVolt = %d\n", data.uupVolt);
            PRTL_FMT_LOGCC("class8_invoke_set_volt_rate : data.lldVolt = %d\n", data.lldVolt);
            PRTL_FMT_LOGCC("class8_invoke_set_volt_rate : data.upVolt = %d\n", data.upVolt);
            PRTL_FMT_LOGCC("class8_invoke_set_volt_rate : data.ldVolt = %d\n", data.ldVolt);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_volt_rate
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_curloop_monitor(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40410200:
        {
            OOP_CURLOOPCKENABLE_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;
            
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_demand_period
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_demand_period(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41000200:
        {
            uint8 data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_demand_period
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_slip_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41010200:
        {
            uint8 data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;
            
            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_coordinates
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_asset_no(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41030200:
        {
            OOP_VISIBLEVAR32_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;
            PRTL_FMT_LOGCC("class8_invoke_set_asset_no : data.nNum = %d\n", data.nNum);
            PRTL_BUF_LOGCC(&data.value[0], data.nNum, "class8_invoke_set_asset_no : data:");

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_combine_word
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_combine_word(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x41120200:
    case 0x41130200:
    case 0x41140200:
        {
            OOP_BITSTR8_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;

            if (!pApduInfo->NoEsamMac && pApduInfo->logicAddr != 1)
            {
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }                
            }
            else
            {
                dar = puAmr_acMeter_set(pOadInfo->pTab->oad, &data, sizeof(data));
                if (dar != DATA_SUCCESS)
                {
                    PRTL_FMT_DEBUG("puAmr_acMeter_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
                    return dar;
                }                
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_braodcast_time
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_broadcast_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x42040200:
        {
            OOP_SYNCTIME_T data;
            memset(&data, 0, sizeof(OOP_SYNCTIME_T));
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_braodcast_time : data.time.hour = %d\n", data.time.hour);
            PRTL_FMT_LOGCC("class8_invoke_set_braodcast_time : data.time.minute = %d\n", data.time.minute);
            PRTL_FMT_LOGCC("class8_invoke_set_braodcast_time : data.time.second = %d\n", data.time.second);
            PRTL_FMT_LOGCC("class8_invoke_set_braodcast_time : data.bValid = %d\n", data.bValid);

            if ((data.time.hour > 23)
                ||(data.time.minute > 59)
                ||(data.time.second > 59))
            {
                return DATA_READ_WRITE_DENIED;
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_p2p_broadcast_time
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_p2p_broadcast_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x42040300:
        {
            OOP_P2PSYNCTIME_T data;
            memset(&data, 0, sizeof(OOP_P2PSYNCTIME_T));
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_p2p_broadcast_time : data.offset = %d\n", data.offset);
            PRTL_FMT_LOGCC("class8_invoke_set_p2p_broadcast_time : data.time.hour = %d\n", data.time.hour);
            PRTL_FMT_LOGCC("class8_invoke_set_p2p_broadcast_time : data.time.minute = %d\n", data.time.minute);
            PRTL_FMT_LOGCC("class8_invoke_set_p2p_broadcast_time : data.time.second = %d\n", data.time.second);
            PRTL_FMT_LOGCC("class8_invoke_set_p2p_broadcast_time : data.bValid = %d\n", data.bValid);

            if ((data.time.hour > 23)
                ||(data.time.minute > 59)
                ||(data.time.second > 59))
            {
                return DATA_READ_WRITE_DENIED;
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_cascade
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_cascade(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[2*BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 i       = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x42020200:
        {
            OAD_INFO_T pstOdaInfo = {0};
            OOP_CASCADE_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.flag = %d\n", data.flag);
            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.port.value = 0x%08x\n", data.port.value);
            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.tdelay = %d\n", data.tdelay);
            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.bdelay = %d\n", data.bdelay);
            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.retry = %d\n", data.retry);
            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.cycle = %d\n", data.cycle);
            PRTL_FMT_LOGCC("class8_invoke_set_cascade : data.casnum = %d\n", data.casnum);
            for (i = 0; i < data.casnum; i++)
            {
                PRTL_BUF_LOGCC(&data.addr[i].add[0], data.addr[i].len, "class8_invoke_set_cascade add:");
            }

            if (!class_oadinfo_get(data.port, &pstOdaInfo))
            {
                return DATA_OTHER_REASON;
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_cascade
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_authentication_code(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[2*BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x44010200:
        {
            OOP_VISIBLEVAR32_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;
            PRTL_FMT_LOGCC("class8_invoke_set_authentication_code : data.nNum = %d\n", data.nNum);
            PRTL_BUF_LOGCC(&data.value[0], data.nNum, "class8_invoke_set_authentication_code : data:");

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_gprs_apn_res
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_gprs_apn_res(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[6*BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x45200200:
        {
            uint32 i = 0;
            uint32 j = 0;
            OOP_APNGROUP_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;

            PRTL_FMT_LOGCC("class8_invoke_set_gprs_apn_res : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_gprs_apn_res : data.net[%d].factory = %d\n", i, data.net[i].factory);
                PRTL_FMT_LOGCC("class8_invoke_set_gprs_apn_res : data.net[%d].network = %d\n", i, data.net[i].network);
                PRTL_BUF_LOGCC(&data.net[i].apn.apn.value[0], data.net[i].apn.apn.nNum, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.apn:", i);
                PRTL_BUF_LOGCC(&data.net[i].apn.username.value[0], data.net[i].apn.username.nNum, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.username:", i);
                PRTL_BUF_LOGCC(&data.net[i].apn.pwd.value[0], data.net[i].apn.pwd.nNum, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.pwd:", i);
                PRTL_BUF_LOGCC(&data.net[i].apn.proxyip[0], 4, "class8_invoke_set_gprs_apn_res : data.net[%d].apn.proxyip:");
                PRTL_FMT_LOGCC("class8_invoke_set_gprs_apn_res : data.net[%d].apn.proxyport = %d\n", i, data.net[i].apn.proxyport);
                PRTL_FMT_LOGCC("class8_invoke_set_gprs_apn_res : data.net[%d].master.nNum = %d\n", i, data.net[i].master.nNum);
                for (j = 0; j < data.net[i].master.nNum; j++)
                {
                    PRTL_BUF_LOGCC(&data.net[i].master.master[j].ip[0], 4, "class8_invoke_set_gprs_apn_res : data.net[%d].master.master[%d].ip:", i, j);
                    PRTL_FMT_LOGCC("class8_invoke_set_gprs_apn_res : data.net[%d].master.master[%d].port = %d\n", i, j, data.net[i].master.master[j].port);
                }
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_security_flag
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_security_flag(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1010200:
        {
            OOP_SECURITYFLAG_E dataSet;
            memcpy(&dataSet, convert.dstBuf, dOffset);
            normal.oad.value = 0xF1010200;
            normal.classtag = CLASS_DATA_INIT;
            PRTL_FMT_LOGCC("class8_invoke_set_security_flag : dataSet = 0x%x\n", dataSet);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataSet, sizeof(OOP_SECURITYFLAG_E));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_yk_config
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_yk_config(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80000200:
        {
            OOP_TELECON_PARAM_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x80000200;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_yk_config : data.limit = %d\n", data.limit);
            PRTL_FMT_LOGCC("class8_invoke_set_yk_config : data.delay = %d\n", data.delay);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_TELECON_PARAM_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_no_comm_time
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_no_comm_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80010300:
        {
            uint16 data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x80010300;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_no_comm_time : data = %d\n", data);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_power_on_time
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_power_on_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80010400:
        {
            uint16 data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x80010400;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_no_comm_time : data = %d\n", data);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_auto_time
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_prt_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    uint32 i = 0;
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80010500:
        {
            OOP_PRTTIME_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x80010500;
            normal.classtag = CLASS_DATA_INIT;

            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_auto_time : data.item[%d].start = %d\n", i, data.item[i].start);
                PRTL_FMT_LOGCC("class8_invoke_set_auto_time : data.item[%d].end = %d\n", i, data.item[i].end);

                if (data.item[i].start > 23 || data.item[i].end > 24 || data.item[i].start >= data.item[i].end)
                {
                    return DATA_READ_WRITE_DENIED;
                }
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_PRTTIME_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            //解除保电状态下，增加自动保电时段，设置无状态，由控制模块判断是否进入自动保电
            if (get_guard_state() == 2)
            {
                set_guard_state(0);
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_keep_value
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_keep_value(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81000200:
        {
            int64 data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x81000200;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_keep_value : data = %d\n", data);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(int64));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
            appmain_buzzer_status(pApduInfo->hUdp, TRUE);
            usleep(200000);
            appmain_buzzer_status(pApduInfo->hUdp, FALSE);
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_powcon_time
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_powcon_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81010200:
        {
            uint32 i = 0;
            OOP_POWCON_TIME_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x81010200;
            normal.classtag = CLASS_DATA_INIT;

            for (i = 0; i < 12; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_powcon_time : data[%d] = %d\n", i, data.period[i]);
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_POWCON_TIME_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_powcon_warn
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_powcon_warn(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81020200:
        {
            uint8 i = 0;
            OOP_POWCON_WARNING_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x81020200;
            normal.classtag = CLASS_DATA_INIT;

            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_powcon_warn : data[%d] = %d\n", i, data.time[i]);
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_POWCON_WARNING_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_keep_value
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_power_value(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x81100200:
        {
            int64 data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0x81100200;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_keep_value : data = %d\n", data);

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(int64));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
            appmain_buzzer_status(pApduInfo->hUdp, TRUE);
            usleep(200000);
            appmain_buzzer_status(pApduInfo->hUdp, FALSE);
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_security_mod
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_security_mod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 i = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1010300:
        {
            OOP_SCURITYMODE_T data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0xF1010300;
            normal.classtag = CLASS_DATA_INIT;

            PRTL_FMT_LOGCC("class8_invoke_set_security_mod : data.nNum = %d\n", data.nNum);
            for (i = 0; i < data.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_set_security_mod : data.mode[%d].object = 0x%04x\n", i, data.mode[i].object);
                PRTL_FMT_LOGCC("class8_invoke_set_security_mod : data.mode[%d].access = 0x%04x\n", i, data.mode[i].access);
            }

            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_SCURITYMODE_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_security_sal
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2021-9-2
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_security_sal(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0xF1010400:
        {
            uint8 data;
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0xF1010400;
            normal.classtag = CLASS_DATA_UNINIT;

            PRTL_FMT_DEBUG("class8_invoke_set_security_sal mode = %d\n", data);
            if(data > 1)
            {
                return DATA_DATA_BLOCK_UNAVAILABLE;
            }
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(uint8));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                               ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
            ssal_set_status(data);
        }
        break;
    
        default: return DATA_OBJECT_UNAVAILABLE;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OAD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_inner_factory_code
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_inner_factory_code(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    OOP_VISIBLESTR4_T data;
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (void *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set_inner_factory_code(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_port_authorize failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    normal.oad.value = pOadInfo->pTab->oad.value;
    normal.classtag = CLASS_DATA_UNINIT;
    
    ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_VISIBLESTR4_T));
    if(ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
            ret, normal.logicId, normal.infoNum, normal.oad.value);
        return DATA_OTHER_REASON;
    }

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_inner_factory_time
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_inner_factory_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    NOMAL_OAD_T normal = {0};
    int  ret = 0;
    
    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0xFFF00600:
        {
            OOP_DATETIME_S_T data = {0};
            memcpy(&data, convert.dstBuf, dOffset);
            //写入数据
            memset(&normal, 0 ,sizeof(NOMAL_OAD_T));
            normal.oad.value = pOadInfo->pTab->oad.value;
            normal.classtag = CLASS_DATA_UNINIT;
            
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(OOP_DATETIME_S_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                                ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
        default:
            return DATA_OBJECT_UNAVAILABLE;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;

}


/**
*********************************************************************
* @name：      class8_invoke_set_inner_app_id
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_inner_app_id(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    OOP_INNER_APP_ID_LIST_T data;
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 i = 0;
    char   cmd[64]={0};

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (void *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_set_inner_app_id(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set_inner_app_id failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    DEVINFO_DEVICE_T* dev = (DEVINFO_DEVICE_T*)hal_device_get(HW_DEVICE_ID_DEVINFO);
    PRTL_FMT_TRACE("class8_invoke_set_inner_app_id data.nNum = %d\n", data.nNum);
    for (i = 0; i < data.nNum; i++)
    {
        PRTL_FMT_TRACE("class8_invoke_set_inner_app_id appName:%s\n", data.innerAppID[i].appName.value);
        PRTL_BUF_TRACE(data.innerAppID[i].appID.value, data.innerAppID[i].appID.nNum, "class8_invoke_set_inner_app_id appID:\n");
        ret = dev->devinfo_write_appid(dev, data.innerAppID[i].appName.value, (const char *)data.innerAppID[i].appID.value, (int32)data.innerAppID[i].appID.nNum);
        if(ret != ERR_OK)
        {
            PRTL_FMT_DEBUG("devinfo_write_appid failed. ret(%d), oad(0x%08x)\n",
                ret, pOadInfo->pTab->oad.value);
            hal_device_release((HW_DEVICE *)dev);
            return DATA_OTHER_REASON;
        }
    }
    hal_device_release((HW_DEVICE *)dev);

    sprintf(cmd, "sync");
    if (exec_system_cmd(cmd) != 0)
    {
        PRTL_FMT_DEBUG("命令执行失败 cmd:%s\n", cmd);
    }

    //置复位标记 reset_real_proc 后续处理, 暂时不重启终端
    //set_reset_flag(pApduInfo->hUdp, TMN_REBOOT);

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_set_rmt_shake
* @brief：     设置遥信防抖时间
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-8-3
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_rmt_shake(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    uint32 sOffset = 4;
    uint32 shaketime = 0; 
    NOMAL_OAD_T normal = {0};
    uint32 offset  = 0;

    //从报文中提取数据
    if(DT_DOUBLE_LONG_UNSIGNED != inData[sOffset++])
    {
        return DATA_TYPE_UNMATCHED;
    }
    memcpy_r(&shaketime, inData + sOffset, 4);

    normal.oad.value = 0x49080200;
    normal.classtag = CLASS_DATA_INIT;

    PRTL_FMT_LOGCC("class8_invoke_set_rmt_shake : data = %d\n", shaketime);

    ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&shaketime, sizeof(uint32));
    if(ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
        return DATA_OTHER_REASON;
    }

    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return DATA_SUCCESS;
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_20
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_20(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x202c:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    //return class8_invoke_set_wallet(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;         
            default:
                break;
            }
        }
        break;      
   
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_40
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_40(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4000:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x03:
                {
                    return class8_invoke_set_timing_mod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }  
                case 0x04:
                {
                    return class8_invoke_set_time_pricse(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x06:
                {
                    return class8_invoke_set_sync_cycle(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }         
                default: break;
            }
            break;
        }
        case 0x4001: //通信地址
        case 0x4002: //通信地址
        case 0x4003: //客户编号
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_addr_octet(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4004: //设备地理坐标
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_coordinates(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4005: //组地址
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_group_addr(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4008: //备用套时区表切换时间
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_time_zone_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4009: //备用套日时段切换时间
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_day_step_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x400A: //备用套日时段切换时间
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_min_step_switch(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x400C: //时区时段数
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_time_region(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
         case 0x4014: //当前套时区表
         case 0x4015: //备用套时区表
         {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_time_zone(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
         }
        case 0x4016: //当前套日时段表
        case 0x4017: //备用套日时段表
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_day_period(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4018: //当前套费率电价
        case 0x4019: //备用套费率电价
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_rate_tariff(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4024: //剔除功能
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_reject_from_group(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:  return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4030: //电压合格率参数
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_volt_rate(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default:return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }
        case 0x4041: //电流回路监测使能
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02:
                {
                    return class8_invoke_set_curloop_monitor(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: return DATA_OBJECT_UNAVAILABLE;
            }
            break;
        }       
        default: return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_41
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_41(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x4100: //最大需量周期
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_demand_period(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;    
     case 0x4101: //滑差时间
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_slip_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;       
    case 0x4103: //设备资产管理编码
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_asset_no(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;    
    case 0x4112: //组合特征字
    case 0x4113: 
    case 0x4114: 
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_combine_word(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;   
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_42
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_42(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4202: //级联参数
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    //级联参数
                    return class8_invoke_set_cascade(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;

    case 0x4204: //广播校时参数
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_broadcast_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x03:
                {
                    return class8_invoke_set_p2p_broadcast_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;

    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_44
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_44(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4401:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    //认证密码
                    return class8_invoke_set_authentication_code(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;

    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_45
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_45(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x4520: //公网远程通信多接入点备用通道
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_gprs_apn_res(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;
   
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_49
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2020-8-3
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_49(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x4908: //开入量采集防抖时间
        {
            switch (pOadInfo->pTab->oad.attID)
            {
                case 0x02: return class8_invoke_set_rmt_shake(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                default:  return DATA_OBJECT_UNAVAILABLE;
            }
        }
        break;
   
        default:  return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}


/**
*********************************************************************
* @name：      class8_invoke_set_oia_80
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_80(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x8000:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_yk_config(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break; 

            default:
                break;
            }
        }
        break;
    case 0x8001:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x03:
                {
                    return class8_invoke_set_no_comm_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break; 
            case 0x04:
                {
                    return class8_invoke_set_power_on_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            case 0x05:
                {
                    return class8_invoke_set_prt_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            default:
                break;
            }
        }
        break;   
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_81
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_81(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x8100:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
#if defined PRODUCT_ZCU_1 || defined PRODUCT_SEU
                    appctrl_alarm_data(255, 0, 3, 1, NULL);
#endif
                    return class8_invoke_set_keep_value(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break; 

            default:
                break;
            }
        }
        break;
    case 0x8101:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
#if defined PRODUCT_ZCU_1 || defined PRODUCT_SEU
                    appctrl_alarm_data(255, 0, 3, 1, NULL);
#endif
                    return class8_invoke_set_powcon_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            default:
                break;
            }
        }
        break;   
    case 0x8102:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
#if defined PRODUCT_ZCU_1 || defined PRODUCT_SEU
                    appctrl_alarm_data(255, 0, 3, 1, NULL);
#endif
                    return class8_invoke_set_powcon_warn(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            default:
                break;
            }
        }
        break; 
    case 0x8110:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_power_value(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;
            default:
                break;
            }
        }
        break; 
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_f1
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_f1(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xF101:
        {
            switch (pOadInfo->pTab->oad.attID)
            {
            case 0x02:
                {
                    return class8_invoke_set_security_flag(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;

            case 0x03:
                {
                    return class8_invoke_set_security_mod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;  
            case 0x04:
                {
                    return class8_invoke_set_security_sal(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
            default:
                break;
            }
        }
        break;
   
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_set_oia_ff
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set_oia_ff(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xFFF0:
        {
            switch (pOadInfo->pTab->oad.attID)
            {          
                case 0x04:
                {
                    return class8_invoke_set_inner_factory_code(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                case 0x06:
                {
                    return class8_invoke_set_inner_factory_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                default: break;
            }
        }
        break;
    case 0xFFF2:
        {
            switch (pOadInfo->pTab->oad.attID)
            {          
            case 0x04:
                {
                    return class8_invoke_set_inner_app_id(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;  
            default:
                break;
            }
        }
        break;   
    default:
        return DATA_OBJECT_UNAVAILABLE;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

#endif

#if DESC("上报方案", 1)

/**
*********************************************************************
* @brief：      记录型数据
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_record_data(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *pOffset;    
    RECORDDATA data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if(srcBufTmp[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //OAD
    dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.oad, sizeof(OOP_OAD_U));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return dar;
    }        
       
    //RCSD
    dar = basic_buf_to_data(E_RCSD, srcBuf, srcLen, &sOffset, &data.tRCSD, sizeof(OOP_PCSD_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return dar;
    }

    //RSD
    dar = basic_buf_to_data(E_RSD, srcBuf, srcLen, &sOffset, &data.tRSD, sizeof(OOP_PRSD_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return dar;
    }    

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(sOffset > srcLen)
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d)\n", sOffset, srcLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    memcpy(dstData, &data, dstLen);

    *pOffset = sOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：      上报内容
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_report_context(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *pOffset;    
    REPORT_CONTEXT data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if(srcBufTmp[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //类型
#ifdef AREA_FUJIAN
    dar = basic_buf_to_data(E_ENUM, srcBuf, srcLen, &sOffset, &data.choice, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
#else
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.choice, sizeof(uint8));
    if (dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }
#endif

    if(data.choice == 0) //普通OAD
    {
        //OAD
        dar = basic_buf_to_data(E_OAD, srcBuf, srcLen, &sOffset, &data.oad, sizeof(OOP_OAD_U));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
            return dar;
        }
    }
    else if(data.choice == 1) //记录型OAD
    {
        dar = buf_to_data_record_data(pOadInfo, srcBuf, srcLen, &sOffset, &data.record, sizeof(RECORDDATA));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
            return dar;
        } 
    }
    else
    {
        PRTL_FMT_DEBUG("choice check failed. choice(%d)\n", data.choice);
        return DATA_TYPE_UNMATCHED;        
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(sOffset > srcLen)
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d)\n", sOffset, srcLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    memcpy(dstData, &data, dstLen);

    *pOffset = sOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：      关联对象属性表
* * @param[in]: srcBuf     源数据区698报文
*               srcLen     源数据长度
*               dstLen     目的长度，通常是变量的长度
*
* @param[out] ：pOffset     解出该数据后的源数据区偏移
*               dstData    目的数据区，通常是变量的地址
* @return：      =0            - 成功
*               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_evt_acqcmd_2007(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E  dar = DATA_SUCCESS;   
    uint32  offset = *pOffset;
    ACQCMD_2007 data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 offlen = 0; //数组数量长度
    uint8 i = 0;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBufTmp[offset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[offset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组类型
    if(srcBufTmp[offset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check array type failed. offset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nMainLen = get_len_offset(&srcBufTmp[offset], &offlen);
    offset += offlen;

    for(i = 0; i < data.nMainLen; i++)
    {
        dar = basic_buf_to_data(E_OCTET_STR4_T, srcBufTmp, srcLen-offset, &offset, &data.mainId[i], sizeof(data.mainId[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "[%d]basic_buf_to_data failed. dar(%d), offset(%d)\n", i, dar, offset);
            return DATA_TYPE_UNMATCHED;
        }
    }

    //数组类型
    if(srcBufTmp[offset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check array type failed. offset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nBackupLen = get_len_offset(&srcBufTmp[offset], &offlen);
    offset += offlen;

    for(i = 0; i < data.nBackupLen; i++)
    {
        dar = basic_buf_to_data(E_OCTET_STR32_T, srcBufTmp, srcLen-offset, &offset, &data.backupId[i], sizeof(data.backupId[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "[%d]basic_buf_to_data failed. dar(%d), offset(%d)\n", i, dar, offset);
            return DATA_TYPE_UNMATCHED;
        }
    }

    memcpy(dstData, &data, dstLen);
    *pOffset = offset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      关联对象属性表
* * @param[in]: srcBuf     源数据区698报文
*               srcLen     源数据长度
*               dstLen     目的长度，通常是变量的长度
*
* @param[out] ：pOffset     解出该数据后的源数据区偏移
*               dstData    目的数据区，通常是变量的地址
* @return：      =0            - 成功
*               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_evt_acqcmd_1997(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E  dar = DATA_SUCCESS;   
    uint32  offset = *pOffset;
    ACQCMD_1997 data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 offlen = 0; //数组数量长度
    uint8 i = 0;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBufTmp[offset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[offset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组类型
    if(srcBufTmp[offset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check array type failed. offset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nMainLen = get_len_offset(&srcBufTmp[offset], &offlen);
    offset += offlen;

    for(i = 0; i < data.nMainLen; i++)
    {
        dar = basic_buf_to_data(E_OCTET_STR2_T, srcBufTmp, srcLen-offset, &offset, &data.mainId[i], sizeof(data.mainId[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "[%d]basic_buf_to_data failed. dar(%d), offset(%d)\n", i, dar, offset);
            return DATA_TYPE_UNMATCHED;
        }
    }

    //数组类型
    if(srcBufTmp[offset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check array type failed. offset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nBackupLen = get_len_offset(&srcBufTmp[offset], &offlen);
    offset += offlen;

    for(i = 0; i < data.nBackupLen; i++)
    {
        dar = basic_buf_to_data(E_OCTET_STR32_T, srcBufTmp, srcLen-offset, &offset, &data.backupId[i], sizeof(data.backupId[i]));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "[%d]basic_buf_to_data failed. dar(%d), offset(%d)\n", i, dar, offset);
            return DATA_TYPE_UNMATCHED;
        }
    }

    memcpy(dstData, &data, dstLen);
    *pOffset = offset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      关联对象属性表
* * @param[in]: srcBuf     源数据区698报文
*               srcLen     源数据长度
*               dstLen     目的长度，通常是变量的长度
*
* @param[out] ：pOffset     解出该数据后的源数据区偏移
*               dstData    目的数据区，通常是变量的地址
* @return：      =0            - 成功
*               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_evt_acqcmd_trans(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E  dar = DATA_SUCCESS;   
    uint32  offset = *pOffset;
    OOP_OCTETVAR256_T data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    MEMZERO(&data, sizeof(data));

    //结构类型
    if(srcBufTmp[offset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBufTmp[offset++] != 1)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    dar = basic_buf_to_data(E_OOP_OCTETVAR256_T, srcBufTmp, srcLen, &offset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "basic_buf_to_data failed. dar(%d), offset(%d)\n", dar, offset);
        return DATA_TYPE_UNMATCHED;
    }
    

    memcpy(dstData, &data, dstLen);
    *pOffset = offset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      冻结关联对象属性表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_report_plan(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PLAN_REPORT_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 5)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //方案编号
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.planID, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //上报通道
    dar = buf_to_data_evt_asobjattr(pOadInfo, srcBuf, srcLen, &sOffset, &data.channel, sizeof(OOP_OADS_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), channel.nNum(%d)\n", dar, data.channel.nNum);
        return DATA_TYPE_UNMATCHED;
    }

    //响应超时时间
    dar = basic_buf_to_data(E_TI, srcBuf, srcLen, &sOffset, &data.timeout, sizeof(OOP_TI_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), ti.unit(%d), ti.value(%d)\n", dar, data.timeout.unit, data.timeout.value);
        return DATA_TYPE_UNMATCHED;
    }

    //最大重试次数
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.retry, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), retry(%d)\n", dar, data.retry);
        return DATA_TYPE_UNMATCHED;
    }

    //上报内容
    dar = buf_to_data_report_context(pOadInfo, srcBuf, srcLen, &sOffset, &data.data, sizeof(REPORT_CONTEXT));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), choice(%d)\n", dar, data.data.choice);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     冻结关联对象属性表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_acq_rule(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_ACQRULE_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //方案编号
    dar = basic_buf_to_data(E_CSD, srcBuf, srcLen, &sOffset, &data.csd, sizeof(OOP_CSD_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

        //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 3)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //07采集数据标识
    dar = buf_to_data_evt_acqcmd_2007(pOadInfo, srcBuf, srcLen, &sOffset, &data.acqCmd.acqCmd07, sizeof(ACQCMD_2007));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //97采集数据标识
    dar = buf_to_data_evt_acqcmd_1997(pOadInfo, srcBuf, srcLen, &sOffset, &data.acqCmd.acqCmd97, sizeof(ACQCMD_1997));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //透明命令
    dar = buf_to_data_evt_acqcmd_trans(pOadInfo, srcBuf, srcLen, &sOffset, &data.acqCmd.acqCmdTrs, sizeof(OOP_OCTETVAR256_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      记录型数据
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_record_data(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  dOffset = *pOffset;    
    RECORDDATA data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBufTmp[dOffset++] = 3;

    //OAD
    dar = basic_data_to_buf(E_OAD, dstBuf, dstLen, &dOffset, &data.oad, sizeof(OOP_OAD_U));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), oad(0x%08x)\n", dar, data.oad.value);
        return dar;
    }        
       
    //RCSD
    dar = basic_data_to_buf(E_PCSD, dstBuf, dstLen, &dOffset, &data.tRCSD, sizeof(OOP_PCSD_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), tRCSD.nNum(0x%08x)\n", dar, data.tRCSD.nNum);
        return dar;
    }

    //RSD
    dar = basic_data_to_buf(E_RSD, dstBuf, dstLen, &dOffset, &data.tRSD, sizeof(OOP_PRSD_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), tRSD.choice(0x%08x)\n", dar, data.tRSD.choice);
        return dar;
    }    

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(dOffset > dstLen)
    {
        PRTL_FMT_DEBUG("cross the border. dOffset(%d), dstLen(%d)\n", dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *pOffset = dOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：      上报内容
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_report_context(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  dOffset = *pOffset;    
    REPORT_CONTEXT data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBufTmp[dOffset++] = 2;

    //类型
#ifdef AREA_FUJIAN
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.choice, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), choice(%d)\n", dar, data.choice);
        return DATA_TYPE_UNMATCHED;
    }
#else
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.choice, sizeof(uint8));
    if (dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), choice(%d)\n", dar, data.choice);
        return DATA_TYPE_UNMATCHED;
    }
#endif

    if(data.choice == 0) //普通OAD
    {
        //OAD
        dar = basic_data_to_buf(E_OAD, dstBuf, dstLen, &dOffset, &data.oad, sizeof(OOP_OAD_U));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), oad(0x%08x)\n", dar, data.oad.value);
            return dar;
        }
    }
    else if(data.choice == 1) //记录型OAD
    {
        dar = data_to_buf_record_data(pOadInfo, dstBuf, dstLen, &dOffset, &data.record, sizeof(RECORDDATA));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("data_to_buf_record_data failed. dar(%d), oad(0x%08x)\n", dar, data.record.oad.value);
            return dar;
        } 
    }
    else
    {
        PRTL_FMT_DEBUG("choice check failed. choice(%d)\n", data.choice);
        return DATA_TYPE_UNMATCHED;        
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(dOffset > dstLen)
    {
        PRTL_FMT_DEBUG("cross the border. dOffset(%d), dstLen(%d)\n", dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *pOffset = dOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      冻结关联对象属性表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_report_plan(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PLAN_REPORT_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 5;

    //方案编号
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.planID, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //上报通道
    dar = data_to_buf_evt_asobjattr(pOadInfo, dstBuf, dstLen, &dOffset, &data.channel, sizeof(OOP_OADS_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), channel.nNum(%d)\n", dar, data.channel.nNum);
        return DATA_TYPE_UNMATCHED;
    }

    //响应超时时间
    dar = basic_data_to_buf(E_TI, dstBuf, dstLen, &dOffset, &data.timeout, sizeof(OOP_TI_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), ti.unit(%d), ti.value(%d)\n", dar, data.timeout.unit, data.timeout.value);
        return DATA_TYPE_UNMATCHED;
    }

    //最大重试次数
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.retry, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), retry(%d)\n", dar, data.retry);
        return DATA_TYPE_UNMATCHED;
    }

    //上报内容
    dar = data_to_buf_report_context(pOadInfo, dstBuf, dstLen, &dOffset, &data.data, sizeof(REPORT_CONTEXT));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), choice(%d)\n", dar, data.data.choice);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;    
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(采集监控状态单元)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_acq_monitor(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_ACQ_MONITOR_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 8;

    //任务ID
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.id, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), ID(%d)\n", dar, data.id);
        return DATA_TYPE_UNMATCHED;
    }

    //任务执行状态
    dar = basic_data_to_buf(E_ENUM, dstBuf, dstLen, &dOffset, &data.taskState, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), taskState(%d)\n", dar, data.taskState);
        return DATA_TYPE_UNMATCHED;
    }

    //任务执行开始时间
    dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data.startTime, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //任务执行结束时间
    dar = basic_data_to_buf(E_DATETIME_S, dstBuf, dstLen, &dOffset, &data.endTime, sizeof(OOP_DATETIME_S_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //采集总数量
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.sum, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), sum(%d)\n", dar, data.sum);
        return DATA_TYPE_UNMATCHED;
    }

    //采集成功数量
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.success, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), success(%d)\n", dar, data.success);
        return DATA_TYPE_UNMATCHED;
    }

    //已发送报文条数
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.send, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), send(%d)\n", dar, data.send);
        return DATA_TYPE_UNMATCHED;
    }

    //已接收报文条数
    dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.receive, sizeof(uint16));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), receive(%d)\n", dar, data.receive);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;  
}

/**
*********************************************************************
* @brief：     data_to_buf_acqcmd_2007
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_acqcmd_2007(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    int32 nRet = ERR_NORMAL;
    uint32     offset = *pOffset;
    ACQCMD_2007 data;
    uint8 offlen = 0; //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;

    //结构成员个数
    dstBufTmp[offset++] = 2;    

    //附加信息
    dstBufTmp[offset++] = DT_ARRAY;
    
    //附加信息个数
    offlen = set_len_offset(data.nMainLen, lenBuf);
    memcpy(&dstBufTmp[offset], lenBuf, offlen);
    offset += offlen;

    for(i = 0; i < data.nMainLen; i++)
    {   
        //AcqCmd_2007
        if(basic_data_to_buf(E_OCTET_STR4_T, dstBufTmp, dstLen-offset, &offset, &data.mainId[i], sizeof(data.mainId[i])) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }      
    }

    //附加信息
    dstBufTmp[offset++] = DT_ARRAY;
    
    //附加信息个数
    offlen = set_len_offset(data.nBackupLen, lenBuf);
    memcpy(&dstBufTmp[offset], lenBuf, offlen);
    offset += offlen;

    for(i = 0; i < data.nBackupLen; i++)
    {   
        //AcqCmd_2007
        if(basic_data_to_buf(E_OCTET_STR32_T, dstBufTmp, dstLen-offset, &offset, &data.backupId[i], sizeof(data.backupId[i])) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }      
    }

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     data_to_buf_acqcmd_1997
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_acqcmd_1997(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    int32 nRet = ERR_NORMAL;
    uint32     offset = *pOffset;
    ACQCMD_1997 data;
    uint8 offlen = 0; //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;

    //结构成员个数
    dstBufTmp[offset++] = 2;    

    //附加信息
    dstBufTmp[offset++] = DT_ARRAY;
    
    //附加信息个数
    offlen = set_len_offset(data.nMainLen, lenBuf);
    memcpy(&dstBufTmp[offset], lenBuf, offlen);
    offset += offlen;

    for(i = 0; i < data.nMainLen; i++)
    {   
        //AcqCmd_2007
        if(basic_data_to_buf(E_OCTET_STR2_T, dstBufTmp, dstLen-offset, &offset, &data.mainId[i], sizeof(data.mainId[i])) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }      
    }

    //附加信息
    dstBufTmp[offset++] = DT_ARRAY;
    
    //附加信息个数
    offlen = set_len_offset(data.nBackupLen, lenBuf);
    memcpy(&dstBufTmp[offset], lenBuf, offlen);
    offset += offlen;

    for(i = 0; i < data.nBackupLen; i++)
    {   
        //AcqCmd_2007
        if(basic_data_to_buf(E_OCTET_STR32_T, dstBufTmp, dstLen-offset, &offset, &data.backupId[i], sizeof(data.backupId[i])) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }      
    }

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     data_to_buf_acqcmd_2007
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_acqcmd_trans(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    int32 nRet = ERR_NORMAL;
    uint32     offset = *pOffset;
    OOP_OCTETVAR256_T data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);
 
    //透明命令
    if(basic_data_to_buf(E_OOP_OCTETVAR256_T, dstBufTmp, offset, &offset, &data, sizeof(data)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    }      

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(采集监控状态单元)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_acq_rule(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_ACQRULE_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 2;

    //数据属性描述符
    dar = basic_data_to_buf(E_CSD, dstBuf, dstLen, &dOffset, &data.csd, sizeof(data.csd));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 3;

    //07采集数据标识
    dar = data_to_buf_acqcmd_2007(pOadInfo, dstBuf, dstLen, &dOffset, &data.acqCmd.acqCmd07, sizeof(data.acqCmd.acqCmd07));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //97采集数据标识
    dar = data_to_buf_acqcmd_1997(pOadInfo, dstBuf, dstLen, &dOffset, &data.acqCmd.acqCmd97, sizeof(data.acqCmd.acqCmd97));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

        //07采集数据标识
    dar = data_to_buf_acqcmd_trans(pOadInfo, dstBuf, dstLen, &dOffset, &data.acqCmd.acqCmdTrs, sizeof(data.acqCmd.acqCmdTrs));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;  
}
#endif

#if DESC("转加密",1)
/**
*********************************************************************
* @brief：     转加密结果
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_encryption_res(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{   
    int32 nRet = ERR_NORMAL;
    uint32     offset = *pOffset;
    OOP_ENCRYPTRES_T data;
    uint8 offlen = 0; //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    uint8 i = 0;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
    dstBufTmp[offset++] = DT_STRUCTURE;

    //结构成员个数
    dstBufTmp[offset++] = 4;   

    //方案编号
    if (basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.planID, sizeof(data.planID)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    } 

    //执行时间
    if (basic_data_to_buf(E_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.planType, sizeof(data.planType)) < 0)
    {
        nRet = ERR_NORMAL;
        return nRet;
    } 

    //配置档案总个数
    if (basic_data_to_buf(E_LONG_UNSIGNED, dstBufTmp, dstLen-offset, &offset, &data.nMetTotal, sizeof(data.nMetTotal)) < 0)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed.\n");
        return DATA_TYPE_UNMATCHED;
    }

    //成功电能表集合
    dstBufTmp[offset++] = DT_ARRAY;

    //成功电能表集合
    offlen = set_len_offset(data.ms.nNum, lenBuf);
    memcpy(&dstBufTmp[offset], lenBuf, offlen);
    offset += offlen;

    for (i = 0; i < data.ms.nNum; i++)
    {
        if (basic_data_to_buf(E_OCTET_STR6_T, dstBufTmp, dstLen-offset, &offset, &data.ms.addr[i], sizeof(OOP_OCTETSTR6_T)) < 0)
        {
            nRet = ERR_NORMAL;
            return nRet;
        }    
    }

    *pOffset = offset;

    return ERR_OK;
}

/**
*********************************************************************
* @brief：     搜表结果
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
* @author    : 贺宁
* @Date      ：2019-12-6                 
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8_encryption_res_all(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_ENCRYPTRES_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    dar = data_to_buf_encryption_res(pOadInfo, dstBuf, dstLen, &dOffset, &data, sizeof(data));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d)\n", dar);
        return DATA_TYPE_UNMATCHED;
    } 

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      转加密方案内容
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_encryption_context(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *pOffset;    
    OOP_ENCRYPT_DATA_T data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;

    //结构类型
    if (srcBufTmp[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if (srcBufTmp[sOffset++] != 2)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //加密的apdu
    dar = basic_buf_to_data(E_OOP_OCTETVAR256_T, srcBuf, srcLen, &sOffset, &data.apdu, sizeof(data.apdu));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //param
    dar = basic_buf_to_data(E_OOP_OCTETVAR64_T, srcBuf, srcLen, &sOffset, &data.param, sizeof(data.param));
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "basic_data_to_buf failed. dar(%d), sOffset(%d)\n", dar, sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(sOffset > srcLen)
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d)\n", sOffset, srcLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    memcpy(dstData, &data, dstLen);

    *pOffset = sOffset;
  
    return dar;
}

/**
*********************************************************************
* @brief：      转加密配置档案
* * @param[in]: srcBuf     源数据区698报文
*               srcLen     源数据长度
*               dstLen     目的长度，通常是变量的长度
*
* @param[out] ：pOffset     解出该数据后的源数据区偏移
*               dstData    目的数据区，通常是变量的地址
* @return：      =0            - 成功
*               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_encryption_meters(const OAD_INFO_T *pOadInfo, const void *srcBuf, uint32 srcLen, uint32 *pOffset, void *dstData, uint32 dstLen)
{
    OOP_DAR_E  dar = DATA_SUCCESS;   
    uint32  offset = *pOffset;
    OOP_ENCRYPT_METERS_T data;
    uint8 *srcBufTmp = (uint8 *)srcBuf;
    uint8 offlen = 0; //数组数量长度
    uint8 i = 0;

    //数组类型
    if(srcBufTmp[offset++] != DT_ARRAY)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check array type failed. offset(%d)", offset);
        return DATA_TYPE_UNMATCHED;
    }

    //数组成员个数
    data.nNum = get_len_offset(&srcBufTmp[offset], &offlen);
    offset += offlen;

    if(data.nNum > OOP_MAX_ENCRYPT_NUM)
    {
        PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check array num failed. num(%d)", data.nNum);
        return DATA_TYPE_UNMATCHED;
    }

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        if(srcBufTmp[offset++] != DT_STRUCTURE)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", offset);
            return DATA_TYPE_UNMATCHED;
        }

        //结构成员数
        if(srcBufTmp[offset++] != 2)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "check struct type failed. sOffset(%d)", offset);
            return DATA_TYPE_UNMATCHED;
        }

        //档案序号
        dar = basic_buf_to_data(E_LONG_UNSIGNED, srcBufTmp, srcLen, &offset, &data.meter[i].metid, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "basic_data_to_buf failed. [%d] dar(%d), offset(%d)\n", i, dar, offset);
            return DATA_TYPE_UNMATCHED;
        }   
        //密钥密文
        dar = basic_buf_to_data(E_OOP_OCTETVAR256_T, srcBufTmp, srcLen, &offset, &data.meter[i].key, sizeof(OOP_OCTETVAR256_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_BUF_DEBUG(srcBufTmp, srcLen, "basic_data_to_buf failed. [%d] dar(%d), offset(%d)\n", i, dar, offset);
            return DATA_TYPE_UNMATCHED;
        } 
    }

    memcpy(dstData, &data, dstLen);
    *pOffset = offset;
     
    return dar;
}

/**
*********************************************************************
* @brief：     转加密方案
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_encryption_plan(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PLAN_ENCRYPT_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    MEMZERO(&data, sizeof(data));
    
    //结构类型
    if(srcBuf[sOffset++] != DT_STRUCTURE)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct type failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //结构成员数
    if(srcBuf[sOffset++] != 4)
    {
        PRTL_BUF_DEBUG(srcBuf, srcLen, "check struct num failed. sOffset(%d)", sOffset);
        return DATA_TYPE_UNMATCHED;
    }
    
    //方案编号
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.planID, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //方案类型
    dar = basic_buf_to_data(E_UNSIGNED, srcBuf, srcLen, &sOffset, &data.planType, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planType);
        return DATA_TYPE_UNMATCHED;
    }

    //方案内容
    dar = buf_to_data_encryption_context(pOadInfo, srcBuf, srcLen, &sOffset, &data.endata, sizeof(OOP_ENCRYPT_DATA_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //配置档案
    dar = buf_to_data_encryption_meters(pOadInfo, srcBuf, srcLen, &sOffset, &data.config, sizeof(OOP_ENCRYPT_METERS_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    memcpy(&dstBuf[dOffset], &data, sizeof(data));
    dOffset += sizeof(data);

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      转加密方案内容
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_encryption_context(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  dOffset = *pOffset;    
    OOP_ENCRYPT_DATA_T data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;

    memcpy(&data, srcData, srcLen);

    //结构类型
     dstBufTmp[dOffset++] = DT_STRUCTURE;
    
     //结构成员数
     dstBufTmp[dOffset++] = 2;
    

    //加密的apdu
    dar = basic_data_to_buf(E_OOP_OCTETVAR256_T, dstBuf, dstLen, &dOffset, &data.apdu, sizeof(data.apdu));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), dOffset(%d)\n", dar, dOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //param
    dar = basic_data_to_buf(E_OOP_OCTETVAR64_T, dstBuf, dstLen, &dOffset, &data.param, sizeof(data.param));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), dOffset(%d)\n", dar, dOffset);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(dOffset > dstLen)
    {
        PRTL_FMT_DEBUG("cross the border. dOffset(%d), dstLen(%d)\n", dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *pOffset = dOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      转加密配置档案
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_encryption_meters(const OAD_INFO_T *pOadInfo, void *dstBuf, uint32 dstLen, uint32 *pOffset, void *srcData, uint32 srcLen)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  dOffset = *pOffset;    
    OOP_ENCRYPT_METERS_T data;
    uint8 *dstBufTmp = (uint8 *)dstBuf;
    uint8 offlen = 0; //数组数量长度
    uint8 lenBuf[3] = {0}; //数组数量编码
    int i = 0;

    memcpy(&data, srcData, srcLen);

    //数组类型
    dstBufTmp[dOffset++] = DT_ARRAY;

    //数组成员个数
    offlen = set_len_offset(data.nNum, lenBuf);
    memcpy(&dstBufTmp[dOffset], lenBuf, offlen);
    dOffset += offlen;

    for(i = 0; i < data.nNum; i++)
    {
        //结构类型
        dstBufTmp[dOffset++] = DT_STRUCTURE;

        dstBufTmp[dOffset++] = 2;

        //档案序号
        dar = basic_data_to_buf(E_LONG_UNSIGNED, dstBuf, dstLen, &dOffset, &data.meter[i].metid, sizeof(uint16));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d), offset(%d)\n", i, dar, dOffset);
            return DATA_TYPE_UNMATCHED;
        }   
        //密钥密文
        dar = basic_data_to_buf(E_OOP_OCTETVAR256_T, dstBuf, dstLen, &dOffset, &data.meter[i].key, sizeof(OOP_OCTETVAR256_T));
        if(dar != DATA_SUCCESS)
        {
            PRTL_FMT_DEBUG("basic_data_to_buf failed. [%d] dar(%d), offset(%d)\n", i, dar, dOffset);
            return DATA_TYPE_UNMATCHED;
        } 
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if(dOffset > dstLen)
    {
        PRTL_FMT_DEBUG("cross the border. dOffset(%d), dstLen(%d)\n", dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *pOffset = dOffset;
     
    return dar;
}

/**
*********************************************************************
* @brief：      冻结关联对象属性表
* @param[in]： ppOadInfo     - 数据表指针
               srcBuf       - 源数据
               srcLen       - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen       - 目的数据长度
               sOffset      - 转换后源数据区的偏移
               dOffset      - 转换后目的数据区的偏移
* @return：     =0           - 成功
              !=0           - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_encryption_plan(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  sOffset = *convert->sOffset;
    uint32  dOffset = *convert->dOffset;
    OOP_PLAN_ENCRYPT_T data;
    uint8 *srcBuf = (uint8*)convert->srcBuf;
    uint32 srcLen = convert->srcLen;
    uint8 *dstBuf = (uint8*)convert->dstBuf;
    uint32 dstLen = convert->dstLen;

    memcpy(&data, &srcBuf[sOffset], sizeof(data));
    sOffset += sizeof(data);

    //结构类型
    dstBuf[dOffset++] = DT_STRUCTURE;

    //结构成员数
    dstBuf[dOffset++] = 4;

    //方案编号
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.planID, sizeof(uint8));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //方案类型
    dar = basic_data_to_buf(E_UNSIGNED, dstBuf, dstLen, &dOffset, &data.planType, sizeof(OOP_OADS_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planType(%d)\n", dar, data.planType);
        return DATA_TYPE_UNMATCHED;
    }

    //方案内容
    dar = data_to_buf_encryption_context(pOadInfo, dstBuf, dstLen, &dOffset, &data.endata, sizeof(OOP_ENCRYPT_DATA_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //配置档案
    dar = data_to_buf_encryption_meters(pOadInfo, dstBuf, dstLen, &dOffset, &data.config, sizeof(OOP_ENCRYPT_METERS_T));
    if(dar != DATA_SUCCESS)
    {
        PRTL_FMT_DEBUG("basic_data_to_buf failed. dar(%d), planID(%d)\n", dar, data.planID);
        return DATA_TYPE_UNMATCHED;
    }

    //避免每步都判断，放最后检查，但检查前可能已经越界
    if((sOffset > srcLen) || (dOffset > dstLen))
    {
        PRTL_FMT_DEBUG("cross the border. sOffset(%d), srcLen(%d), dOffset(%d), dstLen(%d)\n", sOffset, srcLen, dOffset, dstLen);
        return DATA_SCOPE_OF_ACCESS_VIOLATED;        
    }

    *convert->dOffset = dOffset;
    *convert->sOffset = sOffset;
     
    return dar;    
}

#endif

#if DESC("class8对外接口函数",1)

OOP_DAR_E buf_to_data_class8(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    OOP_DAR_E dar = DATA_SUCCESS;

    return dar;
}

/**
*********************************************************************
* @brief：     从数据中心的数据转698格式报文(class22)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E data_to_buf_class8(OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x20220200:   //事件记录序号
        case 0x20230200:   //冻结记录序号
        {
            return data_to_buf_class8_event_record_no(pOadInfo,  convert);
        }
        break;

        case 0x202a0200:   //目标服务器地址
        {
            return data_to_buf_class8_common(pOadInfo,  convert);
        }
        break;
        
        case 0x202c0200:   //钱包文件
        {
            return data_to_buf_class8_wallet(pOadInfo,  convert);
        }
        break;

        case 0x201e0200:   //事件发生时间
        case 0x20200200:   //事件结束时间
        case 0x20210200:   //数据冻结时间
        case 0x40000200:   //获取系统时间
        case 0x40080200:   //备用套时区表切换时间
        case 0x40090200:   
        case 0x400A0200:
        case 0x400B0200:
        case 0xFFF00600:
        {
           return data_to_buf_class8_time(pOadInfo,  convert);
        }break;

        case 0x40000300:   //获取校时模式
        {
           return data_to_buf_class8_timing_mod(pOadInfo,  convert);
        }break;

        case 0x40000400:   //获取终端地理坐标
        {
           return data_to_buf_class8_time_precise(pOadInfo,  convert);
        }break;

        case 0x40000500:   //获取终端地理坐标
        {
           return data_to_buf_class8_time_board(pOadInfo,  convert);
        }
        
        case 0x40000600:   //卫星对时
        {
           return data_to_buf_class8_sysnc_cycle(pOadInfo,  convert);
        }break;

        case 0x40030200:
        case 0x40010200:   //获取终端地址
        case 0x40020200:
        {
           return data_to_buf_class8_addr_octet(pOadInfo,  convert);
        }break;

        case 0x40040200:   //获取终端地理坐标
        {
           return data_to_buf_class8_coordinates(pOadInfo,  convert);
        }break;

        case 0x40050200:   //获取终端组地址
        {
           return data_to_buf_class8_group_addr(pOadInfo,  convert);
        }break;

        case 0x400C0200:   //获取时区时段数
        {
           return data_to_buf_class8_time_region(pOadInfo,  convert);
        }break;

        case 0x40060200:   //获取终端时钟源
        {
           return data_to_buf_class8_clock_src(pOadInfo,  convert);
        }break;

        case 0x40070200:   //LCD参数
        {
           return data_to_buf_class8_LCD_param(pOadInfo,  convert);
        }break;
        case 0x40110200:   //公共假日表
        {
           return data_to_buf_class8_pub_holiday(pOadInfo,  convert);
        }break;
        case 0x41160200:   //结算日
        {
           return data_to_buf_class8_pay_day(pOadInfo,  convert);
        }break;
        case 0x40140200:   //当前套时区表
        case 0x40150200:   //备用套时区表
        {
           return data_to_buf_class8_time_zone(pOadInfo,  convert);
        }break;

        case 0x40160200:   //当前套日时段表
        case 0x40170200:   //备用套日时段表
        {
           return data_to_buf_class8_day_period(pOadInfo,  convert);
        }break;

        case 0x40180200:
        case 0x40190200:
        {
           return data_to_buf_class8_rate_tariff(pOadInfo,  convert);
        }break;

        case 0x40240200:   //剔除功能
        {
           return data_to_buf_class8_reject_from_group(pOadInfo,  convert);
        }break;
        case 0x40270200:   //获取升级结果
        {
           return data_to_buf_class8_update_result(pOadInfo,  convert);
        }break;

        case 0x40300200:   //获取终端地理坐标
        {
           return data_to_buf_class8_volt_rate(pOadInfo,  convert);
        }break;

        case 0x40400200:   //TA模块信息
        {
           return data_to_buf_class8_tamod(pOadInfo,  convert);
        }break;

        case 0x40400300:   //TA模块工况信息
        {
           return data_to_buf_class8_workstatus(pOadInfo,  convert);
        }break;

        case 0x40400400:   //TA模块换算及单位
        {
           return data_to_buf_class8_taunit(pOadInfo,  convert);
        }break;       

        case 0x40400500:   //TA模块版本信息
        {
           return data_to_buf_class8_taversion(pOadInfo,  convert);
        }break;    

        case 0x40410200:   //电流回路监测使能
        {
           return data_to_buf_class8_curloop_monitor(pOadInfo,  convert);
        }break;  

        case 0x41000200:   //需量周期
        {
           return data_to_buf_class8_demand_period(pOadInfo,  convert);
        }break;

        case 0x41010200:   //滑差时间
        {
           return data_to_buf_class8_slip_time(pOadInfo,  convert);
        }break;

        case 0x41030200:   //获取资产管理编码
        {
           return data_to_buf_class8_asset_no(pOadInfo,  convert);
        }break;
        
        case 0x41040200:   //额定电压
        {
            return data_to_buf_class8_rated_volt(pOadInfo,  convert);
        }break;

        case 0x41050200:   //额定电流
        {
            return data_to_buf_class8_rated_curr(pOadInfo,  convert);
        }break;

        case 0x41060200:   //最大电流
        {
            return data_to_buf_class8_max_curr(pOadInfo,  convert);
        }break;

        case 0x42020200:   //级联参数
        {
           return data_to_buf_class8_cascade(pOadInfo,  convert);
        }break;

        case 0x42040200:   //获取广播校时参数
        {
           return data_to_buf_class8_broadcast_time(pOadInfo,  convert);
        }break;

        case 0x42040300:   //获取广播校时参数
        {
           return data_to_buf_class8_p2p_broadcast_time(pOadInfo,  convert);
        }break;

        case 0x45200200:   //备用通道
        {
           return data_to_buf_class8_gprs_apn_res(pOadInfo,  convert);
        }break;

        case 0x48000400:   //负荷感知-冻结数据单元
        {
           return data_to_buf_class8_load_aware(pOadInfo,  convert);
        }break;

        case 0x80000200:   //遥控告警配置
        {
           return data_to_buf_class8_yk_config(pOadInfo,  convert);
        }break;

        case 0x80000400:   //遥控告警状态
        {
           return data_to_buf_class8_ykalarm_state(pOadInfo,  convert);
        }break;

        case 0x80000500:   //遥控命令状态
        {
           return data_to_buf_class8_ykalarm_state(pOadInfo,  convert);
        }break;

        case 0x80010200:   //保电状态
        {
           return data_to_buf_class8_guard_state(pOadInfo,  convert);
        }break;

        case 0x80010300:   //允许与主站最大无通信时长（分钟），0表示不自动保电
        case 0x80010400:   //上电自动保电时长（分钟），0表示上电不自动保电
        {
           return data_to_buf_class8_guard_time(pOadInfo,  convert);
        }break;

        case 0x80010500:   //自动保电时段
        {
           return data_to_buf_class8_auto_guard_interval(pOadInfo,  convert);
        }break;

        case 0x80020200:   //催费告警状态
        {
           return data_to_buf_class8_payment_state(pOadInfo,  convert);
        }break;

        case 0x80020300:   //催费告警状态
        {
           return data_to_buf_class8_payment_para(pOadInfo,  convert);
        }break;

        case 0x81000200:   //催费告警状态
        {
           return data_to_buf_class8_keep_value(pOadInfo,  convert);
        }break;

        case 0x81010200:   //终端功控时段
        {
           return data_to_buf_class8_powcon_time(pOadInfo,  convert);
        }break;

        case 0x81020200:   //功控告警时间
        {
           return data_to_buf_class8_powcon_warn(pOadInfo,  convert);
        }break;

        case 0x810c0200:   //购电控配置单元
        {
           return data_to_buf_class8_dk_config(pOadInfo,  convert);
        }break;

        case 0x81100200:   //电控定值
        {
           return data_to_buf_class8_power_value(pOadInfo,  convert);
        }break;

        case 0xF1010200:   //安全模式选择
        {
           return data_to_buf_class8_security_flag(pOadInfo,  convert);
        }break;

        case 0xF1010300:   //设备对象列表
        {
           return data_to_buf_class8_security_mod(pOadInfo,  convert);
        }break;
        case 0x40120200:  //周休日特征字
        case 0x41100200:  //电能表运行特征字1
        case 0x41110200:  //软件备案号
        case 0x41120200:  //有功组合方式特征字
        case 0x41130200:  //无功组合方式1特征字 
        case 0x41140200:  //无功组合方式2特征字 
        case 0xF4060200:  //安全加固信息
        case 0x40130200:
        case 0x401C0200:
        case 0x401D0200:
        case 0x400D0200:
        case 0x400C0201:
        case 0x400C0202:
        case 0x400C0203:
        case 0x400C0204:
        case 0x400C0205:
        case 0x401E0202:
        {
           return basic_db_to_fmt698(pOadInfo,  convert);
        }break;
        case 0x41110300:
        {
           return data_to_buf_limit_softrec(pOadInfo,  convert);
        }break;    
        case 0x401A0200:
        case 0x401B0200:
        {
            return data_to_buf_limit_stepprice(pOadInfo,  convert);
        }
        break;
        case 0x401E0200:
        {
            return data_to_buf_limit_charge(pOadInfo,  convert);
        }
        break;
        case 0x401F0200:
        {
            return data_to_buf_other_limit(pOadInfo,  convert);
        }
        break;
        case 0x41210200:
        {
            return data_to_buf_power_characteristic_record(pOadInfo,  convert);
        }
        break;
        case 0x41220200:
        {
            return data_to_buf_energy_characteristic_record(pOadInfo,  convert);
        }
        break;
        case 0x47010200:
        {
            return data_to_buf_pile_work_status(pOadInfo, convert);
        }
        break;
        case 0x47020400:
        {
            return data_to_buf_charge_service(pOadInfo, convert);
        }
        break;

#ifdef AREA_HUNAN
        case 0x60E10200:   //温湿度传感器
        case 0x60E20200:   //烟雾传感器
        case 0x60E30200:   //水浸传感器
        case 0x60E40200:   //变压器桩头温度传感器
        {
            return data_to_buf_class8_sensor_param(pOadInfo, convert);
        }
        break;
#endif
#ifdef AREA_ANHUI
        case 0x6E430200:   //异常电表信息记录
        {
            //return data_to_buf_class8_abnormal_meter_info(pOadInfo, convert);
        }
        break;
#endif
#ifdef AREA_FUJIAN
        case 0x4E010200:
        {
            return basic_db_to_fmt698(pOadInfo,  convert);
        }
        break;
        case 0x4E020200:
        {
            return buf_to_data_battery_status(pOadInfo,  convert);
        }
        break;
        case 0x4E030200:
        {
            return buf_to_data_singal_info(pOadInfo,  convert);
        }
        break;
        case 0x6E160200:
        {
            return data_to_buf_transparent_results(pOadInfo, convert);
        }
        break;
        case 0x6E320200:
        {
            return data_to_buf_transparent_event(pOadInfo, convert);
        }
        break;
#endif
        default:
        {
            PRTL_FMT_DEBUG("data_to_buf not support. oad(0x%08x)\n", pOadInfo->pTab->oad.value);
            return DATA_READ_WRITE_DENIED;
        }break;
    }

    return DATA_SUCCESS;
}

/**
*********************************************************************
* @brief：     从698格式报文转数据中心的数据(class8)
* @param[in]： ppOadInfo     - 数据表指针
               srcData       - 源数据
               srcLen        - 源数据长度
* @param[out]：dstBuf        - 目的数据
               dstLen        - 目的数据长度
* @return：    =0            - 成功
               <0            - 错误码
*********************************************************************
*/
OOP_DAR_E buf_to_data_class8_act(const OAD_INFO_T *pOadInfo, DATA_CONVERT_T *convert)
{
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x40007f00:   //设置时间
        {
            return buf_to_data_class8_time(pOadInfo,  convert);
        }break;

        case 0x80008100:   //遥控跳闸
        {
            return buf_to_data_class8_telecon_trip(pOadInfo,  convert);
        }break;

        case 0x80008200:   //遥控合闸
        {
            return buf_to_data_class8_telecon_close(pOadInfo,  convert);
        }break;

        case 0x80027f00:   //催费告警参数
        {
            return buf_to_data_class8_payment_on(pOadInfo,  convert);
        }break;

        case 0xf1010100:   //清空安全参数
        {
            return buf_to_data_class8_clear_scuritymod(pOadInfo,  convert);
        }break;

        case 0xf1017f00:   //增加显式安全参数
        {
            return buf_to_data_class8_add_scuritymod(pOadInfo,  convert);
        }break;

        case 0xf1018000:   //删除显式安全参数
        {
            return buf_to_data_class8_del_scuritymod(pOadInfo,  convert);
        }break;

        case 0xf1018100:   //增加显式安全参数
        {
            return buf_to_data_class8_add_scuritymod_list(pOadInfo,  convert);
        }break;

        //......
        
        default:
        {
            return DATA_READ_WRITE_DENIED;
        }break;
    }

    return DATA_SUCCESS;
}

/**
*********************************************************************
* @name：      class8_invoke_act_time
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_time(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40007f00:
        {
            uint32 offset = 0;
            OOP_DATETIME_S_T data = {0};
            DateTimeHex_t dateHex;
            memset(&dateHex,0,sizeof(DateTimeHex_t));
            
            time_t timep;
            time(&timep);
            OOP_DATETIME_S_T curData = {0};
            DT_Time2DateTimeShort(timep, &curData);
            
            memcpy(&data, convert.dstBuf, dOffset);
            PRTL_FMT_LOGCC("class8_invoke_act_time : curData.year = %hu\n", curData.year);
            PRTL_FMT_LOGCC("class8_invoke_act_time : curData.month = %d\n", curData.month);
            PRTL_FMT_LOGCC("class8_invoke_act_time : curData.day = %d\n", curData.day);
            PRTL_FMT_LOGCC("class8_invoke_act_time : curData.hour = %d\n", curData.hour);
            PRTL_FMT_LOGCC("class8_invoke_act_time : curData.minute = %d\n", curData.minute);
            PRTL_FMT_LOGCC("class8_invoke_act_time : curData.second = %d\n", curData.second);
            datetime_s_data_to_buf(data, &offset, (uint8 *)&dateHex);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.year = 0x%02x\n", dateHex.year_h);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.year = 0x%02x\n", dateHex.year_l);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.month = %d\n", dateHex.month);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.day = %d\n", dateHex.day);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.hour = %d\n", dateHex.hour);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.minute = %d\n", dateHex.min);
            PRTL_FMT_LOGCC("class8_invoke_act_time : dateHex.second = %d\n", dateHex.sec);

            if ((dateHex.month > 12) 
                ||(dateHex.day > 31)
                ||(dateHex.month == 2 && dateHex.day > 29)
                ||(dateHex.hour > 23)
                ||(dateHex.min > 59)
                ||(dateHex.sec > 59))
            {
                return DATA_SCOPE_OF_ACCESS_VIOLATED;
            }

            if(FALSE == systime_set((DateTimeHex_t*)&dateHex))
            {
                return DATA_SCOPE_OF_ACCESS_VIOLATED;
            }          
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_time
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_clock_src(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    uint32  offset  = 0;
    uint32 sOffset = 4;
    OOP_DAR_E dar = DATA_SUCCESS;

    //时钟源
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x40067f00:
    case 0x40068000:
        {
            if(inData[sOffset ++] != DT_NULL)
            {
                return DATA_TYPE_UNMATCHED;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

uint8 appmin_msg_creat_update_sys(OOP_SYS_UPDATE_T *app,uint8 *sendbuf)
{
    uint16 index=0;
    if(app->sysVersion.nNum>0)
    {
        sendbuf[index++] = app->sysVersion.nNum;
        memcpy(&sendbuf[index],app->sysVersion.value,app->sysVersion.nNum);
        index+=app->sysVersion.nNum;
    }else
    {
        sendbuf[index++] = 0;
    }
    sendbuf[index++]=app->updateType;
    
    OOP_APPFILE_INFO_T *file = &app->fileinfo;
    if(file->name.nNum >0)
    {
        sendbuf[index++]=file->name.nNum;
        memcpy(&sendbuf[index],file->name.value,file->name.nNum);
        index+=file->name.nNum;
    }else
    {
        sendbuf[index++] = 0;
    }
    if(file->type.nNum >0)
    {
        sendbuf[index++]=file->type.nNum;
        memcpy(&sendbuf[index],file->type.value,file->type.nNum);
        index+=file->type.nNum;
    }else
    {
        sendbuf[index++] = 0;
    }
    if(file->path.nNum >0)
    {
        sendbuf[index++]=file->path.nNum;
        memcpy(&sendbuf[index],file->path.value,file->path.nNum);
        index+=file->path.nNum;
    }else
    {
        sendbuf[index++] = 0;
    }
    memcpy_r(&sendbuf[index],&file->size,sizeof(uint32));
    index+=sizeof(uint32);
//    if(file->md5.nNum>0)
//    {
//        sendbuf[index++]=file->md5.nNum;
//        memcpy(&sendbuf[index],file->md5.value,file->md5.nNum);
//        index+=file->md5.nNum;
//    }else
//    {
//        sendbuf[index++] = 0;
//    }

    if(file->checkcode.choice == DT_OCTET_STRING)
    {
        sendbuf[index++]=file->checkcode.md5.nNum;
        memcpy(&sendbuf[index],file->checkcode.md5.value,file->checkcode.md5.nNum);
        index+=file->checkcode.md5.nNum;
    }
    else if(file->checkcode.choice == DT_CHECKSUM)
    {
        //sendbuf[index++] = file->checkcode.checksum.checktype;
        sendbuf[index++]=file->checkcode.checksum.checkcode.nNum;
        memcpy(&sendbuf[index],file->checkcode.checksum.checkcode.value,file->checkcode.checksum.checkcode.nNum);
        index+=file->checkcode.checksum.checkcode.nNum;
    }
    else
    {
        PRTL_FMT_DEBUG("校验类型错误choice = %d\n", file->checkcode.choice);
        sendbuf[index++] = 0;
    }
    OOP_APPFILE_SIGN_T *sign = &file->sign;
    if(sign->name.nNum==0 || sign->path.nNum == 0 || sign->name.value==NULL || sign->path.value == NULL)
    {
        sendbuf[index++] = 0;
    }
    else
    {
        sendbuf[index++] = 1;
        sendbuf[index++]=sign->name.nNum;
        memcpy(&sendbuf[index],sign->name.value,sign->name.nNum);
        index+=sign->name.nNum;
        sendbuf[index++]=sign->path.nNum;
        memcpy(&sendbuf[index],sign->path.value,sign->path.nNum);
        index+=sign->path.nNum;
        memcpy_r(&sendbuf[index],&sign->size,sizeof(uint32));
        index+=sizeof(uint32);
        
//        sendbuf[index++]=sign->md5.nNum;
//        memcpy(&sendbuf,sign->md5.value,sign->md5.nNum);
//        index+=sign->md5.nNum;

        if(sign->checkcode.choice == DT_OCTET_STRING)
        {
            sendbuf[index++]=sign->checkcode.md5.nNum;
            memcpy(&sendbuf[index],sign->checkcode.md5.value,sign->checkcode.md5.nNum);
            index+=sign->checkcode.md5.nNum;
        }
        else if(sign->checkcode.choice == DT_CHECKSUM)
        {
            //sendbuf[index++] = sign->checkcode.checksum.checktype;
            sendbuf[index++]=sign->checkcode.checksum.checkcode.nNum;
            memcpy(&sendbuf[index],sign->checkcode.checksum.checkcode.value,sign->checkcode.checksum.checkcode.nNum);
            index+=sign->checkcode.checksum.checkcode.nNum;
        }
        else
        {
            PRTL_FMT_DEBUG("校验类型错误choice = %d\n", sign->checkcode.choice);
            sendbuf[index++] = 0;
        }
    }
    return index;
}


/**
*********************************************************************
* @name：      class8_invoke_act_time
* @brief：     class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_update_sys(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    OOP_SYS_UPDATE_T data = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint16 sendlen = 0;
    uint8 sendbuf[1024] = {0};
    uint16 recvlen = 0;
    uint8 recvbuf[1024] = {0};
    
    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8*)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_sys_update(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }
    PRTL_FMT_DEBUG("系统升级操作, 升级后版本%s, 升级类型%d, 文件%s, 路径%s\n", 
                   data.sysVersion.value, data.updateType, data.fileinfo.name.value, data.fileinfo.path.value);
    sendlen = appmin_msg_creat_update_sys(&data,sendbuf);
    PRTL_BUF_DEBUG(sendbuf, sendlen,"升级消息:");
    dar = appmain_send_syncmsg(MSG_APPAMIN_UPDATE_SYS,sendbuf,sendlen,recvbuf,sizeof(recvbuf),&recvlen);
    if(dar!=ERR_OK || recvbuf[0] == 0)
    {
        PRTL_FMT_DEBUG("系统升级失败 \n");
        return DATA_OTHER_REASON;
    }

    PRTL_FMT_DEBUG("系统升级消息发送成功 \n");
    offset = 0;
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;
    

    return DATA_SUCCESS;
}

/**
*********************************************************************
* @name：      class8_invoke_act_telecon_trip
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_telecon_trip(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    uint32 i = 0;
    uint32 j = 0;
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;  

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class22_act failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x80008100:
        {
            OOP_TELECON_CLOSE_T dataActClose;
            OOP_TELECON_TRIP_T dataAct;
            OOP_TELECON_TRIP_T dataGet;
            BOOL   ifClearData = FALSE;
            uint8  turn = 0;
            uint8  data = 0;

            MEMZERO(&dataAct, sizeof(dataAct));
            MEMZERO(&dataGet, sizeof(dataGet));
            MEMZERO(&dataActClose, sizeof(dataActClose));
            memcpy(&dataAct, convert.dstBuf, dOffset);

            //检测是否保电状态
            normal.oad.value = 0x80010200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }
            if (data != 0)
            {
                //国网台体回正确
                memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
                offset += sizeof(OOP_OAD_U);
                outData->pResultData[offset ++] = 0x00;                            //DAR type
                outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
                outData->resultDataLen = offset;
                return DATA_SUCCESS;
            }

            //需要将主站下发的参数存入到dataGet，按8个轮次固定存储, 0 - 第一论； 1 - 第二论 ...... 
            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0x800081FF;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(OOP_TELECON_TRIP_T), (uint8*)&dataGet, &len);
            if(ret != ERR_OK)
            {
                MEMZERO(&dataGet, sizeof(dataGet));
                dataGet.nNum = 8;
            }
            
            for (i = 0; i < dataAct.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_act_telecon_trip : dataAct.trip[i].nRelayIdx = 0x%08x\n", dataAct.trip[i].nRelayIdx.value);
                PRTL_FMT_LOGCC("class8_invoke_act_telecon_trip : dataAct.trip[i].nWarnDelay = %d\n", dataAct.trip[i].nWarnDelay);
                PRTL_FMT_LOGCC("class8_invoke_act_telecon_trip : dataAct.trip[i].nTripTime = %d\n", dataAct.trip[i].nTripTime);
                PRTL_FMT_LOGCC("class8_invoke_act_telecon_trip : dataAct.trip[i].bAutoClose = %d\n", dataAct.trip[i].bAutoClose);

                if (dataAct.trip[i].bAutoClose > 1)
                {
                    return DATA_SCOPE_OF_ACCESS_VIOLATED;
                }

                if (dataAct.trip[i].nRelayIdx.value > 0xF2050200 + OOP_MAX_TRIP || 
                    dataAct.trip[i].nRelayIdx.value < 0xF2050201)
                {
                    PRTL_FMT_DEBUG("class8_invoke_act_telecon_trip err[%d] dataAct.trip[%d].nRelayIdx.value = 0x%08x\n",
                        DATA_OTHER_REASON, i, dataAct.trip[i].nRelayIdx.value);
                    return DATA_OTHER_REASON;
                }

                turn = dataAct.trip[i].nRelayIdx.value - 0xF2050201;
                memcpy(&dataGet.trip[turn], &dataAct.trip[i], sizeof(TELECON_TRIP));
            }

            //清除合闸数据，先读出跳闸数据，再判断是否要删除数据
            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0x800082FF;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(dataActClose), (uint8*)&dataActClose, &len);
            if ((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                ifClearData = FALSE;
            }
            else
            {
                for (i = 0; i < dataActClose.nNum; i++)
                {
                    for (j = 0; j < dataAct.nNum; j++)
                    {
                        if (dataActClose.close[i].nRelayIdx.value == dataAct.trip[j].nRelayIdx.value)
                        {
                            PRTL_FMT_DEBUG("delete dataActClose.trip[%d] oad(0x%08x)\n",
                                i, dataActClose.close[i].nRelayIdx.value);
                            MEMZERO(&dataActClose.close[i], sizeof(dataActClose.close[i]));
                            ifClearData = TRUE;
                            break;
                        }
                    }
                }
            }
            if (ifClearData)
            {
                ifClearData = FALSE;
                MEMZERO(&normal, sizeof(normal));
                normal.oad.value = 0x800082FF;
                normal.classtag = CLASS_DATA_INIT;
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataActClose, sizeof(dataActClose));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }
            }

            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0x800081FF;
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataGet, sizeof(OOP_TELECON_TRIP_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            
            sleep(2);//先写数据中心，防止控制投入标记先扫描到

            //提供实时查询遥控状态接口给控制模块
            for (i = 0; i < dataAct.nNum; i++)
            {
                if(dataAct.trip[i].nRelayIdx.value > 0xF2050200 + OOP_MAX_TRIP || 
                   dataAct.trip[i].nRelayIdx.value < 0xF2050201)
                {
                    PRTL_FMT_DEBUG("class8_invoke_act_telecon_trip err dataAct.trip[%d].nRelayIdx.value = 0x%08x\n",
                        i, dataAct.trip[i].nRelayIdx.value);
                    continue;
                }
                turn = dataAct.trip[i].nRelayIdx.value - 0xF2050201;
                set_remote_state_valid(turn + 1, 1);
                PRTL_FMT_DEBUG("set_remote_state_valid turn[%d], state[%d], type[%d], dataAct.trip[%d].nRelayIdx.value = 0x%08x\n",
                    turn + 1, 1, 1, i, dataAct.trip[i].nRelayIdx.value);
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }

    sleep(1);//送检时，电科院测试主站发送完拉合闸命令之后立马读取继电器合闸状态，为了避免状态刷新不及时，加上2s延时回码,可以保证状态量刷新过
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_telecon_close
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_telecon_close(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    uint32 i = 0;
    uint32 j = 0;
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class22_act failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
        case 0x80008200:
        {
            OOP_TELECON_CLOSE_T dataAct;
            OOP_TELECON_CLOSE_T dataGet;
            OOP_TELECON_TRIP_T  dataActTrip;
            BOOL   ifClearData = FALSE;
            uint8  turn = 0;

            MEMZERO(&dataAct, sizeof(dataAct));
            MEMZERO(&dataGet, sizeof(dataGet));
            MEMZERO(&dataActTrip, sizeof(dataActTrip));
            memcpy(&dataAct, convert.dstBuf, dOffset);

            //需要将主站下发的参数存入到dataGet，按8个轮次固定存储, 0 - 第一论； 1 - 第二论 ......
            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0x800082FF;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(OOP_TELECON_CLOSE_T), (uint8*)&dataGet, &len);
            if(ret != ERR_OK)
            {
                MEMZERO(&dataGet, sizeof(dataGet));
                dataGet.nNum = 8;
            }

            OOP_SWITCHOUT_T tSwitch;
            /* 如果存在跳闸, 返回失败 */
            normal.oad.value = 0xF2050200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(OOP_SWITCHOUT_T), (uint8*)&tSwitch, &len);
            if(0 == ret)
            {
                /* 直接合闸操作判断 前一半是跳闸继电器, 后一半是合闸继电器 */
                for(i = 0; i < dataAct.nNum; i++)
                {
                    if(0 == dataAct.close[i].nState || dataAct.close[i].nRelayIdx.value <= 0xF2050200 + OOP_MAX_TRIP / 2)
                    {
                        continue;
                    }
                    for(j = 0; j < tSwitch.nNum / 2; j++)
                    {
                        if(1 == tSwitch.value[j].current && 
                           dataAct.close[i].nRelayIdx.value == 0xF2050200 + OOP_MAX_TRIP / 2 + j + 1)
                        {
                            /* 存在允许合闸 返回错误 */
                            PRTL_FMT_DEBUG("轮次%d动作中，不允许直接合闸\n", j + 1);
                            return DATA_OTHER_REASON;
                        }
                    }
                }
            }
            
            for (i = 0; i < dataAct.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_act_telecon_close : dataAct.close[i].nRelayIdx = 0x%08x\n", dataAct.close[i].nRelayIdx);
                PRTL_FMT_LOGCC("class8_invoke_act_telecon_close : dataAct.close[i].nState = %d\n", dataAct.close[i].nState);

                if (dataAct.close[i].nState > 1)
                {
                    return DATA_SCOPE_OF_ACCESS_VIOLATED;
                }

                if (dataAct.close[i].nRelayIdx.value > 0xF2050200 + OOP_MAX_TRIP || 
                    dataAct.close[i].nRelayIdx.value < 0xF2050201)
                {
                    PRTL_FMT_DEBUG("class8_invoke_act_telecon_close err[%d] dataAct.close[%d].nRelayIdx.value = 0x%08x\n",
                        DATA_OTHER_REASON, i, dataAct.close[i].nRelayIdx.value);
                    return DATA_OTHER_REASON;
                }

                turn = dataAct.close[i].nRelayIdx.value - 0xF2050201;
                memcpy(&dataGet.close[turn], &dataAct.close[i], sizeof(TELECON_CLOSE));
            }

            //清除跳闸数据，先读出跳闸数据，再判断是否要删除数据
            normal.oad.value = 0x800081FF;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(dataActTrip), (uint8*)&dataActTrip, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                ifClearData = FALSE;
            }
            else
            {
                for (i = 0; i < dataActTrip.nNum; i++)
                {
                    for (j = 0; j < dataAct.nNum; j++)
                    {
                        if (dataActTrip.trip[i].nRelayIdx.value == dataAct.close[j].nRelayIdx.value)
                        {
                            PRTL_FMT_DEBUG("delete dataActTrip.trip[%d] oad(0x%08x)\n",
                                i, dataActTrip.trip[i].nRelayIdx.value);
                            MEMZERO(&dataActTrip.trip[i], sizeof(dataActTrip.trip[i]));
                            ifClearData = TRUE;
                            break;
                        }
                    }
                }
            }
            if (ifClearData)
            {
                ifClearData = FALSE;
                MEMZERO(&normal, sizeof(normal));
                normal.oad.value = 0x800081FF;
                normal.classtag = CLASS_DATA_INIT;
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataActTrip, sizeof(OOP_TELECON_TRIP_T));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                    return DATA_OTHER_REASON;
                }
            }

            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0x800082FF;
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataGet, sizeof(OOP_TELECON_CLOSE_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            
            sleep(2);//先写数据中心，防止控制投入标记先扫描到

            //提供实时查询遥控状态接口给控制模块
            for (i = 0; i < dataAct.nNum; i++)
            {
                if (dataAct.close[i].nRelayIdx.value > 0xF2050200 + OOP_MAX_TRIP || 
                    dataAct.close[i].nRelayIdx.value < 0xF2050201)
                {
                    PRTL_FMT_DEBUG("class8_invoke_act_telecon_trip err dataAct.close[%d].nRelayIdx.value = 0x%08x\n",
                        i, dataAct.close[i].nRelayIdx.value);
                    continue;
                }
                turn = dataAct.close[i].nRelayIdx.value - 0xF2050201;
                if(0 == dataAct.close[i].nState)
                {
                    set_remote_state_valid(turn + 1, 2);
                }
                else
                {
                    /* 直接合闸 */
                    set_remote_state_valid(turn + 1, 3);
                }
                
                PRTL_FMT_DEBUG("set_remote_state_valid turn[%d], state[%d], type[%d], dataAct.close[%d].nRelayIdx.value = 0x%08x\n",
                    turn + 1, 1, 2, i, dataAct.close[i].nRelayIdx.value);
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    sleep(1);//送检时，电科院测试主站发送完拉合闸命令之后立马读取继电器合闸状态，为了避免状态刷新不及时，加上1s延时回码,可以保证状态量刷新过
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;
    
    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_guard_on
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_guard_on(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint32 sOffset = 4;
    uint32 offset  = 0;
    int ret = ERR_NORMAL;

    if (inData[sOffset] != DT_NULL)
    {
        dar = DATA_DATA_BLOCK_UNAVAILABLE;
        PRTL_FMT_DEBUG("class8_invoke_act_guard_on err dar[%d]\n", dar);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80017f00:
        {
            uint8 data = 1;

            set_guard_state(1);

            normal.oad.value = 0x80010200;   
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_guard_off
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_guard_off(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint32 sOffset = 4;
    uint32 offset  = 0;
    CLEAR_DATA_T RecordDel;
    int ret = ERR_NORMAL;

    if (inData[sOffset] != DT_NULL)
    {
        dar = DATA_DATA_BLOCK_UNAVAILABLE;
        PRTL_FMT_DEBUG("class8_invoke_act_guard_off err dar[%d]\n", dar);
        return dar;
    }

    MEMZERO(&RecordDel, sizeof(RecordDel));

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80018000:
        {
            uint8 data = 0;

            set_guard_state(2);
            CTRL_FMT_DEBUG("规约解除保电\n");

            normal.oad.value = 0x80010200;   
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            RecordDel.recordOAD.logicId = 0;
            RecordDel.recordOAD.infoNum = 0;
            RecordDel.recordOAD.classtag = CLASS_DATA_INIT;
            RecordDel.recordOAD.road.oadMain.value = 0;
            RecordDel.recordOAD.road.oadCols.nNum = 1;
            RecordDel.recordOAD.road.oadCols.oad[0].value = 0x80010500;
            RecordDel.bClassTag = FALSE;

            //解除保电时把自动保电的时段也删掉
            ret = db_clear_oad_data(pApduInfo->hUdp, &RecordDel);
            if (ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("clear auto guard time err[%d]\n", ret);
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_auto_guard_off
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_auto_guard_off(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint32 sOffset = 4;
    uint32 offset  = 0;
    CLEAR_DATA_T RecordDel;
    int ret = ERR_NORMAL;
    uint32 len = 0;

    if (inData[sOffset] != DT_NULL)
    {
        dar = DATA_DATA_BLOCK_UNAVAILABLE;
        PRTL_FMT_DEBUG("class8_invoke_act_auto_guard_off err dar[%d]\n", dar);
        return dar;
    }

    MEMZERO(&RecordDel, sizeof(RecordDel));

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80018100:
        {
            uint8 data = 0;

            normal.oad.value = 0x80010200;
            ret = db_read_nomal(pApduInfo->hUdp, &normal, sizeof(data), (uint8*)&data, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            if (data == 2)
            {
                set_guard_state(2);
                CTRL_FMT_DEBUG("规约解除自动保电\n");
                data = 0;
                MEMZERO(&normal, sizeof(normal));
                normal.oad.value = 0x80010200;
                normal.classtag = CLASS_DATA_INIT;
                ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
                if(ret != ERR_OK)
                {
                    PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                        ret, normal.logicId, normal.infoNum, normal.oad.value);
                }
            }

            RecordDel.recordOAD.logicId = 0;
            RecordDel.recordOAD.infoNum = 0;
            RecordDel.recordOAD.classtag = CLASS_DATA_INIT;
            RecordDel.recordOAD.road.oadMain.value = 0;
            RecordDel.recordOAD.road.oadCols.nNum = 1;
            RecordDel.recordOAD.road.oadCols.oad[0].value = 0x80010500;
            RecordDel.bClassTag = FALSE;

            //解除保电时把自动保电的时段也删掉
            ret = db_clear_oad_data(pApduInfo->hUdp, &RecordDel);
            if (ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("clear auto guard time err[%d]\n", ret);
            }

            MEMZERO(&RecordDel, sizeof(RecordDel));
            RecordDel.recordOAD.logicId = 0;
            RecordDel.recordOAD.infoNum = 0;
            RecordDel.recordOAD.classtag = CLASS_DATA_INIT;
            RecordDel.recordOAD.road.oadMain.value = 0;
            RecordDel.recordOAD.road.oadCols.nNum = 1;
            RecordDel.recordOAD.road.oadCols.oad[0].value = 0x80010400;
            RecordDel.bClassTag = FALSE;

            //解除保电时把上电保电的时段也删掉
            ret = db_clear_oad_data(pApduInfo->hUdp, &RecordDel);
            if (ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("clear boot guard time err[%d]\n", ret);
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_auto_guard_off
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_payment_on(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_act failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80027F00:
        {
            uint8 data = 1;
            OOP_CALLFEE_T dataAct;
            
            MEMZERO(&dataAct, sizeof(dataAct));
            memcpy(&dataAct, convert.dstBuf, dOffset);
            PRTL_BUF_LOGCC(dataAct.period, 3, "class8_invoke_act_payment_on dataAct.period:");
            PRTL_BUF_LOGCC(dataAct.info, dataAct.nLen, "class8_invoke_act_payment_on dataAct.info:");

            normal.oad.value = 0x80020300;   
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataAct, sizeof(OOP_CALLFEE_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }

            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0x80027FFF;   
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(uint8));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    sleep(3);

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_auto_guard_off
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_payment_off(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint32 sOffset = 4;
    uint32 offset  = 0;

    if (inData[sOffset] != DT_NULL)
    {
        PRTL_FMT_DEBUG("class8_invoke_act_payment_off err inData[4] = [%d]\n", inData[sOffset]);
        return DATA_DATA_BLOCK_UNAVAILABLE;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0x80028000:
        {
            uint8 dataAct = 0;

            normal.oad.value = 0x80027FFF;   
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataAct, sizeof(uint8));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    sleep(2); //延时2s操作
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    sleep(2);

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_packlog_upload
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_log_delect(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32 sOffset = 4;
    uint32 offset  = 0;
    uint8 sendbuf[1024] = {0};
    uint8 recvbuf[1024] = {0};
    uint16 recvlen = 0;
    switch (pOadInfo->pTab->oad.value)
    {
        case 0xF4008000:
        {
            OOP_VISIBLEVAR128_T logpath;
            logpath.nNum = inData[sOffset++];
            memcpy(logpath.value,&inData[sOffset],logpath.nNum);
            sOffset+=logpath.nNum;
            sendbuf[offset++] =0; //日志文件路径 [0]  visible-string，
            sendbuf[offset++] = logpath.nNum;
            memcpy(&sendbuf[offset],logpath.value,logpath.nNum);
            offset+=logpath.nNum;
        }
        case 0xF4008100:
        {
            sendbuf[offset++] = 1;
            sendbuf[offset++] = 0;

        }
    }
    ret = appmain_send_syncmsg_time(MSG_APPAMIN_LOG_DELECT,sendbuf,offset,recvbuf,sizeof(recvbuf),&recvlen, 60);
    if(ret!=ERR_OK)
    {
        PRTL_FMT_DEBUG("日志删除失败 \n");
        return DATA_OBJECT_UNDEFINED;
    }
    offset = 0;
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
                                //DAR type
                           //DATA:NULL
        outData->pResultData[offset ++] = 0x01;
        outData->pResultData[offset ++] = recvbuf[0];

    outData->resultDataLen = offset;
    
    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_packlog_upload
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_packlog_upload(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32 sOffset = 4;
    uint32 offset  = 0;
    uint8 sendbuf[1024] = {0};
    uint8 recvbuf[1024] = {0};
    uint16 recvlen = 0;
    OOP_VISIBLEVAR128_T logpath,packpath;
    memset(&logpath,0,sizeof(logpath));
    memset(&packpath,0,sizeof(packpath));
    if(inData[sOffset++]!= DT_STRUCTURE)
        return DATA_OBJECT_UNDEFINED;
    if(inData[sOffset++]!= 2)
        return DATA_OBJECT_UNDEFINED;
    if(inData[sOffset++]!= DT_VISIBLE_STRING)
        return DATA_OBJECT_UNDEFINED;
    logpath.nNum = inData[sOffset++];
    if(logpath.nNum != 0)
    {
        memcpy(logpath.value,&inData[sOffset],logpath.nNum);
        sOffset+=logpath.nNum;
    }
    if(inData[sOffset++]!= DT_VISIBLE_STRING)
        return DATA_OBJECT_UNDEFINED;
    packpath.nNum = inData[sOffset++];
    if(packpath.nNum!=0)
    {
        memcpy(packpath.value,&inData[sOffset],packpath.nNum);
        sOffset+=packpath.nNum;
    }

    if(logpath.nNum == 0)     //
    {
        sendbuf[offset++] = 1;
        sendbuf[offset++] = 0;
    }
    else
    {
        sendbuf[offset++] = 0;
        sendbuf[offset++] = logpath.nNum;
        memcpy(&sendbuf[offset],logpath.value,logpath.nNum);
        offset+=logpath.nNum;
    }
    if(packpath.nNum == 0)     //
    {
        sendbuf[offset++] = 0;
    }
    else
    {
        sendbuf[offset++] = 1;
        sendbuf[offset++] = packpath.nNum;
        memcpy(&sendbuf[offset],packpath.value,packpath.nNum);
        offset+=packpath.nNum;
    }
    ret = appmain_send_syncmsg_time(MSG_APPAMIN_LOG_PACKAGE,sendbuf,offset,recvbuf,sizeof(recvbuf),&recvlen, 60);
    if(ret!=ERR_OK)
    {
        PRTL_FMT_DEBUG("获取打包日志信息失败 \n");
        return DATA_OBJECT_UNDEFINED;
    }
    offset = 0;
    memset(&packpath,0,sizeof(packpath));
    packpath.nNum = recvbuf[offset++];
    memcpy(packpath.value,&recvbuf[offset],packpath.nNum);
    offset+=packpath.nNum; 
    offset = 0;
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
                                //DAR type
    //outData->pResultData[offset ++] = DT_ARRAY;                            //DATA:NULL
    if(packpath.nNum != 0 )
    {
        outData->pResultData[offset ++] = dar;
        outData->pResultData[offset ++] = 0x01;
        outData->pResultData[offset ++] = DT_VISIBLE_STRING;
        outData->pResultData[offset ++] = packpath.nNum;
        memcpy(&outData->pResultData[offset],packpath.value,packpath.nNum);
        offset+=packpath.nNum;
    }
    else
    {
        outData->pResultData[offset ++] = 0x01;
        outData->pResultData[offset ++] = 0;
    }

    outData->resultDataLen = offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_act_clear_scuritymod
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_clear_scuritymod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    CLEAR_DATA_T delData;
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_act failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xf1010100:
        {
            uint8 dataAct;
            MEMZERO(&dataAct, sizeof(dataAct));
            MEMZERO(&delData, sizeof(delData));
            memcpy(&dataAct, convert.dstBuf, dOffset);
            PRTL_FMT_TRACE("class8_invoke_act_clear_scuritymod dataAct:%d\n", dataAct);

            delData.recordOAD.logicId = 0x00;
            delData.recordOAD.optional = 0;
            delData.recordOAD.classtag = CLASS_DATA_INIT;
            delData.recordOAD.road.oadMain.value = 0x00;
            delData.recordOAD.road.oadCols.nNum = 1;
            delData.recordOAD.road.oadCols.oad[0].value = 0xf1010300;
            delData.bClassTag = FALSE;
            delData.recordOAD.infoNum = 0;

            ret = db_clear_oad_data(pApduInfo->hUdp, &delData);
            if (ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("class8_invoke_act_clear_scuritymod err = %d\n", ret);
                return DATA_READ_WRITE_DENIED;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_add_scuritymod
* @brief：     class8的ACT服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_add_scuritymod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;
    uint32 i = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1017f00:
        {
            OOP_SCURITYMODE_T dataGet;
            SECURITYMODE data;
            MEMZERO(&dataGet, sizeof(dataGet));
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0xF1010300;

            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&dataGet, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_DEBUG("读出显示安全模式: data.nNum = %d\n", dataGet.nNum);
            for (i = 0; i < MIN(dataGet.nNum, OOP_MAX_SECURITYOBJ); i++)
            {
                PRTL_FMT_DEBUG("读出显示安全模式: data.mode[%d].object = 0x%04x\n", i, dataGet.mode[i].object);
                PRTL_FMT_DEBUG("读出显示安全模式: data.mode[%d].access = 0x%04x\n", i, dataGet.mode[i].access);
            }

            //检测原有列表中是否存在，存在则改，不在则增加
            for (i = 0; i < MIN(dataGet.nNum, OOP_MAX_SECURITYOBJ); i++)
            {
                if (dataGet.mode[i].object == data.object)
                {
                    dataGet.mode[i].access = data.access;
                    break;
                }
            }
            if (i == dataGet.nNum)
            {
                if (dataGet.nNum < OOP_MAX_SECURITYOBJ)
                {
                    dataGet.mode[i].object = data.object;
                    dataGet.mode[i].access = data.access;
                    dataGet.nNum ++;
                }
            }
            PRTL_FMT_DEBUG("修改显示安全模式: data.nNum = %d\n", dataGet.nNum);
            for (i = 0; i < dataGet.nNum; i++)
            {
                PRTL_FMT_DEBUG("修改显示安全模式: data.mode[%d].object = 0x%04x\n", i, dataGet.mode[i].object);
                PRTL_FMT_DEBUG("修改显示安全模式: data.mode[%d].access = 0x%04x\n", i, dataGet.mode[i].access);
            }

            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0xF1010300;
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataGet, sizeof(OOP_SCURITYMODE_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_del_scuritymod
* @brief：     class8的ACT服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_del_scuritymod(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;
    uint32 i = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1018000:
        {
            OOP_SCURITYMODE_T dataGet;
            OI data;
            MEMZERO(&dataGet, sizeof(dataGet));
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0xF1010300;

            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&dataGet, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_act_del_scuritymod : data.nNum = %d\n", dataGet.nNum);
            for (i = 0; i < MIN(dataGet.nNum, OOP_MAX_SECURITYOBJ); i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_act_del_scuritymod : data.mode[%d].object = 0x%04x\n", i, dataGet.mode[i].object);
                PRTL_FMT_LOGCC("class8_invoke_act_del_scuritymod : data.mode[%d].access = 0x%04x\n", i, dataGet.mode[i].access);
            }

            //删除相应的OI
            for (i = 0; i < MIN(dataGet.nNum, OOP_MAX_SECURITYOBJ); i++)
            {
                if (dataGet.mode[i].object == data)
                {
                    dataGet.mode[i].access = 0;
                    break;
                }
            }
            if (i < dataGet.nNum)
            {
                if (dataGet.nNum > 0)
                {
                    dataGet.nNum --;
                }
            }

            PRTL_FMT_LOGCC("class8_invoke_act_del_scuritymod after modify : data.nNum = %d\n", dataGet.nNum);
            for (i = 0; i < dataGet.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_act_del_scuritymod after modify : data.mode[%d].object = 0x%04x\n", i, dataGet.mode[i].object);
                PRTL_FMT_LOGCC("class8_invoke_act_del_scuritymod after modify : data.mode[%d].access = 0x%04x\n", i, dataGet.mode[i].access);
            }

            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0xF1010300;
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataGet, sizeof(OOP_SCURITYMODE_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}


/**
*********************************************************************
* @name：      class8_invoke_act_add_scuritymod_list
* @brief：     class8的ACT服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_add_scuritymod_list(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint8 data[BUF_LEN_MAX] = {0};
    DATA_CONVERT_T convert;
    uint32 sOffset = 4;
    uint32 dOffset = 0;
    uint32 offset  = 0;
    uint32 len = 0;
    uint32 i = 0;
    uint32 j = 0;
    uint32 num = 0;

    MEMZERO(&data, sizeof(data)); 
    MEMZERO(&convert, sizeof(convert)); 

    convert.srcBuf = (uint8 *)inData;
    convert.srcLen = InDataLen;
    convert.sOffset = &sOffset;

    convert.dstBuf = &data;
    convert.dstLen = sizeof(data);
    convert.dOffset = &dOffset;  

    //从报文中提取数据
    dar = buf_to_data_class8_act(pOadInfo, &convert);
    if(dar != DATA_SUCCESS)
    {
        PRTL_BUF_DEBUG(&inData[sOffset], InDataLen-sOffset, "buf_to_data_class8_set failed. dar(%d), oad(0x%08x)\n", dar, pOadInfo->pTab->oad.value);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xF1018100:
        {
            OOP_SCURITYMODE_T dataGet;
            OOP_SCURITYMODE_T data;
            MEMZERO(&dataGet, sizeof(dataGet));
            memcpy(&data, convert.dstBuf, dOffset);
            normal.oad.value = 0xF1010300;

            ret = db_read_nomal(pApduInfo->hUdp, &normal, pOadInfo->pTab->dataLen, (uint8*)&dataGet, &len);
            if((ret != ERR_OK) || (len == 0))
            {
                PRTL_FMT_DEBUG("db_read_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
            }

            PRTL_FMT_LOGCC("class8_invoke_act_add_scuritymod_list : data.nNum = %d\n", dataGet.nNum);
            for (i = 0; i < dataGet.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_act_add_scuritymod_list : data.mode[%d].object = 0x%04x\n", i, dataGet.mode[i].object);
                PRTL_FMT_LOGCC("class8_invoke_act_add_scuritymod_list : data.mode[%d].access = 0x%04x\n", i, dataGet.mode[i].access);
            }

            //检测原有列表中是否存在，存在则改，不在则增加
            num = MIN(dataGet.nNum, OOP_MAX_SECURITYOBJ);
            for (i = 0; i < MIN(data.nNum, OOP_MAX_SECURITYOBJ); i++)
            {
                for (j = 0; j < num; j++)
                {
                    if (dataGet.mode[j].object == data.mode[i].object)
                    {
                        dataGet.mode[j].access = data.mode[i].access;
                        break;
                    }
                }
                //不在已有列表中，就添加后面
                if (j == num)
                {
                    if (dataGet.nNum < OOP_MAX_SECURITYOBJ)
                    {
                        dataGet.mode[dataGet.nNum].object = data.mode[i].object;
                        dataGet.mode[dataGet.nNum].access = data.mode[i].access;
                        dataGet.nNum ++;
                    }
                }
            }

            PRTL_FMT_LOGCC("class8_invoke_act_add_scuritymod_list after modify : data.nNum = %d\n", dataGet.nNum);
            for (i = 0; i < dataGet.nNum; i++)
            {
                PRTL_FMT_LOGCC("class8_invoke_act_add_scuritymod_list after modify : data.mode[%d].object = 0x%04x\n", i, dataGet.mode[i].object);
                PRTL_FMT_LOGCC("class8_invoke_act_add_scuritymod_list after modify : data.mode[%d].access = 0x%04x\n", i, dataGet.mode[i].access);
            }

            MEMZERO(&normal, sizeof(normal));
            normal.oad.value = 0xF1010300;
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&dataGet, sizeof(OOP_SCURITYMODE_T));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_inner_security_flag
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_inner_security_flag(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    OOP_DAR_E dar = DATA_SUCCESS;
    NOMAL_OAD_T normal = {0};
    uint32 sOffset = 4;
    uint32 offset  = 0;
    int ret = ERR_NORMAL;

    if (inData[sOffset] != DT_NULL)
    {
        dar = DATA_DATA_BLOCK_UNAVAILABLE;
        PRTL_FMT_DEBUG("class8_invoke_act_inner_security_flag err dar[%d]\n", dar);
        return dar;
    }

    //写入数据
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xfff06600:
        {
            OOP_SECURITYFLAG_E data = SECURITY_OFF;
            normal.oad.value = 0xF1010200;   
            normal.classtag = CLASS_DATA_INIT;
            ret = db_write_nomal(pApduInfo->hUdp, &normal, (uint8*)&data, sizeof(data));
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_write_nomal failed. ret(%d), logicId(%d), infoNum(%d), oad(0x%08x)\n",
                    ret, normal.logicId, normal.infoNum, normal.oad.value);
                return DATA_OTHER_REASON;
            }
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_all_param_init(厂家自定义参数)
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_all_param_init(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    uint32  offset  = 0;
    uint8 logicAddr = pApduInfo->logicAddr;

    ret = db_recover_default(pApduInfo->hUdp, logicAddr);
    if(ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("db_recover_default failed. ret(%d), logicId(%d)\n",
        ret, logicAddr);

        return DATA_OTHER_REASON;
    }
    else
    {
        PRTL_FMT_DEBUG("db_recover_default ok. ret(%d), logicId(%d)\n",
        ret, logicAddr);
    }

    ret = param_init_sent_to_acmeter();
    if (ret != ERR_OK)
    {
        PRTL_FMT_DEBUG("param_init_sent_to_acmeter err. ret(%d), logicId(%d)\n",
        ret, logicAddr);
        return DATA_HARDWARE_FAULT;
    }

    // 值复位标记，交采参数初始化成功后复位
    set_reset_flag(pApduInfo->hUdp, TMN_RBT_DELAY_20S);

    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_all_data_clear(厂家自定义参数)
* @brief：     class8的ACTION服务
* @param[in] ：pOdaInfo       OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_all_data_clear(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    int ret = ERR_OK;
    OOP_DAR_E dar = DATA_SUCCESS;
    CLEAR_DATA_T clrData;
    uint32  offset  = 0;
    uint8 logicAddr = 0;

    MEMZERO(&clrData, sizeof(clrData));

    //数据初始化操作
    switch (pOadInfo->pTab->oad.value)
    {
    case 0xfff0d400:
        {
            logicAddr = pApduInfo->logicAddr;
            clrData.recordOAD.logicId = logicAddr;
            clrData.bClassTag = FALSE;

            //clrData.recordOAD.classtag = CLASS_DATA_INIT;
            ret = db_clear_data(pApduInfo->hUdp, &clrData);
            if(ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("db_clear_data failed. ret(%d), logicId(%d)\n",
                    ret, logicAddr);

                //台体测试显示数据初始化有时会失败，先注释掉
                //return DATA_OTHER_REASON;
            }
            else
            {
                PRTL_FMT_DEBUG("db_clear_data ok. ret(%d), logicId(%d)\n",
                    ret, logicAddr);
            }

            // clrData.recordOAD.classtag = CLASS_DATA_NORMAL;
            // ret = db_clear_data(pApduInfo->hUdp, &clrData);
            // if (ret != ERR_OK)
            // {
            //     PRTL_FMT_DEBUG("db_clear_data failed. ret(%d), logicId(%d)\n",
            //         ret, logicAddr);
            //     return DATA_OTHER_REASON;
            // }
            // else
            // {
            //     PRTL_FMT_DEBUG("db_clear_data ok. ret(%d), logicId(%d)\n",
            //         ret, logicAddr);
            // }

            ret = data_init_sent_to_acmeter();
            if (ret != ERR_OK)
            {
                PRTL_FMT_DEBUG("data_init_sent_to_acmeter err. ret(%d), logicId(%d)\n",
                ret, logicAddr);
                return DATA_HARDWARE_FAULT;
            }

            inner_data_init(PRTL_INIT_DATA, pApduInfo->hUdp);
        }
        break;
    
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    
    memcpy(&outData->pResultData[offset], inData, sizeof(OOP_OAD_U));  //OMD
    offset += sizeof(OOP_OAD_U);
    outData->pResultData[offset ++] = 0x00;                            //DAR type
    outData->pResultData[offset ++] = 0x00;                            //DATA:NULL
    outData->resultDataLen = offset;

    return dar;
}

/**
*********************************************************************
* @name：      class8_invoke_act_oia_40
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_oia_40(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0x4000:
        {
            switch (pOadInfo->pTab->oad.value)
            {
            case 0x40007f00:
                {
                    return class8_invoke_act_time(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;        
            default:
                break;
            }
        }
        break;
    case 0x4006:
        {
            switch (pOadInfo->pTab->oad.value)
            {
            case 0x40068000:
            case 0x40067f00:
                {
                    return class8_invoke_act_clock_src(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;        
            default:
                break;
            }
        }
        break;
    case 0x4038:
        {
            switch (pOadInfo->pTab->oad.value)
            {
            case 0x40388000:
                {
                    return class8_invoke_act_update_sys(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                }
                break;        
            default:
                break;
            }
        }
        break; 
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_act_oia_80
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_oia_80(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    //遥控和保电必须带时间标签
    if (((pOadInfo->pTab->oad.nObjID == 0x8000) || (pOadInfo->pTab->oad.nObjID == 0x8001)) && 
        (pApduInfo->connectionInfo.timeTag.tagFlag == 0))
    {
        return DATA_TIMEFLAG_INVALID;
    }

    switch (pOadInfo->pTab->oad.nObjID)
    {
        case 0x8000:
        {
            switch (pOadInfo->pTab->oad.value)
            {
             case 0x80007f00:
                {
                }
                break;    
            case 0x80008000:
                {
                }
                break;    
            case 0x80008100:
                {
                    return class8_invoke_act_telecon_trip(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;  
            case 0x80008200:
                {
                    return class8_invoke_act_telecon_close(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;  
            default:
                break;
            }
            break;  
        }
        
        case 0x8001:
        {
            switch (pOadInfo->pTab->oad.value)
            {
                case 0x80017f00:
                {
                    return class8_invoke_act_guard_on(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                  
                case 0x80018000:
                {
                    return class8_invoke_act_guard_off(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }  
                case 0x80018100:
                {
                    return class8_invoke_act_auto_guard_off(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                } 
                default: break;
            }
        }
        case 0x8002:
        {
            switch (pOadInfo->pTab->oad.value)
            {
            case 0x80027f00:
                {
                    return class8_invoke_act_payment_on(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;    
            case 0x80028000:
                {
                    return class8_invoke_act_payment_off(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;     
            default:
                break;
            }
            break;
        }
        default: return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_act_oia_f1
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_log_f4(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xf400:
        {
            switch (pOadInfo->pTab->oad.value)
            { 
            case 0xf4007f00:
                {
                    return class8_invoke_act_packlog_upload(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break; 
            case 0xf4008000:
            case 0xf1018100:
                {
                    return class8_invoke_act_log_delect(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break; 
            default:
                break;
            }
        }
        break;  
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    return DATA_OBJECT_UNAVAILABLE;
}


/**
*********************************************************************
* @name：      class8_invoke_act_oia_f1
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_oia_f1(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xf101:
        {
            switch (pOadInfo->pTab->oad.value)
            {
            case 0xf1010100:
                {
                    return class8_invoke_act_clear_scuritymod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;  
            case 0xf1017f00:
                {
                    return class8_invoke_act_add_scuritymod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break; 
            case 0xf1018000:
                {
                    return class8_invoke_act_del_scuritymod(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break; 
            case 0xf1018100:
                {
                    return class8_invoke_act_add_scuritymod_list(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break; 
            default:
                break;
            }
        }
        break;  
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：      class8_invoke_act_oia_ff
* @brief：     class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act_oia_ff(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->oad.nObjID)
    {
    case 0xfff0:
        {
            switch (pOadInfo->pTab->oad.value)
            {
            case 0xfff06600:
                {
                    return class8_invoke_act_inner_security_flag(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;  
            case 0xfff0d300:
                {
                    return class8_invoke_act_all_param_init(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;
            case 0xfff0d400:
                {
                    return class8_invoke_act_all_data_clear(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;
            default:
                break;
            }
        }
        break;  
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_set
* @brief：      class8的SET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_set(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->OIA1)
    {
        case 0x02:
        {
            switch (pOadInfo->pTab->OIA2)
            {
                case 0x00:
                {
                    return class8_invoke_set_oia_20(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                default:
                    return DATA_OBJECT_UNAVAILABLE;
            }
        }
        break;
        case 0x04:
        {
            switch (pOadInfo->pTab->OIA2)
            {
                case 0x00:
                {
                    return class8_invoke_set_oia_40(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                case 0x01:
                {
                    return class8_invoke_set_oia_41(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                case 0x02:
                {
                    return class8_invoke_set_oia_42(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                case 0x04:
                {
                    return class8_invoke_set_oia_44(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                case 0x05:
                {
                    return class8_invoke_set_oia_45(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                case 0x09:
                {
                    return class8_invoke_set_oia_49(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                default:
                    return DATA_OBJECT_UNAVAILABLE;
            }
        }
        break;

        case 0x0f:
        {
            switch (pOadInfo->pTab->OIA2)
            {
                case 0x01:
                {
                    return class8_invoke_set_oia_f1(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;
                case 0x0f:
                {
                    return class8_invoke_set_oia_ff(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;

        case 0x08:
        {
            switch (pOadInfo->pTab->OIA2)
            {
                case 0x00:
                {
                    return class8_invoke_set_oia_80(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;
                case 0x01:
                {
                    return class8_invoke_set_oia_81(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                }
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;
        case 0x06:
        {
            switch (pOadInfo->pTab->OIA2)
            {
#ifdef AREA_HUNAN
            case 0x00:
            {
                return class8_invoke_set_oia_60(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax); 
                break;
            }
#endif
#if AREA_FUJIAN
            case 0x0e:
            {
                return class8_invoke_set_oia_6e_fj(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            }
#endif
        default:
            return DATA_OBJECT_UNAVAILABLE;
            }
        }
    }
    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_get
* @brief：      class8的GET服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_get(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint16 InDataLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->OIA1)
    {
        case 0x02:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x00:
                return class8_invoke_get_oia_20(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;

        case 0x04:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x00:
                return class8_invoke_get_oia_40(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            case 0x01:
                return class8_invoke_get_oia_41(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            case 0x02:
                return class8_invoke_get_oia_42(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            case 0x04:
                return DATA_READ_WRITE_DENIED;
            case 0x05:
                return class8_invoke_get_oia_45(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            case 0x07:
                return class8_invoke_get_oia_47(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            case 0x09:
                return class8_invoke_get_oia_49(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            case 0x0E:
                return class8_invoke_get_oia_4E(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
            default:
                return DATA_OBJECT_UNAVAILABLE;
            }
        }
        break;

        case 0x0F:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x01:
                return class8_invoke_get_oia_f1(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            case 0x0f:
                return class8_invoke_get_oia_ff(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            case 0x04:
                return class8_invoke_get_oia_f4(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                    break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;

        case 0x08:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x00:
                return class8_invoke_get_oia_80(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            case 0x01:
                return class8_invoke_get_oia_81(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;
        case 0x06:
        {
            switch (pOadInfo->pTab->OIA2)
            {
#ifdef AREA_HUNAN
            case 0x00:
                return class8_invoke_get_oia_60(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
#endif
#ifdef AREA_FUJIAN
            case 0x0e:
            {
                return class8_invoke_get_oia_6e_fj(pOadInfo, pApduInfo, inData, InDataLen, outData, outDataMax);
                break;
            }
#endif
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        default:
            return DATA_OBJECT_UNAVAILABLE;
    }

    return DATA_OBJECT_UNAVAILABLE;
}

/**
*********************************************************************
* @name：       class8_invoke_act
* @brief：      class8的ACTION服务
* @param[in] ：pOdaInfo        OAD信息
               pBpInfo        应用分帧断点信息
               inData         输入报文，不含OAD
               inLen          输入报文长度
               outDataMax     输出报文缓冲区最大长度

* @param[out]：outData     输出报文
* @return    ：OOP_DAR_E
* @author    : 
* @Date      ：2019-12-6
*********************************************************************
*/
OOP_DAR_E class8_invoke_act(OAD_INFO_T *pOadInfo, APDU_INFO_T *pApduInfo, const uint8 *inData, uint32 inLen, RESULT_DATA_T *outData, uint16 outDataMax)
{
    switch (pOadInfo->pTab->OIA1)
    {
    case 0x04:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x00:
                {
                    return class8_invoke_act_oia_40(pOadInfo, pApduInfo, inData, (uint16)inLen, outData, outDataMax); 
                }
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;
    case 0x08:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x00:
                {
                    return class8_invoke_act_oia_80(pOadInfo, pApduInfo, inData, (uint16)inLen, outData, outDataMax); 
                }
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;
    case 0x0f:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x01:
                {
                    return class8_invoke_act_oia_f1(pOadInfo, pApduInfo, inData, (uint16)inLen, outData, outDataMax); 
                }
                break;
            case 0x04:
                {
                    return class8_invoke_act_log_f4(pOadInfo, pApduInfo, inData, (uint16)inLen, outData, outDataMax); 
                }
                break;
            case 0x0f:
                {
                    return class8_invoke_act_oia_ff(pOadInfo, pApduInfo, inData, (uint16)inLen, outData, outDataMax); 
                }
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
        break;
    #ifdef AREA_FUJIAN
        case 0x06:
        {
            switch (pOadInfo->pTab->OIA2)
            {
            case 0x0e:
                {
                    return class8_invoke_act_oia_6e_fj(pOadInfo, pApduInfo, inData, (uint16)inLen, outData, outDataMax); 
                }
                break;
            default:
                return DATA_OBJECT_UNAVAILABLE;
                break;
            }
        }
    #endif
    default:
        return DATA_OBJECT_UNAVAILABLE;
        break;
    }

    return DATA_OBJECT_UNAVAILABLE;
}

#endif

