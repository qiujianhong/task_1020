
#include "ac_save.h"
#include "ac_sample.h"
#include "ac_lib.h"
#include "db_api.h"
#include "ac_main.h"


/*******************************************************************************
* 全局变量
*******************************************************************************/

const Map645ToOop_NEW gMap645ToOop_RT[]= //实时数据映射表
{
    // (当前)组合有功电能块
    {{0x00000200},  0,  0x0000FF00,4,20,0xFFFF,E_OOP_ENERGYS_T,   0, },   // (当前)组合有功电能块
    {{0x00000201}, -2,  0x00000000,4,4, 0xFFFF,E_OOP_ENERGYS_T,  -2, },   // 4字节, XXXXXX.XX(当前)组合有功总电能
    {{0x00000202}, -2,  0x00000100,4,4, 0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率1组合有功电能
    {{0x00000203}, -2,  0x00000200,4,4, 0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率2组合有功电能
    {{0x00000204}, -2,  0x00000300,4,4, 0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率3组合有功电能
    {{0x00000205}, -2,  0x00000400,4,4, 0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率4组合有功电能

    {{0x00010200}, -2,  0xFFFFFFFF,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相组合有功 1 电能
    {{0x00010201}, -2,  0xFFFFFFFF,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相组合有功 1 电能

    {{0x00020200}, -2,  0xFFFFFFFF,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相组合有功 1 电能
    {{0x00020201}, -2,  0xFFFFFFFF,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相组合有功 1 电能

    {{0x00030200}, -2,  0xFFFFFFFF,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相组合有功 1 电能
    {{0x00030201}, -2,  0xFFFFFFFF,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相组合有功 1 电能

    // (当前)正向有功总电能
    {{0x00100200}, -2,  0x0001FF00,4,20,0x901F,E_OOP_ENERGY_T, -2, },	 // (当前)正向有功电能块
    {{0x00100201}, -2,  0x00010000,4,4, 0x9010,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)正向有功总电能
    {{0x00100202}, -2,  0x00010100,4,4, 0x9011,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率1正向有功电能
    {{0x00100203}, -2,  0x00010200,4,4, 0x9012,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率2正向有功电能
    {{0x00100204}, -2,  0x00010300,4,4, 0x9013,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率3正向有功电能
    {{0x00100205}, -2,  0x00010400,4,4, 0x9014,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率4正向有功电能

    // (当前)A相正向有功总电能		
    {{0x00110200}, -2,  0x00150000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A相正向有功总电能
    {{0x00110201}, -2,  0x00150000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A相正向有功总电能
    // (当前)B相正向有功总电能	
    {{0x00120200}, -2,  0x00290000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B相正向有功总电能
    {{0x00120201}, -2,  0x00290000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B相正向有功总电能
    // (当前)C相正向有功总电能			
    {{0x00130200}, -2,  0x003D0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C相正向有功总电能
    {{0x00130201}, -2,  0x003D0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C相正向有功总电能

    // (当前)A相反向有功总电能			
    {{0x00210200}, -2,  0x00160000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A相反向有功总电能
    {{0x00210201}, -2,  0x00160000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A相反向有功总电能
    // (当前)B相反向有功总电能			
    {{0x00220200}, -2,  0x002A0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B相反向有功总电能
    {{0x00220201}, -2,  0x002A0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B相反向有功总电能
    // (当前)C相反向有功总电能			
    {{0x00230200}, -2,  0x003E0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C相反向有功总电能
    {{0x00230201}, -2,  0x003E0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C相反向有功总电能
    
    {{0x00310200}, -2,  0x00170000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相组合无功 1 电能
    {{0x00310201}, -2,  0x00170000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相组合无功 1 电能

    {{0x00320200}, -2,  0x002B0000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相组合无功 1 电能
    {{0x00320201}, -2,  0x002B0000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相组合无功 1 电能

    {{0x00330200}, -2,  0x003F0000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相组合无功 1 电能
    {{0x00330201}, -2,  0x003F0000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相组合无功 1 电能

    {{0x00410200}, -2,  0x00180000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相组合无功 2 电能
    {{0x00410201}, -2,  0x00180000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相组合无功 2 电能

    {{0x00420200}, -2,  0x002C0000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相组合无功 2 电能
    {{0x00420201}, -2,  0x002C0000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相组合无功 2 电能

    {{0x00430200}, -2,  0x00400000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相组合无功 2 电能
    {{0x00430201}, -2,  0x00400000,4,4,0xFFFF,E_OOP_ENERGYS_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相组合无功 2 电能

    

    {{0x00510200}, -2,  0x00190000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第一象限无功电能 电能
    {{0x00510201}, -2,  0x00190000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第一象限无功电能 电能

    {{0x00520200}, -2,  0x002d0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第一象限无功电能 电能
    {{0x00520201}, -2,  0x002d0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第一象限无功电能 电能

    {{0x00530200}, -2,  0x00410000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第一象限无功电能 电能
    {{0x00530201}, -2,  0x00410000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第一象限无功电能 电能


    {{0x00610200}, -2,  0x001a0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第二象限无功电能 电能
    {{0x00610201}, -2,  0x001a0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第二象限无功电能 电能

    {{0x00620200}, -2,  0x002e0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第二象限无功电能 电能
    {{0x00620201}, -2,  0x002e0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第二象限无功电能 电能

    {{0x00630200}, -2,  0x00420000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第二象限无功电能 电能
    {{0x00630201}, -2,  0x00420000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第二象限无功电能 电能


    {{0x00710200}, -2,  0x001b0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第三象限无功电能 电能
    {{0x00710201}, -2,  0x001b0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第三象限无功电能 电能

    {{0x00720200}, -2,  0x002f0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第三象限无功电能 电能
    {{0x00720201}, -2,  0x002f0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第三象限无功电能 电能

    {{0x00730200}, -2,  0x00430000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第三象限无功电能 电能
    {{0x00730201}, -2,  0x00430000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第三象限无功电能 电能


    {{0x00810200}, -2,  0x001c0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第四象限无功电能 电能
    {{0x00810201}, -2,  0x001c0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相第四象限无功电能 电能

    {{0x00820200}, -2,  0x00300000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第四象限无功电能 电能
    {{0x00820201}, -2,  0x00300000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相第四象限无功电能 电能

    {{0x00830200}, -2,  0x00440000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第四象限无功电能 电能
    {{0x00830201}, -2,  0x00440000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相第四象限无功电能 电能


    {{0x00910200}, -2,  0x001d0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相正向视在电能 电能
    {{0x00910201}, -2,  0x001d0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相正向视在电能 电能

    {{0x00920200}, -2,  0x00310000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相正向视在电能 电能
    {{0x00920201}, -2,  0x00310000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相正向视在电能 电能

    {{0x00930200}, -2,  0x00450000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相正向视在电能 电能
    {{0x00930201}, -2,  0x00450000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相正向视在电能 电能


    {{0x00a10200}, -2,  0x001e0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相反向视在电能 电能
    {{0x00a10201}, -2,  0x001e0000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)A 相反向视在电能 电能

    {{0x00a20200}, -2,  0x00320000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相反向视在电能 电能
    {{0x00a20201}, -2,  0x00320000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)B 相反向视在电能 电能

    {{0x00a30200}, -2,  0x00460000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相反向视在电能 电能
    {{0x00a30201}, -2,  0x00460000,4,4,0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)C 相反向视在电能 电能

    //(当前)反向有功总电能
    {{0x00200200}, -2,  0x0002FF00,4,20,0x902F,E_OOP_ENERGY_T, -2, },	 // (当前)反向有功电能块
    {{0x00200201}, -2,  0x00020000,4,4, 0x9020,E_OOP_ENERGY_T, -2, },	 // 4字节, XXXXXX.XX(当前)反向有功总电能
    {{0x00200202}, -2,  0x00020100,4,4, 0x9021,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率1反向有功电能
    {{0x00200203}, -2,  0x00020200,4,4, 0x9022,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率2反向有功电能
    {{0x00200204}, -2,  0x00020300,4,4, 0x9023,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率3反向有功电能
    {{0x00200205}, -2,  0x00020400,4,4, 0x9024,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率4反向有功电能

    //(当前)正向无功总电能(+RL,+RC)
    {{0x00300200}, -2,  0x0003FF00,4,20,0x911F,E_OOP_ENERGYS_T, -2, },    // (当前)正向无功电能块(+RL,+RC)
    {{0x00300201}, -2,  0x00030000,4,4, 0x9110,E_OOP_ENERGYS_T,  -2, },    // 4字节,XXXXXX.XX (当前)正向无功总电能(+RL,+RC)
    {{0x00300202}, -2,	0x00030100,4,4, 0x9111,E_OOP_ENERGYS_T,  -2, },    // 4字节,XXXXXX.XX (当前)费率1正向无功电能
    {{0x00300203}, -2,	0x00030200,4,4, 0x9112,E_OOP_ENERGYS_T,  -2, },    // 4字节,XXXXXX.XX (当前)费率2正向无功电能
    {{0x00300204}, -2,	0x00030300,4,4, 0x9113,E_OOP_ENERGYS_T,  -2, },    // 4字节,XXXXXX.XX (当前)费率3正向无功电能
    {{0x00300205}, -2,	0x00030400,4,4, 0x9114,E_OOP_ENERGYS_T,  -2, },    // 4字节,XXXXXX.XX (当前)费率4正向无功电能

    //(当前)反向无功总电能
    {{0x00400200}, -2,	0x0004FF00,4,20,0x912F,E_OOP_ENERGYS_T, -2, },    // (当前)反向无功电能块(-RL,-RC)
    {{0x00400201}, -2,	0x00040000,4,4, 0x9120,E_OOP_ENERGYS_T,  -2, },    // 4字节, XXXXXX.XX (当前)反向无功总电能(-RL,-RC)
    {{0x00400202}, -2,	0x00040100,4,4, 0x9121,E_OOP_ENERGYS_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率1反向无功电能
    {{0x00400203}, -2,	0x00040200,4,4, 0x9122,E_OOP_ENERGYS_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率2反向无功电能
    {{0x00400204}, -2,	0x00040300,4,4, 0x9123,E_OOP_ENERGYS_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率3反向无功电能
    {{0x00400205}, -2,	0x00040400,4,4, 0x9124,E_OOP_ENERGYS_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率4反向无功电能

    //一象限无功总电能
    {{0x00500200}, -2,	0x0005FF00,4,20,0x913F,E_OOP_ENERGY_T, -2, },    // (当前)一象限无功电能块(+RL)
    {{0x00500201}, -2,	0x00050000,4,4, 0x9130,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)一象限无功总电能(+RL)
    {{0x00500202}, -2,	0x00050100,4,4, 0x9131,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率1一象限无功电能
    {{0x00500203}, -2,	0x00050200,4,4, 0x9132,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率2一象限无功电能
    {{0x00500204}, -2,	0x00050300,4,4, 0x9133,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率3一象限无功电能
    {{0x00500205}, -2,	0x00050400,4,4, 0x9134,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率4一象限无功电能

    //二象限无功总电能
    {{0x00600200}, -2,	0x0006FF00,4,20,0x915F,E_OOP_ENERGY_T, -2, },    // (当前)二象限无功电能块(+Rc)
    {{0x00600201}, -2,	0x00060000,4,4, 0x9150,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)二象限无功总电能(+Rc)
    {{0x00600202}, -2,	0x00060100,4,4, 0x9151,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率1二象限无功电能
    {{0x00600203}, -2,	0x00060200,4,4, 0x9152,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率2二象限无功电能
    {{0x00600204}, -2,	0x00060300,4,4, 0x9153,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率3二象限无功电能
    {{0x00600205}, -2,	0x00060400,4,4, 0x9154,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率4二象限无功电能

    //三象限无功总电能
    {{0x00700200}, -2,	0x0007FF00,4,20,0x916F,E_OOP_ENERGY_T, -2, },    // (当前)三象限无功电能块(-RL)
    {{0x00700201}, -2,	0x00070000,4,4, 0x9160,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)三象限无功总电能(-RL)
    {{0x00700202}, -2,	0x00070100,4,4, 0x9161,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率1三象限无功电能
    {{0x00700203}, -2,	0x00070200,4,4, 0x9162,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率2三象限无功电能
    {{0x00700204}, -2,	0x00070300,4,4, 0x9163,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率3三象限无功电能
    {{0x00700205}, -2,	0x00070400,4,4, 0x9164,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率4三象限无功电能

    //四象限无功总电能
    {{0x00800200}, -2,	0x0008FF00,4,20,0x914F,E_OOP_ENERGY_T, -2, },    // (当前)四象限无功电能块(-Rc)
    {{0x00800201}, -2,	0x00080000,4,4, 0x9140,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)四象限无功总电能(-Rc)
    {{0x00800202}, -2,	0x00080100,4,4, 0x9141,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率1四象限无功电能
    {{0x00800203}, -2,	0x00080200,4,4, 0x9142,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率2四象限无功电能
    {{0x00800204}, -2,	0x00080300,4,4, 0x9143,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率3四象限无功电能
    {{0x00800205}, -2,	0x00080400,4,4, 0x9144,E_OOP_ENERGY_T,  -2, },    // 4字节, XXXXXX.XX (当前)费率4四象限无功电能

    // (当前)正向视在电能数据块
    {{0x00900200}, -2,  0x0009FF00,4,20,0xFFFF,E_OOP_ENERGY_T, -2, },	 // (当前)正向视在电能数据块
    {{0x00900201}, -2,  0x00090000,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)正向视在电能
    {{0x00900202}, -2,  0x00090100,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率1正向视在电能
    {{0x00900203}, -2,  0x00090200,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率2正向视在电能
    {{0x00900204}, -2,  0x00090300,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率3正向视在电能
    {{0x00900205}, -2,  0x00090400,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率4正向视在电能

    // (当前)反向视在电能数据块
    {{0x00a00200}, -2,  0x000aFF00,4,20,0xFFFF,E_OOP_ENERGY_T, -2, },	 // (当前)反向视在电能数据块
    {{0x00a00201}, -2,  0x000a0000,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)反向视在电能
    {{0x00a00202}, -2,  0x000a0100,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率1反向视在电能
    {{0x00a00203}, -2,  0x000a0200,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率2反向视在电能
    {{0x00a00204}, -2,  0x000a0300,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率3反向视在电能
    {{0x00a00205}, -2,  0x000a0400,4,4, 0xFFFF,E_OOP_ENERGY_T,  -2, },	 // 4字节, XXXXXX.XX(当前)费率4反向视在电能

    /***高精度 电能量 begin 数据项8字节, 四位小数***/
    
    // (当前)组合有功电能块
    {{0x00000400}, -4,  0xF100FF00,5,25,0xFFFF,E_OOP_HENERGYS_T,  -4, },   // (当前)组合有功电能块
    {{0x00000401}, -4,  0xF1000000,5,5, 0xFFFF,E_OOP_HENERGYS_T,  -4, },   // 4字节, XXXXXX.XX(当前)组合有功总电能
    {{0x00000402}, -4,  0xF1000100,5,5, 0xFFFF,E_OOP_HENERGYS_T,  -4, },  // 4字节, XXXXXX.XX(当前)费率1组合有功电能
    {{0x00000403}, -4,  0xF1000200,5,5, 0xFFFF,E_OOP_HENERGYS_T,  -4, },  // 4字节, XXXXXX.XX(当前)费率2组合有功电能
    {{0x00000404}, -4,  0xF1000300,5,5, 0xFFFF,E_OOP_HENERGYS_T,  -4, },  // 4字节, XXXXXX.XX(当前)费率3组合有功电能
    {{0x00000405}, -4,  0xF1000400,5,5, 0xFFFF,E_OOP_HENERGYS_T,  -4, },  // 4字节, XXXXXX.XX(当前)费率4组合有功电能

    // (当前)正向有功总电能
    {{0x00100400}, -4,  0xF101FF00,5,25,0x901F,E_OOP_HENERGY_T,  -4, },    // (当前)正向有功电能块
    {{0x00100401}, -4,  0xF1010000,5,5, 0x9010,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)正向有功总电能
    {{0x00100402}, -4,  0xF1010100,5,5, 0x9011,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率1正向有功电能
    {{0x00100403}, -4,  0xF1010200,5,5, 0x9012,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率2正向有功电能
    {{0x00100404}, -4,  0xF1010300,5,5, 0x9013,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率3正向有功电能
    {{0x00100405}, -4,  0xF1010400,5,5, 0x9014,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率4正向有功电能

    // (当前)A相正向有功总电能        
    {{0x00110400}, -4,  0xF1150000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A相正向有功总电能
    {{0x00110401}, -4,  0xF1150000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A相正向有功总电能
    // (当前)B相正向有功总电能    
    {{0x00120400}, -4,  0xF1290000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B相正向有功总电能
    {{0x00120401}, -4,  0xF1290000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B相正向有功总电能
    // (当前)C相正向有功总电能            
    {{0x00130400}, -4,  0xF13D0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C相正向有功总电能
    {{0x00130401}, -4,  0xF13D0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C相正向有功总电能

    // (当前)A相反向有功总电能            
    {{0x00210400}, -4,  0xF1160000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A相反向有功总电能
    {{0x00210401}, -4,  0xF1160000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A相反向有功总电能
    // (当前)B相反向有功总电能            
    {{0x00220400}, -4,  0xF12A0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B相反向有功总电能
    {{0x00220401}, -4,  0xF12A0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B相反向有功总电能
    // (当前)C相反向有功总电能            
    {{0x00230400}, -4,  0xF13E0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C相反向有功总电能
    {{0x00230401}, -4,  0xF13E0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C相反向有功总电能
    
    {{0x00310400}, -4,  0xF1170000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相组合无功 1 电能
    {{0x00310401}, -4,  0xF1170000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相组合无功 1 电能

    {{0x00320400}, -4,  0xF12B0000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相组合无功 1 电能
    {{0x00320401}, -4,  0xF12B0000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相组合无功 1 电能

    {{0x00330400}, -4,  0xF13F0000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相组合无功 1 电能
    {{0x00330401}, -4,  0xF13F0000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相组合无功 1 电能

    {{0x00410400}, -4,  0xF1180000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相组合无功 2 电能
    {{0x00410401}, -4,  0xF1180000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相组合无功 2 电能

    {{0x00420400}, -4,  0xF12C0000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相组合无功 2 电能
    {{0x00420401}, -4,  0xF12C0000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相组合无功 2 电能

    {{0x00430400}, -4,  0xF1400000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相组合无功 2 电能
    {{0x00430401}, -4,  0xF1400000,5,5,0xFFFF,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相组合无功 2 电能

    

    {{0x00510400}, -4,  0xF1190000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第一象限无功电能 电能
    {{0x00510401}, -4,  0xF1190000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第一象限无功电能 电能

    {{0x00520400}, -4,  0xF12d0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第一象限无功电能 电能
    {{0x00520401}, -4,  0xF12d0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第一象限无功电能 电能

    {{0x00530400}, -4,  0xF1410000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第一象限无功电能 电能
    {{0x00530401}, -4,  0xF1410000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第一象限无功电能 电能


    {{0x00610400}, -4,  0xF11a0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第二象限无功电能 电能
    {{0x00610401}, -4,  0xF11a0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第二象限无功电能 电能

    {{0x00620400}, -4,  0xF12e0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第二象限无功电能 电能
    {{0x00620401}, -4,  0xF12e0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第二象限无功电能 电能

    {{0x00630400}, -4,  0xF1420000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第二象限无功电能 电能
    {{0x00630401}, -4,  0xF1420000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第二象限无功电能 电能


    {{0x00710400}, -4,  0xF11b0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第三象限无功电能 电能
    {{0x00710401}, -4,  0xF11b0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第三象限无功电能 电能

    {{0x00720400}, -4,  0xF12f0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第三象限无功电能 电能
    {{0x00720401}, -4,  0xF12f0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第三象限无功电能 电能

    {{0x00730400}, -4,  0xF1430000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第三象限无功电能 电能
    {{0x00730401}, -4,  0xF1430000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第三象限无功电能 电能


    {{0x00810400}, -4,  0xF11c0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第四象限无功电能 电能
    {{0x00810401}, -4,  0xF11c0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相第四象限无功电能 电能

    {{0x00820400}, -4,  0xF1300000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第四象限无功电能 电能
    {{0x00820401}, -4,  0xF1300000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相第四象限无功电能 电能

    {{0x00830400}, -4,  0xF1440000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第四象限无功电能 电能
    {{0x00830401}, -4,  0xF1440000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相第四象限无功电能 电能


    {{0x00910400}, -4,  0xF11d0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相正向视在电能 电能
    {{0x00910401}, -4,  0xF11d0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相正向视在电能 电能

    {{0x00920400}, -4,  0xF1310000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相正向视在电能 电能
    {{0x00920401}, -4,  0xF1310000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相正向视在电能 电能

    {{0x00930400}, -4,  0xF1450000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相正向视在电能 电能
    {{0x00930401}, -4,  0xF1450000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相正向视在电能 电能


    {{0x00a10400}, -4,  0xF11e0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相反向视在电能 电能
    {{0x00a10401}, -4,  0xF11e0000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)A 相反向视在电能 电能

    {{0x00a20400}, -4,  0xF1320000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相反向视在电能 电能
    {{0x00a20401}, -4,  0xF1320000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)B 相反向视在电能 电能

    {{0x00a30400}, -4,  0xF1460000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相反向视在电能 电能
    {{0x00a30401}, -4,  0xF1460000,5,5,0xFFFF,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX(当前)C 相反向视在电能 电能

    //(当前)反向有功总电能
    {{0x00200400}, -4,  0xF102FF00,5,25,0x902F,E_OOP_HENERGY_T, -4, },    // (当前)反向有功电能块
    {{0x00200401}, -4,  0xF1020000,5,5, 0x9020,E_OOP_HENERGY_T, -4, },    // 4字节, XXXXXX.XX(当前)反向有功总电能
    {{0x00200402}, -4,  0xF1020100,5,5, 0x9021,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率1反向有功电能
    {{0x00200403}, -4,  0xF1020200,5,5, 0x9022,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率2反向有功电能
    {{0x00200404}, -4,  0xF1020300,5,5, 0x9023,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率3反向有功电能
    {{0x00200405}, -4,  0xF1020400,5,5, 0x9024,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率4反向有功电能

    //(当前)正向无功总电能(+RL,+RC)
    {{0x00300400}, -4,  0xF103FF00,5,25,0x911F,E_OOP_HENERGYS_T, -4, },    // (当前)正向无功电能块(+RL,+RC)
    {{0x00300401}, -4,  0xF1030000,5,5, 0x9110,E_OOP_HENERGYS_T,  -4, },    // 4字节,XXXXXX.XX (当前)正向无功总电能(+RL,+RC)
    {{0x00300402}, -4,  0xF1030100,5,5, 0x9111,E_OOP_HENERGYS_T,  -4, },    // 4字节,XXXXXX.XX (当前)费率1正向无功电能
    {{0x00300403}, -4,  0xF1030200,5,5, 0x9112,E_OOP_HENERGYS_T,  -4, },    // 4字节,XXXXXX.XX (当前)费率2正向无功电能
    {{0x00300404}, -4,  0xF1030300,5,5, 0x9113,E_OOP_HENERGYS_T,  -4, },    // 4字节,XXXXXX.XX (当前)费率3正向无功电能
    {{0x00300405}, -4,  0xF1030400,5,5, 0x9114,E_OOP_HENERGYS_T,  -4, },    // 4字节,XXXXXX.XX (当前)费率4正向无功电能

    //(当前)反向无功总电能
    {{0x00400400}, -4,  0xF104FF00,5,25,0x912F,E_OOP_HENERGYS_T, -4, },    // (当前)反向无功电能块(-RL,-RC)
    {{0x00400401}, -4,  0xF1040000,5,5, 0x9120,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX (当前)反向无功总电能(-RL,-RC)
    {{0x00400402}, -4,  0xF1040100,5,5, 0x9121,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率1反向无功电能
    {{0x00400403}, -4,  0xF1040200,5,5, 0x9122,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率2反向无功电能
    {{0x00400404}, -4,  0xF1040300,5,5, 0x9123,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率3反向无功电能
    {{0x00400405}, -4,  0xF1040400,5,5, 0x9124,E_OOP_HENERGYS_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率4反向无功电能

    //一象限无功总电能
    {{0x00500400}, -4,  0xF105FF00,5,25,0x913F,E_OOP_HENERGY_T, -4, },    // (当前)一象限无功电能块(+RL)
    {{0x00500401}, -4,  0xF1050000,5,5, 0x9130,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)一象限无功总电能(+RL)
    {{0x00500402}, -4,  0xF1050100,5,5, 0x9131,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率1一象限无功电能
    {{0x00500403}, -4,  0xF1050200,5,5, 0x9132,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率2一象限无功电能
    {{0x00500404}, -4,  0xF1050300,5,5, 0x9133,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率3一象限无功电能
    {{0x00500405}, -4,  0xF1050400,5,5, 0x9134,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率4一象限无功电能

    //二象限无功总电能
    {{0x00600400}, -4,  0xF106FF00,5,25,0x915F,E_OOP_HENERGY_T, -4, },    // (当前)二象限无功电能块(+Rc)
    {{0x00600401}, -4,  0xF1060000,5,5, 0x9150,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)二象限无功总电能(+Rc)
    {{0x00600402}, -4,  0xF1060100,5,5, 0x9151,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率1二象限无功电能
    {{0x00600403}, -4,  0xF1060200,5,5, 0x9152,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率2二象限无功电能
    {{0x00600404}, -4,  0xF1060300,5,5, 0x9153,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率3二象限无功电能
    {{0x00600405}, -4,  0xF1060400,5,5, 0x9154,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率4二象限无功电能

    //三象限无功总电能
    {{0x00700400}, -4,  0xF107FF00,5,25,0x916F,E_OOP_HENERGY_T, -4, },    // (当前)三象限无功电能块(-RL)
    {{0x00700401}, -4,  0xF1070000,5,5, 0x9160,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)三象限无功总电能(-RL)
    {{0x00700402}, -4,  0xF1070100,5,5, 0x9161,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率1三象限无功电能
    {{0x00700403}, -4,  0xF1070200,5,5, 0x9162,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率2三象限无功电能
    {{0x00700404}, -4,  0xF1070300,5,5, 0x9163,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率3三象限无功电能
    {{0x00700405}, -4,  0xF1070400,5,5, 0x9164,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率4三象限无功电能

    //四象限无功总电能
    {{0x00800400}, -4,  0xF108FF00,5,25,0x914F,E_OOP_HENERGY_T, -4, },    // (当前)四象限无功电能块(-Rc)
    {{0x00800401}, -4,  0xF1080000,5,5, 0x9140,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)四象限无功总电能(-Rc)
    {{0x00800402}, -4,  0xF1080100,5,5, 0x9141,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率1四象限无功电能
    {{0x00800403}, -4,  0xF1080200,5,5, 0x9142,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率2四象限无功电能
    {{0x00800404}, -4,  0xF1080300,5,5, 0x9143,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率3四象限无功电能
    {{0x00800405}, -4,  0xF1080400,5,5, 0x9144,E_OOP_HENERGY_T,  -4, },    // 4字节, XXXXXX.XX (当前)费率4四象限无功电能

    // (当前)正向视在电能数据块
    {{0x00900400}, -4,  0xF109FF00,5,25,0xFFFF,E_OOP_HENERGY_T, -4, },    // (当前)正向视在电能数据块
    {{0x00900401}, -4,  0xF1090000,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)正向视在电能
    {{0x00900402}, -4,  0xF1090100,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率1正向视在电能
    {{0x00900403}, -4,  0xF1090200,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率2正向视在电能
    {{0x00900404}, -4,  0xF1090300,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率3正向视在电能
    {{0x00900405}, -4,  0xF1090400,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率4正向视在电能

    // (当前)反向视在电能数据块
    {{0x00a00400}, -4,  0xF10aFF00,5,25,0xFFFF,E_OOP_HENERGY_T, -4, },    // (当前)反向视在电能数据块
    {{0x00a00401}, -4,  0xF10a0000,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)反向视在电能
    {{0x00a00402}, -4,  0xF10a0100,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率1反向视在电能
    {{0x00a00403}, -4,  0xF10a0200,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率2反向视在电能
    {{0x00a00404}, -4,  0xF10a0300,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率3反向视在电能
    {{0x00a00405}, -4,  0xF10a0400,5,5, 0xFFFF,E_OOP_HENERGY_T,  -4, },   // 4字节, XXXXXX.XX(当前)费率4反向视在电能

    /***高精度 电能量 end***/

    //(当前)正向有功总最大需量
    {{0x10100200},  0,	 0x0101FF00,	8,40,	0xA01F,E_OOP_DEMAND_T,  0,       },  // (当前)正向有功最大需量块
    {{0x10100200},  0,	 0x0101FF00,	8,40,	0xB01F,E_OOP_DEMAND_T,  0,       },  // (当前)正向有功最大需量块
    {{0x10100201},  0,	 0x01010000,	8,8,	0xA010,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)正向有功总最大需量
    {{0x10100201},  0,	 0x01010000,	8,8,	0xB010,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)正向有功总最大需量
    {{0x10100202},  0,	 0x01010100,	8,8,	0xA011,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1正向有功最大需量
    {{0x10100202},  0,	 0x01010100,	8,8,	0xB011,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1正向有功最大需量
    {{0x10100203},  0,	 0x01010200,	8,8,	0xA012,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2正向有功最大需量
    {{0x10100203},  0,	 0x01010200,	8,8,	0xB012,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2正向有功最大需量
    {{0x10100204},  0,	 0x01010300,	8,8,	0xA013,E_OOP_DEMAND_T,  0       },  // 3字节, XX.XXXX,  (当前)费率3正向有功最大需量
    {{0x10100204},  0,	 0x01010300,	8,8,	0xB013,E_OOP_DEMAND_T,  0       },  // 3字节, XX.XXXX,  (当前)费率3正向有功最大需量
    {{0x10100205},  0,	 0x01010400,	8,8,	0xA014,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4正向有功最大需量
    {{0x10100205},  0,	 0x01010400,	8,8,	0xB014,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4正向有功最大需量

    //(当前)反向有功总最大需量
    {{0x10200200},  0,	 0x0102FF00,	8,40,	0xA02F,E_OOP_DEMAND_T,  -0,       },  // (当前)反向有功最大需量块
    {{0x10200200},  0,	 0x0102FF00,	8,40,	0xB02F,E_OOP_DEMAND_T,  -0,       },  // (当前)反向有功最大需量块
    {{0x10200201},  0,	 0x01020000,	8,8,	0xA020,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)反向有功总最大需量
    {{0x10200201},  0,	 0x01020000,	8,8,	0xB020,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)反向有功总最大需量
    {{0x10200202},  0,	 0x01020100,	8,8,	0xA021,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率1反向有功最大需量
    {{0x10200202},  0,	 0x01020100,	8,8,	0xB021,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率1反向有功最大需量
    {{0x10200203},  0,	 0x01020200,	8,8,	0xA022,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率2反向无功向有功最大需量
    {{0x10200203},  0,	 0x01020200,	8,8,	0xB022,E_OOP_DEMAND_T,  -0,		 },  // 3字节, XX.XXXX,  (当前)费率2反向无功向有功最大需量
    {{0x10200204},  0,	 0x01020300,	8,8,	0xA023,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率3反向无功向有功最大需量
    {{0x10200204},  0,	 0x01020300,	8,8,	0xB023,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率3反向无功向有功最大需量
    {{0x10200205},  0,	 0x01020400,	8,8,	0xA024,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率4反向无功向有功最大需量
    {{0x10200205},  0,	 0x01020400,	8,8,	0xB024,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率4反向无功向有功最大需量

    //(当前)正向无功总最大需量
    {{0x10300200}, 0,	 0x0103FF00,	8,40,	0xA11F,E_OOP_DEMAND_T,  -0,       },  //  (当前)正向无功最大需量块
    {{0x10300200}, 0,	 0x0103FF00,	8,40,	0xB11F,E_OOP_DEMAND_T,  -0,       },  //  (当前)正向无功最大需量块
    {{0x10300201}, 0,	 0x01030000,	8,8,	0xA110,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)正向无功总最大需量
    {{0x10300201}, 0,	 0x01030000,	8,8,	0xB110,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)正向无功总最大需量
    {{0x10300202}, 0,	 0x01030100,	8,8,	0xA111,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率1正向无功最大需量
    {{0x10300202}, 0,	 0x01030100,	8,8,	0xB111,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率1正向无功最大需量  
    {{0x10300203}, 0,	 0x01030200,	8,8,	0xA112,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率2正向无功最大需量
    {{0x10300203}, 0,	 0x01030200,	8,8,	0xB112,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率2正向无功最大需量
    {{0x10300204}, 0,	 0x01030300,	8,8,	0xA113,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率3正向无功最大需量
    {{0x10300204}, 0,	 0x01030300,	8,8,	0xB113,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率3正向无功最大需量
    {{0x10300205}, 0,	 0x01030400,	8,8,	0xA114,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率4正向无功最大需量
    {{0x10300205}, 0,	 0x01030400,	8,8,	0xB114,E_OOP_DEMAND_T,  -0,       },  // 3字节, XX.XXXX,  (当前)费率4正向无功最大需量

    //(当前)反向无功总最大需量
    {{0x10400200}, 0,	 0x0104FF00,	8,40,0xA12F,E_OOP_DEMAND_T,  0,       },  //(当前)反向无功最大需量块
    {{0x10400200}, 0,	 0x0104FF00,	8,40,0xB12F,E_OOP_DEMAND_T,  0,       },  //(当前)反向无功最大需量块
    {{0x10400201}, 0,	 0x01040000,	8,8,0xA120,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前反向无功总最大需量
    {{0x10400201}, 0,	 0x01040000,	8,8,0xB120,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前反向无功总最大需量
    {{0x10400202}, 0,	 0x01040100,	8,8,0xA121,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1反向无功最大需量
    {{0x10400202}, 0,	 0x01040100,	8,8,0xB121,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1反向无功最大需量
    {{0x10400203}, 0,	 0x01040200,	8,8,0xA122,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2反向无功最大需量
    {{0x10400203}, 0,	 0x01040200,	8,8,0xB122,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2反向无功最大需量
    {{0x10400204}, 0,	 0x01040300,	8,8,0xA123,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3反向无功最大需量
    {{0x10400204}, 0,	 0x01040300,	8,8,0xB123,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3反向无功最大需量
    {{0x10400205}, 0,	 0x01040400,	8,8,0xA124,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4反向无功最大需量
    {{0x10400205}, 0,	 0x01040400,	8,8,0xB124,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4反向无功最大需量
    
    //分相正向有功总最大需量
    {{0x10110200},  0,0x01150000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相正向有功总最大需量
    {{0x10110201},  0,0x01150000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相正向有功总最大需量

    {{0x10120200},  0,0x01290000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相正向有功总最大需量
    {{0x10120201},  0,0x01290000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相正向有功总最大需量

    {{0x10130200},  0,0x013D0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相正向有功总最大需量
    {{0x10130201},  0,0x013D0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相正向有功总最大需量


    {{0x10210200},  0,0x01160000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相反向有功最大需量
    {{0x10210201},  0,0x01160000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相反向有功最大需量

    {{0x10220200},  0,0x012a0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相反向有功最大需量
    {{0x10220201},  0,0x012a0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相反向有功最大需量

    {{0x10230200},  0,0x013e0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相反向有功最大需量
    {{0x10230201},  0,0x013e0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相反向有功最大需量


    {{0x10310200},  0,0x01170000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相组合无功1最大需量
    {{0x10310201},  0,0x01170000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相组合无功1最大需量

    {{0x10320200},  0,0x012b0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相组合无功1最大需量
    {{0x10320201},  0,0x012b0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相组合无功1最大需量

    {{0x10330200},  0,0x013f0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相组合无功1最大需量
    {{0x10330201},  0,0x013f0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相组合无功1最大需量


    {{0x10410200},  0,0x01180000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相组合无功2最大需量
    {{0x10410201},  0,0x01180000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相组合无功2最大需量

    {{0x10420200},  0,0x012c0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相组合无功2最大需量
    {{0x10420201},  0,0x012c0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相组合无功2最大需量

    {{0x10430200},  0,0x01400000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相组合无功2最大需量
    {{0x10430201},  0,0x01400000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相组合无功2最大需量


    {{0x10510200},  0,0x01190000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第一象限最大需量
    {{0x10510201},  0,0x01190000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第一象限最大需量

    {{0x10520200},  0,0x012d0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第一象限最大需量
    {{0x10520201},  0,0x012d0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第一象限最大需量

    {{0x10530200},  0,0x01410000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第一象限最大需量
    {{0x10530201},  0,0x01410000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第一象限最大需量


    {{0x10610200},  0,0x011a0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第二象限最大需量
    {{0x10610201},  0,0x011a0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第二象限最大需量

    {{0x10620200},  0,0x012e0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第二象限最大需量
    {{0x10620201},  0,0x012e0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第二象限最大需量

    {{0x10630200},  0,0x01420000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第二象限最大需量
    {{0x10630201},  0,0x01420000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第二象限最大需量


    {{0x10710200},  0,0x011b0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第三象限最大需量
    {{0x10710201},  0,0x011b0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第三象限最大需量

    {{0x10720200},  0,0x012f0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第三象限最大需量
    {{0x10720201},  0,0x012f0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第三象限最大需量

    {{0x10730200},  0,0x01430000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第三象限最大需量
    {{0x10730201},  0,0x01430000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第三象限最大需量


    {{0x10810200},  0,0x011c0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第四象限最大需量
    {{0x10810201},  0,0x011c0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相第四象限最大需量

    {{0x10820200},  0,0x01300000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第四象限最大需量
    {{0x10820201},  0,0x01300000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相第四象限最大需量

    {{0x10830200},  0,0x01440000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第四象限最大需量
    {{0x10830201},  0,0x01440000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相第四象限最大需量


    {{0x10910200},  0,0x011d0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相正向视在最大需量
    {{0x10910201},  0,0x011d0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相正向视在最大需量

    {{0x10920200},  0,0x01310000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相正向视在最大需量
    {{0x10920201},  0,0x01310000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相正向视在最大需量

    {{0x10930200},  0,0x01450000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相正向视在最大需量
    {{0x10930201},  0,0x01450000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相正向视在最大需量


    {{0x10a10200},  0,0x011e0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相反向视在最大需量
    {{0x10a10201},  0,0x011e0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)A相反向视在最大需量

    {{0x10a20200},  0,0x01320000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相反向视在最大需量
    {{0x10a20201},  0,0x01320000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 35字节,XX.XXXX,  (当前)B相反向视在最大需量

    {{0x10a30200},  0,0x01460000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相反向视在最大需量
    {{0x10a30201},  0,0x01460000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  -0,       },    // 3字节, XX.XXXX,  (当前)C相反向视在最大需量

    //电压
    {{0x20000200},			   -1,	0x0201FF00,2,6,0xB61F,E_OOP_WORD3V_T,	-1, },   // 电压数据块
    {{0x20000201},			   -1,	0x02010100,2,2,0xB610,E_OOP_WORD3V_T,	-1, },   // 2字节, X.XXX A相电压/AB线电压/单向表电压
    {{0x20000202},			   -1,	0x02010200,2,2,0xB611,E_OOP_WORD3V_T,	-1, },   // 2字节, X.XXX B相电压/无/无
    {{0x20000203},			   -1,	0x02010300,2,2,0xB612,E_OOP_WORD3V_T,	-1, },   // 2字节, X.XXX C相电压/CB线电压/无

    //高精度电压
    {{0x20000400},			   -1,	0xFFFFFFFF,4,12,0xFFFF,E_OOP_DWORD3V_T,	-1, },   // 高精度电压数据块
    {{0x20000401},			   -1,	0xFFFFFFFF,4,4, 0xFFFF,E_OOP_DWORD3V_T,	-1, },   // 4字节, A相电压
    {{0x20000402},			   -1,	0xFFFFFFFF,4,4, 0xFFFF,E_OOP_DWORD3V_T,	-1, },   // 4字节, B相电压
    {{0x20000403},			   -1,	0xFFFFFFFF,4,4, 0xFFFF,E_OOP_DWORD3V_T,	-1, },   // 4字节, C相电压

    //电流
    {{0x20010200},			   -3,	0x0202FF00,3,12,0xB62F,E_OOP_INT3V_T,	-3, },	// 电流数据块
    {{0x20010201},			   -3,	0x02020100,3,3,0xB620,E_OOP_INT3V_T,	-3, },	// 3字节, XXX.XXX, A相电流/A相电流/单向表电流
    {{0x20010202},			   -3,	0x02020200,3,3,0xB621,E_OOP_INT3V_T,	-3, },	// 3字节, XXX.XXX, B相电流/无/无
    {{0x20010203},			   -3,	0x02020300,3,3,0xB622,E_OOP_INT3V_T,	-3, },	// 3字节, XXX.XXX, C相电流/C相电流/无

    //零序电压
    {{0x20000600},			   -1,	0xFFFFFFFF,2,2,0xFFFF,E_LONG_UNSIGNED,	-1, },  // 2字节, XXX.X 零序电压

    //零线电流
    {{0x20010400},			   -3,	0xFFFFFFFF,3,3,0xFFFF,E_DOUBLE_LONG,	-3, },	// 3字节, XXX.XXX, 零线电流

    //零序电流
    {{0x20010600},			   -3,	0x02800001,3,3,0xFFFF,E_DOUBLE_LONG,	-3, },	// 3字节, XXX.XXX, 零序电流

    //电压电流相角
    {{0x20030200},		   -1,	0x0207FF00,2,6,0xFFFF,E_OOP_WORD3V_T,	-1, },	// 电压电流相角数据块
    {{0x20030201},		   -1,	0x02070100,2,2,0xFFFF,E_OOP_WORD3V_T,	-1, },	// 2字节, XXX.X, A相电压电流相角
    {{0x20030202},		   -1,	0x02070200,2,2,0xFFFF,E_OOP_WORD3V_T,	-1, },	// 2字节, XXX.X, B相电压电流相角
    {{0x20030203},		   -1,	0x02070300,2,2,0xFFFF,E_OOP_WORD3V_T,	-1, },	// 2字节, XXX.X, C相电压电流相角

    //电压相角
    {{0x20020200},		   -1,	0xEFB10000,2,6,0xFFFF,E_OOP_WORD3V_T,	-1, },	// 电压相角数据块

    //电流相角(特殊 暂时)
    {{0xAAAA0001},		   -1,	0xEFB10000,2,6,0xFFFF,E_OOP_WORD3V_T,	-1, },	// 电压相角数据块

    //A相电压谐波含有率（总及2…n次）
    {{0x200D0200},		   -2,	0x020A01FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-2, },	// 2字节, XX.XX, A相电压谐波含有率（总及2…n次）21次
    //B相电压谐波含有率（总及2…n次）
    {{0x200D0300},		   -2,	0x020A02FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-2, },	// 2字节, XX.XX, B相电压谐波含有率（总及2…n次）21次
    //C相电压谐波含有率（总及2…n次）
    {{0x200D0400},		   -2,	0x020A03FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-2, },	// 2字节, XX.XX, C相电压谐波含有率（总及2…n次）21次

    //A相电流谐波含有率（总及2…n次）
    {{0x200E0200},		   -2,	0x020B01FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-2, },	// 2字节, XX.XX, A相电流谐波含有率（总及2…n次）21次
    //B相电流谐波含有率（总及2…n次）
    {{0x200E0300},		   -2,	0x020B02FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-2, },	// 2字节, XX.XX, B相电流谐波含有率（总及2…n次）21次
    //C相电流谐波含有率（总及2…n次）
    {{0x200E0400},		   -2,	0x020B03FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-2, },	// 2字节, XX.XX, C相电流谐波含有率（总及2…n次）21次

    //A相电压谐波含量（消息接口 2…n次）
    {{0x20330200},		   -1,	0x020C01FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-1, },	// 2字节, XX.XX, A相电压谐波含量（消息接口 2…n次）21次
    //B相电压谐波含量（消息接口 2…n次）
    {{0x20330300},		   -1,	0x020C02FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-1, },	// 2字节, XX.XX, B相电压谐波含量（消息接口 2…n次）21次
    //C相电压谐波含量（消息接口 2…n次）
    {{0x20330400},		   -1,	0x020C03FF,2,42,0xFFFF,E_OOP_HARMONIC_T,	-1, },	// 2字节, XX.XX, C相电压谐波含量（消息接口 2…n次）21次

    //A相电流谐波含量（消息接口 2…n次）
    {{0x20340200},		   -3,	0x020D01FF,3,63,0xFFFF,E_OOP_HARMONIC_T,	-3, },	// 2字节, XX.XX, A相电流谐波含量（消息接口 2…n次）21次
    //B相电流谐波含量（消息接口 2…n次）
    {{0x20340300},		   -3,	0x020D02FF,3,63,0xFFFF,E_OOP_HARMONIC_T,	-3, },	// 2字节, XX.XX, B相电流谐波含量（消息接口 2…n次）21次
    //C相电流谐波含量（消息接口 2…n次）
    {{0x20340400},		   -3,	0x020D03FF,3,63,0xFFFF,E_OOP_HARMONIC_T,	-3, },	// 2字节, XX.XX, C相电流谐波含量（消息接口 2…n次）21次

    //瞬时正向有功功率
    {{0x20040200},			 -1,	0x0203FF00,3,12,0xB63F,E_OOP_INT4V_T,	-4, },	 // 瞬时正向有功功率块
    {{0x20040201},			   -1,	0x02030000,3,3, 0xB630,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, 瞬时正向有功功率,都为正，与RT_NEG_Z_AP_EV_ID 互斥
    {{0x20040202},			   -1,	0x02030100,3,3, 0xB631,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, A相有功功率,有正负,自定义格式，为负时只将最高字节的最高位置1,如0f 00 00 80 代表-15
    {{0x20040203},			   -1,	0x02030200,3,3, 0xB632,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, B相有功功率,有正负,格式同上
    {{0x20040204},			   -1,	0x02030300,3,3, 0xB633,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, C相有功功率,有正负,格式同上

    //瞬时正向无功功率
    {{0x20050200},			 -1,	0x0204FF00,3,12,0xB64F,E_OOP_INT4V_T,	-4, },	 // 瞬时正向无功功率块
    {{0x20050201},			   -1,	0x02040000,3,3, 0xB640,E_OOP_INT4V_T,	-4, },	 // 瞬时正向无功功率块
    {{0x20050202},			   -1,	0x02040100,3,3, 0xB641,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, A相无功功率,有正负,自定义格式，为负时只将最高字节的最高位置1,如0f 00 00 80 代表-15
    {{0x20050203},			   -1,	0x02040200,3,3, 0xB642,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, B相无功功率,格式同上
    {{0x20050204},			   -1,	0x02040300,3,3, 0xB643,E_OOP_INT4V_T,	-4, },	 // 3字节, XX.XXXX, C相无功功率,格式同上

    //瞬时总功率因数
    {{0x200A0200},			 -3,	0x0206FF00,2,8,0xB65F,E_OOP_LONG4V_T,	-3, },	 // 瞬时功率因数块
    {{0x200A0201},			   -3,	0x02060000,2,2,0xB650,E_OOP_LONG4V_T,	-3, },	 // 2字节, XX.XXXX, 瞬时总功率因数
    {{0x200A0202},			   -3,	0x02060100,2,2,0xB651,E_OOP_LONG4V_T,	-3, },	 // 2字节, XX.XXXX, A相功率因数
    {{0x200A0203},			   -3,	0x02060200,2,2,0xB652,E_OOP_LONG4V_T,	-3, },	 // 2字节, XX.XXXX, B相功率因数
    {{0x200A0204},			   -3,	0x02060300,2,2,0xB653,E_OOP_LONG4V_T,	-3, },	 // 2字节, XX.XXXX, C相功率因数
    {{0x200F0200},			   -2,	0x02800002,2,2,0xFFFF,E_LONG_UNSIGNED,	-2, },	 // 2字节, XX.XXXX, 频率
    //瞬时视在功率
    {{0x20060200},			   -1, 0x0205FF00,3,12,0xB66F,E_OOP_INT4V_T,  -4, },	// 瞬时视在功率块
    {{0x20060201},			   -1, 0x02050000,3,3, 0xB660,E_OOP_INT4V_T,  -4, },	// 3字节, XX.XXXX, 瞬时视在功率
    {{0x20060202},			   -1, 0x02050100,3,3, 0xB661,E_OOP_INT4V_T,  -4, },	// 3字节, XX.XXXX, A相视在功率
    {{0x20060203},			   -1, 0x02050200,3,3, 0xB662,E_OOP_INT4V_T,  -4, },	// 3字节, XX.XXXX, B相视在功率
    {{0x20060204},			   -1, 0x02050300,3,3, 0xB663,E_OOP_INT4V_T,  -4, },	// 3字节, XX.XXXX, C相视在功率

    {{0x20140200},		   0, 0x040005FF,2,14,0xFFFF,E_OOP_METWORD_T,   0,},	// 7*2字节,电表运行状态字块
    {{0x20140201},		   0, 0x04000501,2,2,0xC020,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字1
    {{0x20140202},		   0, 0x04000502,2,2,0xC021,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字2
    {{0x20140203},		   0, 0x04000503,2,2,0xFFFF,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字3
    {{0x20140204},		   0, 0x04000504,2,2,0xFFFF,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字4
    {{0x20140205},		   0, 0x04000505,2,2,0xFFFF,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字5
    {{0x20140206},		   0, 0x04000506,2,2,0xFFFF,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字6
    {{0x20140207},		   0, 0x04000507,2,2,0xFFFF,E_OOP_METWORD_T,	 0, },	// 2字节,电表运行状态字7

    {{0x20260200},		   -2, 0xFFFFFFFF,2,2,0xFFFF,E_LONG_UNSIGNED,	 -2, },	// 2字节,电压不平衡率
    {{0x20270200},		   -2, 0xFFFFFFFF,2,2,0xFFFF,E_LONG_UNSIGNED,	 -2, },	// 2字节,电流不平衡率

    {{0x40000200},		   0, 0x04000101,4,4,0xC010,E_REAL_DATETIME_S,   0, },// 4字节,
    {{0x40000200},		   0, 0x04000102,3,3,0xC011,E_REAL_DATETIME_S,   0, },// 3字节,

    {{0x202C0200},       -2,    0x00900200, 4,4,0xFFFF,    E_OOP_WALLET_T, -2, },// 4字节,钱包文件
    {{0x202C0200},        0,    0x03330201, 2,2,0xFFFF,    E_OOP_WALLET_T,  0, },// 3字节,钱包文件
    {{0x202C0201},       -2,    0x00900200, 4,4,0xFFFF,    E_DOUBLE_LONG_UNSIGNED, -2, },// 4字节,剩余金额
    {{0x202C0202},        0,    0x03330201, 2,2,0xFFFF,    E_DOUBLE_LONG_UNSIGNED,  0, },// 3字节,购电次数
    {{0x202D0200},       -2,    0x00900201, 4,4,0xFFFF,    E_DOUBLE_LONG_UNSIGNED, -2, },// 4字节,透支金额
    {{0x202E0200},       -2,    0x03330601, 4,4,0xFFFF,    E_DOUBLE_LONG_UNSIGNED, -2, },// 4字节,累计购电金额

    //第一象限无功总最大需量及发生时间
    {{0x10500200}, 0,	 0x0105FF00,	8,40,	0xA13F,E_OOP_DEMAND_T,  0,       },  //  (当前)第一象限无功总最大需量块
    {{0x10500200}, 0,	 0x0105FF00,	8,40,	0xB13F,E_OOP_DEMAND_T,  0,       },  //  (当前)第一象限无功总最大需量块
    {{0x10500201}, 0,	 0x01050000,	8,8,	0xA130,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第一象限无功总总最大需量
    {{0x10500201}, 0,	 0x01050000,	8,8,	0xB130,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第一象限无功总总最大需量
    {{0x10500202}, 0,	 0x01050100,	8,8,	0xA131,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第一象限无功最大需量
    {{0x10500202}, 0,	 0x01050100,	8,8,	0xB131,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第一象限无功最大需量
    {{0x10500203}, 0,	 0x01050200,	8,8,	0xA132,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第一象限无功最大需量
    {{0x10500203}, 0,	 0x01050200,	8,8,	0xB132,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第一象限无功最大需量
    {{0x10500204}, 0,	 0x01050300,	8,8,	0xA133,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第一象限无功最大需量
    {{0x10500204}, 0,	 0x01050300,	8,8,	0xB133,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第一象限无功最大需量
    {{0x10500205}, 0,	 0x01050400,	8,8,	0xA134,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第一象限无功最大需量
    {{0x10500205}, 0,	 0x01050400,	8,8,	0xB134,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第一象限无功最大需量

    //第二象限无功总最大需量及发生时间
    {{0x10600200}, 0,	 0x0106FF00,	8,40,	0xA15F,E_OOP_DEMAND_T,  0,       },  //  (当前)第二象限无功总最大需量块
    {{0x10600200}, 0,	 0x0106FF00,	8,40,	0xB15F,E_OOP_DEMAND_T,  0,       },  //  (当前)第二象限无功总最大需量块
    {{0x10600201}, 0,	 0x01060000,	8,8,	0xA150,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第二象限无功总总最大需量
    {{0x10600201}, 0,	 0x01060000,	8,8,	0xB150,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第二象限无功总总最大需量
    {{0x10600202}, 0,	 0x01060100,	8,8,	0xA151,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第二象限无功最大需量
    {{0x10600202}, 0,	 0x01060100,	8,8,	0xB151,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第二象限无功最大需量
    {{0x10600203}, 0,	 0x01060200,	8,8,	0xA152,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第二象限无功最大需量
    {{0x10600203}, 0,	 0x01060200,	8,8,	0xB152,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第二象限无功最大需量
    {{0x10600204}, 0,	 0x01060300,	8,8,	0xA153,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第二象限无功最大需量
    {{0x10600204}, 0,	 0x01060300,	8,8,	0xB153,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第二象限无功最大需量
    {{0x10600205}, 0,	 0x01060400,	8,8,	0xA154,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第二象限无功最大需量	
    {{0x10600205}, 0,    0x01060400,	8,8,	0xB154,E_OOP_DEMAND_T,  0,		},	// 3字节, XX.XXXX,  (当前)费率4第二象限无功最大需量
    //第三象限无功总最大需量及发生时间
    {{0x10700200}, 0,	 0x0107FF00,	8,40,	0xA16F,E_OOP_DEMAND_T,  0,       },  //  (当前)第三象限无功总最大需量块
    {{0x10700200}, 0,	 0x0107FF00,	8,40,	0xB16F,E_OOP_DEMAND_T,  0,       },  //  (当前)第三象限无功总最大需量块
    {{0x10700201}, 0,	 0x01070000,	8,8,	0xA160,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第三象限无功总总最大需量
    {{0x10700201}, 0,	 0x01070000,	8,8,	0xB160,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第三象限无功总总最大需量
    {{0x10700202}, 0,	 0x01070100,	8,8,	0xA161,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第三象限无功最大需量
    {{0x10700202}, 0,	 0x01070100,	8,8,	0xB161,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第三象限无功最大需量
    {{0x10700203}, 0,	 0x01070200,	8,8,	0xA162,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第三象限无功最大需量
    {{0x10700203}, 0,	 0x01070200,	8,8,	0xB162,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第三象限无功最大需量
    {{0x10700204}, 0,	 0x01070300,	8,8,	0xA163,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第三象限无功最大需量
    {{0x10700204}, 0,	 0x01070300,	8,8,	0xB163,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第三象限无功最大需量
    {{0x10700205}, 0,	 0x01070400,	8,8,	0xA164,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第三象限无功最大需量
    {{0x10700205}, 0,	 0x01070400,	8,8,	0xB164,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第三象限无功最大需量
    //第四象限无功总最大需量及发生时间
    {{0x10800200}, 0,	 0x0108FF00,	8,40,	0xA14F,E_OOP_DEMAND_T,  0,       },  //  (当前)第四象限无功总最大需量块
    {{0x10800200}, 0,	 0x0108FF00,	8,40,	0xB14F,E_OOP_DEMAND_T,  0,       },  //  (当前)第四象限无功总最大需量块
    {{0x10800201}, 0,	 0x01080000,	8,8,	0xA140,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第四象限无功总总最大需量
    {{0x10800201}, 0,	 0x01080000,	8,8,	0xB140,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)第四象限无功总总最大需量
    {{0x10800202}, 0,	 0x01080100,	8,8,	0xA141,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第四象限无功最大需量
    {{0x10800202}, 0,	 0x01080100,	8,8,	0xB141,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1第四象限无功最大需量
    {{0x10800203}, 0,	 0x01080200,	8,8,	0xA142,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第四象限无功最大需量
    {{0x10800203}, 0,	 0x01080200,	8,8,	0xB142,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2第四象限无功最大需量
    {{0x10800204}, 0,	 0x01080300,	8,8,	0xA143,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第四象限无功最大需量
    {{0x10800204}, 0,	 0x01080300,	8,8,	0xB143,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3第四象限无功最大需量
    {{0x10800205}, 0,	 0x01080400,	8,8,	0xA144,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第四象限无功最大需量
    {{0x10800205}, 0,	 0x01080400,	8,8,	0xB144,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4第四象限无功最大需量

    //正向视在最大需量及发生时间
    {{0x10900200}, 0,	 0x0109FF00,	8,40,	0xFFFF,E_OOP_DEMAND_T,  0,       },  //  (当前)正向视在最大需量块
    {{0x10900200}, 0,	 0x0109FF00,	8,40,	0xFFFF,E_OOP_DEMAND_T,  0,       },  //  (当前)正向视在最大需量块
    {{0x10900201}, 0,	 0x01090000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)正向视在最大需量
    {{0x10900201}, 0,	 0x01090000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)正向视在最大需量
    {{0x10900202}, 0,	 0x01090100,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1正向视在最大需量
    {{0x10900202}, 0,	 0x01090100,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1正向视在最大需量
    {{0x10900203}, 0,	 0x01090200,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2正向视在最大需量
    {{0x10900203}, 0,	 0x01090200,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2正向视在最大需量
    {{0x10900204}, 0,	 0x01090300,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3正向视在最大需量
    {{0x10900204}, 0,	 0x01090300,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3正向视在最大需量
    {{0x10900205}, 0,	 0x01090400,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4正向视在最大需量
    {{0x10900205}, 0,	 0x01090400,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4正向视在最大需量

    //反向视在最大需量及发生时间
    {{0x10a00200}, 0,	 0x010AFF00,	8,40,	0xFFFF,E_OOP_DEMAND_T,  0,       },  //  (当前)反向视在最大需量块
    {{0x10a00200}, 0,	 0x010AFF00,	8,40,	0xFFFF,E_OOP_DEMAND_T,  0,       },  //  (当前)反向视在最大需量块
    {{0x10a00201}, 0,	 0x010A0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)反向视在最大需量
    {{0x10a00201}, 0,	 0x010A0000,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)反向视在最大需量
    {{0x10a00202}, 0,	 0x010A0100,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1反向视在最大需量
    {{0x10a00202}, 0,	 0x010A0100,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率1反向视在最大需量
    {{0x10a00203}, 0,	 0x010A0200,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2反向视在最大需量
    {{0x10a00203}, 0,	 0x010A0200,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率2反向视在最大需量
    {{0x10a00204}, 0,	 0x010A0300,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3反向视在最大需量
    {{0x10a00204}, 0,	 0x010A0300,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率3反向视在最大需量
    {{0x10a00205}, 0,	 0x010A0400,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4反向视在最大需量
    {{0x10a00205}, 0,	 0x010A0400,	8,8,	0xFFFF,E_OOP_DEMAND_T,  0,       },  // 3字节, XX.XXXX,  (当前)费率4反向视在最大需量

    //交采参数相关
    {{0x40080200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_DATETIME_S,     0,      },//备用套时区表切换时间
    {{0x40090200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_DATETIME_S,     0,      },//备用套日时段切换时间
    {{0x400c0200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_PERIOD_T,   0,      },//时区时段数
    {{0x40140200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_TIMEZONE_T, 0,      },//当前套时区表
    {{0x40150200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_TIMEZONE_T, 0,      },//备用套时区表
    {{0x40160200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_DAYPERIOD_T,0,      },//当前套日时段表
    {{0x40170200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_DAYPERIOD_T,0,      },//备用套日时段表
    {{0x41000200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_UNSIGNED,       0,      },//最大需量周期
    {{0x41010200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_UNSIGNED,       0,      },//滑差时间
    {{0x41120200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_BITSTR8_T,  0,      },//有功组合方式特征字
    {{0x41130200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_BITSTR8_T,  0,      },//无功组合方式1特征字
    {{0x41140200}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_BITSTR8_T,  0,      },//无功组合方式2特征字
    {{0x43000300}, 0,	 0xFFFFFFFF,	1,1,	0xFFFF,E_OOP_VERSION_T,  0,      },//交采版本信息
    
    {{0xFFFFFFFF}, 0xFF, 0xFFFFFFFF,    0xFF, 0xFF, 0xFFFF, 0xFF, 0xFF	  },
};


/*******************************************************************************
* 所有 交采模块实时存储任务 (修改后, 添加存储周期)
********************************************************************************/
const uint32 gSaveTaskAll[] =
{
    /* 电能 */
    0x00000200,             //(当前)组合有功电能块
    0x00100200,             //(当前)正向有功电能总尖峰平谷示值
    0x00110200,             //(A相)正向有功总电能示值
    0x00120200,             //(B相)正向有功总电能示值
    0x00130200,             //(C相)正向有功总电能示值
    0x00200200,             //(当前)反向有功电能总尖峰平谷示值
    0x00210200,             //(A相)反向有功总电能示值
    0x00220200,             //(B相)反向有功总电能示值
    0x00230200,             //(C相)反向有功总电能示值
    0x00300200,             //(当前)正向无功电能总尖峰平谷示值
    0x00310200,             //(A相)正向无功总电能示值
    0x00320200,             //(B相)正向无功总电能示值
    0x00330200,             //(C相)正向无功总电能示值
    0x00400200,             //(当前)反向无功电能总尖峰平谷示值
    0x00410200,             //(A相)反向无功总电能示值
    0x00420200,             //(B相)反向无功总电能示值
    0x00430200,             //(C相)反向无功总电能示值
    0x00500200,             //(当前)第一象限无功总尖峰平谷电能示值
    0x00510200,             //(A相)第一象限无功电能
    0x00520200,             //(B相)第一象限无功电能
    0x00530200,             //(C相)第一象限无功电能
    0x00600200,             //(当前)第二象限无功总尖峰平谷电能示值
    0x00610200,             //(A相)第二象限无功电能
    0x00620200,             //(B相)第二象限无功电能
    0x00630200,             //(C相)第二象限无功电能
    0x00700200,             //(当前)第三象限无功总尖峰平谷电能示值
    0x00710200,             //(A相)第三象限无功电能
    0x00720200,             //(B相)第三象限无功电能
    0x00730200,             //(C相)第三象限无功电能
    0x00800200,             //(当前)第四象限无功总尖峰平谷电能示值
    0x00810200,             //(A相)第四象限无功电能
    0x00820200,             //(B相)第四象限无功电能
    0x00830200,             //(C相)第四象限无功电能
    0x00900200,             //(当前)正向视在电能数据块
    0x00910200,             //(A相)正向视在电能
    0x00920200,             //(B相)正向视在电能
    0x00930200,             //(C相)正向视在电能
    0x00A00200,             //(当前)反向视在电能数据块
    0x00A10200,             //(A相)反向视在电能
    0x00A20200,             //(B相)反向视在电能
    0x00A30200,             //(C相)反向视在电能

    /* 需量 */
    0x10100200,             //(当前)正向有功总尖峰平谷最大需量
    0x10110200,             //(A相)正向有功总最大需量
    0x10120200,             //(B相)正向有功总最大需量
    0x10130200,             //(C相)正向有功总最大需量
    0x10200200,             //(当前)反向有功总尖峰平谷最大需量
    0x10210200,             //(A相)反向有功最大需量
    0x10220200,             //(B相)反向有功最大需量
    0x10230200,             //(C相)反向有功最大需量
    0x10300200,             //(当前)正向无功总尖峰平谷最大需量
    0x10310200,             //(A相)组合无功1最大需量
    0x10320200,             //(B相)组合无功1最大需量
    0x10330200,             //(C相)组合无功1最大需量
    0x10400200,             //(当前)反向无功总尖峰平谷最大需量
    0x10410200,             //(A相)组合无功2最大需量
    0x10420200,             //(B相)组合无功2最大需量
    0x10430200,             //(C相)组合无功2最大需量
    0x10500200,             //(当前)第一象限最大需量总尖峰平谷
    0x10510200,             //(A相)第一象限最大需量
    0x10520200,             //(B相)第一象限最大需量
    0x10530200,             //(C相)第一象限最大需量
    0x10600200,             //(当前)第二象限最大需量总尖峰平谷
    0x10610200,             //(A相)第二象限最大需量
    0x10620200,             //(B相)第二象限最大需量
    0x10630200,             //(C相)第二象限最大需量
    0x10700200,             //(当前)第三象限最大需量总尖峰平谷
    0x10710200,             //(A相)第三象限最大需量
    0x10720200,             //(B相)第三象限最大需量
    0x10730200,             //(C相)第三象限最大需量
    0x10800200,             //(当前)第四象限最大需量总尖峰平谷
    0x10810200,             //(A相)第四象限最大需量
    0x10820200,             //(B相)第四象限最大需量
    0x10830200,             //(C相)第四象限最大需量
    0x10900200,             //(当前)正向视在最大需量总尖峰平谷
    0x10910200,             //(A相)正向视在最大需量
    0x10920200,             //(B相)正向视在最大需量
    0x10930200,             //(C相)正向视在最大需量
    0x10A00200,             //(当前)反向视在最大需量总尖峰平谷
    0x10A10200,             //(A相)反向视在最大需量
    0x10A20200,             //(B相)反向视在最大需量
    0x10A30200,             //(C相)反向视在最大需量

    /* 实时数据 */
    0x20000200, 			 //(当前)三相电压
    0x20000600,              //零序电压
    0x20010200, 			 //(当前)三相电流
    0x20010400,              //零线电流
    0x20010600,              //零序电流
    0x20020200,              //电压相角
    0x20030200,              //电压电流相角 
    0x20040200,              //(当前)瞬时正向有功功率
    0x20050200, 		     //(当前)瞬时正向无功功率
    0x20060200,              //(当前)瞬时正向视在功率
    0x200A0200,              //(当前)瞬时总及分相功率因数
    0x200F0200,              //电网频率
    0x20140200,             //电表运行状态字1-7
    0x20260200,             //电压不平衡率
    0x20270200,             //电流不平衡率

    /* 谐波 */
    0x200D0200,           	//A相电压谐波含有率（总及2…n次）
    0x200D0300,           	//B相电压谐波含有率（总及2…n次）
    0x200D0400,           	//C相电压谐波含有率（总及2…n次）
    0x200E0200,           	//A相电流谐波含有率（总及2…n次）
    0x200E0300,           	//B相电流谐波含有率（总及2…n次）
    0x200E0400,           	//C相电流谐波含有率（总及2…n次）

    0x20330200,           	//A相电压谐波含量（2…n次）
    0x20330300,           	//B相电压谐波含量（2…n次）
    0x20330400,           	//C相电压谐波含量（2…n次）
    0x20340200,           	//A相电流谐波含量（2…n次）
    0x20340300,           	//B相电流谐波含量（2…n次）
    0x20340400,           	//C相电流谐波含量（2…n次）

    /* 对象容器OAD */
    0xF2130201,           	//电量
    0xF2130202,           	//需量
    0xF2130203,           	//实时数据
    0xF2130204,           	//谐波
    
    0xFFFFFFFF
};

uint16 gSaveTaskAllNum = sizeof(gSaveTaskAll)/sizeof(uint32) - 1;  //gSaveTaskEnergy的元素个数

//交采参数相关(提供设置与查询服务)
const uint32 gSaveTaskPara[] =
{
    0x300F0600,           	//设置交采电压（电流）逆相序事件参数
    0x300F0900,           	//设置交采电压（电流）逆相序事件有效
    0x40000200,           	//设置时间
    0x40080200,           	//备用套时区表切换时间
    0x40090200,           	//备用套日时段切换时间
    0x400A0200,           	//备用套阶梯电价切换时间
    0x400C0200,           	//时区时段数
    0x40140200,           	//当前套时区表
    0x40150200,           	//备用套时区表
    0x40160200,           	//当前套日时段表
    0x40160201,             //当前套日时段表 第1套
    0x40160202,             //当前套日时段表 第2套
    0x40160203,             //当前套日时段表 第3套
    0x40160204,             //当前套日时段表 第4套
    0x40160205,             //当前套日时段表 第5套
    0x40160206,             //当前套日时段表 第6套
    0x40160207,             //当前套日时段表 第7套
    0x40160208,             //当前套日时段表 第8套
    0x40170200,           	//备用套日时段表
    0x40170201,             //备用套日时段表 第1套
    0x40170202,             //备用套日时段表 第2套
    0x40170203,             //备用套日时段表 第3套
    0x40170204,             //备用套日时段表 第4套
    0x40170205,             //备用套日时段表 第5套
    0x40170206,             //备用套日时段表 第6套
    0x40170207,             //备用套日时段表 第7套
    0x40170208,             //备用套日时段表 第8套
    0x40300200,           	//设置交采电压合格率参数
    0x41000200,           	//最大需量周期 分钟
    0x41010200,           	//滑差时间 分钟
    0x41120200,           	//有功组合方式特征字
    0x41130200,           	//无功组合方式1特征字
    0x41140200,           	//无功组合方式2特征字

    0xFFFFFFFF
};

uint16 gSaveTaskParaNum = sizeof(gSaveTaskPara)/sizeof(uint32) - 1;  //gSaveTaskPara的元素个数

const uint32 gSubOadData[] =
{
    0x40000200,			   //(当前)交采时钟
    0x20000201,			   //(当前)三相电压 A分项
    0x20000202,			   //(当前)三相电压 B分项
    0x20000203,			   //(当前)三相电压 C分项
    0x20010201,			   //(当前)三相电流 A分项
    0x20010202,			   //(当前)三相电流 B分项
    0x20010203,			   //(当前)三相电流 C分项
    0x200A0201,			   //(当前)瞬时总及分相功率因数 总
    0x200A0202,			   //(当前)瞬时总及分相功率因数 A
    0x200A0203,			   //(当前)瞬时总及分相功率因数 B
    0x200A0204,			   //(当前)瞬时总及分相功率因数 C
    0x40160201,            //当前套日时段表 第1套
    0x40160202,            //当前套日时段表 第2套
    0x40160203,            //当前套日时段表 第3套
    0x40160204,            //当前套日时段表 第4套
    0x40160205,            //当前套日时段表 第5套
    0x40160206,            //当前套日时段表 第6套
    0x40160207,            //当前套日时段表 第7套
    0x40160208,            //当前套日时段表 第8套
    0x43000300,            //版本信息
    0xFFFFFFFF
};
uint16 gSubOadDataNum = sizeof(gSubOadData)/sizeof(uint32) - 1;  //gSubOadData的元素个数
const uint32 gActionPara[] =
{
    0x50040500,           	//删除交采冻结关联列
    0x50040700,           	//配置交采冻结关联列
    0x50060500,           	//删除交采冻结关联列
    0x50060700,           	//配置交采冻结关联列
    0xFFFFFFFF
};
uint16 gActionParaNum = sizeof(gActionPara)/sizeof(uint32) - 1;  //gActionPara的元素个数
const uint32 gRecordData[] =
{
    0x50040200,           	//日冻结记录
    0x50060200,           	//月冻结记录
    0x300F0200,           	//电压逆向序事件
    0xFFFFFFFF
};
uint16 gRecordDataNum = sizeof(gRecordData)/sizeof(uint32) - 1;  //gRecordData的元素个数
/*******************************************************************************
* 交采模块实时存储任务(修改后, 添加存储周期)
********************************************************************************/
const uint32 gSaveTaskEnergy[] =
{
    /* 电能 */
    0x00000200,             //(当前)组合有功电能总尖峰平谷示值
    0x00010200,             //(A相)组合有功电能示值
    0x00020200,             //(B相)组合有功电能示值
    0x00030200,             //(C相)组合有功电能示值
    0x00100200,             //(当前)正向有功电能总尖峰平谷示值
    0x00110200,             //(A相)正向有功总电能示值
    0x00120200,             //(B相)正向有功总电能示值
    0x00130200,             //(C相)正向有功总电能示值
    0x00200200,             //(当前)反向有功电能总尖峰平谷示值
    0x00210200,             //(A相)反向有功总电能示值
    0x00220200,             //(B相)反向有功总电能示值
    0x00230200,             //(C相)反向有功总电能示值
    0x00300200,             //(当前)正向无功电能总尖峰平谷示值
    0x00310200,             //(A相)正向无功总电能示值
    0x00320200,             //(B相)正向无功总电能示值
    0x00330200,             //(C相)正向无功总电能示值
    0x00400200,             //(当前)反向无功电能总尖峰平谷示值
    0x00410200,             //(A相)反向无功总电能示值
    0x00420200,             //(B相)反向无功总电能示值
    0x00430200,             //(C相)反向无功总电能示值
    0x00500200,             //(当前)第一象限无功总尖峰平谷电能示值
    0x00510200,             //(A相)第一象限无功电能
    0x00520200,             //(B相)第一象限无功电能
    0x00530200,             //(C相)第一象限无功电能
    0x00600200,             //(当前)第二象限无功总尖峰平谷电能示值
    0x00610200,             //(A相)第二象限无功电能
    0x00620200,             //(B相)第二象限无功电能
    0x00630200,             //(C相)第二象限无功电能
    0x00700200,             //(当前)第三象限无功总尖峰平谷电能示值
    0x00710200,             //(A相)第三象限无功电能
    0x00720200,             //(B相)第三象限无功电能
    0x00730200,             //(C相)第三象限无功电能
    0x00800200,             //(当前)第四象限无功总尖峰平谷电能示值
    0x00810200,             //(A相)第四象限无功电能
    0x00820200,             //(B相)第四象限无功电能
    0x00830200,             //(C相)第四象限无功电能
    0x00900200,             //(当前)正向视在电能数据块
    0x00910200,             //(A相)正向视在电能
    0x00920200,             //(B相)正向视在电能
    0x00930200,             //(C相)正向视在电能
    0x00A00200,             //(当前)反向视在电能数据块
    0x00A10200,             //(A相)反向视在电能
    0x00A20200,             //(B相)反向视在电能
    0x00A30200,             //(C相)反向视在电能

#if HD_ENERGY_EN == 1
    /* 高精度 电能 */
    0x00000400,             //(当前)组合有功电能块
    0x00100400,             //(当前)正向有功电能总尖峰平谷示值
    0x00110400,             //(A相)正向有功总电能示值
    0x00120400,             //(B相)正向有功总电能示值
    0x00130400,             //(C相)正向有功总电能示值
    0x00200400,             //(当前)反向有功电能总尖峰平谷示值
    0x00210400,             //(A相)反向有功总电能示值
    0x00220400,             //(B相)反向有功总电能示值
    0x00230400,             //(C相)反向有功总电能示值
    0x00300400,             //(当前)正向无功电能总尖峰平谷示值
    0x00310400,             //(A相)正向无功总电能示值
    0x00320400,             //(B相)正向无功总电能示值
    0x00330400,             //(C相)正向无功总电能示值
    0x00400400,             //(当前)反向无功电能总尖峰平谷示值
    0x00410400,             //(A相)反向无功总电能示值
    0x00420400,             //(B相)反向无功总电能示值
    0x00430400,             //(C相)反向无功总电能示值
    0x00500400,             //(当前)第一象限无功总尖峰平谷电能示值
    0x00510400,             //(A相)第一象限无功电能
    0x00520400,             //(B相)第一象限无功电能
    0x00530400,             //(C相)第一象限无功电能
    0x00600400,             //(当前)第二象限无功总尖峰平谷电能示值
    0x00610400,             //(A相)第二象限无功电能
    0x00620400,             //(B相)第二象限无功电能
    0x00630400,             //(C相)第二象限无功电能
    0x00700400,             //(当前)第三象限无功总尖峰平谷电能示值
    0x00710400,             //(A相)第三象限无功电能
    0x00720400,             //(B相)第三象限无功电能
    0x00730400,             //(C相)第三象限无功电能
    0x00800400,             //(当前)第四象限无功总尖峰平谷电能示值
    0x00810400,             //(A相)第四象限无功电能
    0x00820400,             //(B相)第四象限无功电能
    0x00830400,             //(C相)第四象限无功电能
    0x00900400,             //(当前)正向视在电能数据块
    0x00910400,             //(A相)正向视在电能
    0x00920400,             //(B相)正向视在电能
    0x00930400,             //(C相)正向视在电能
    0x00A00400,             //(当前)反向视在电能数据块
    0x00A10400,             //(A相)反向视在电能
    0x00A20400,             //(B相)反向视在电能
    0x00A30400,             //(C相)反向视在电能
#endif

    /* 实时数据 */
    0x20000200, 			 //(当前)三相电压
    0x20000600,              //零序电压
    0x20010200, 			 //(当前)三相电流
    0x20010400,              //零线电流
    0x20010600,              //零序电流
    0x20020200,              //电压相角
    0x20030200,              //电压电流相角 
    0x20040200,              //(当前)瞬时正向有功功率
    0x20050200, 		     //(当前)瞬时正向无功功率
    0x20060200,              //(当前)瞬时正向视在功率
    0x200A0200,              //(当前)瞬时总及分相功率因数
    0x200F0200,              //电网频率
    0x20140200,             //电表运行状态字1-7
    0x20260200,             //电压不平衡率
    0x20270200,             //电流不平衡率
    0xFFFFFFFF
};

uint16 gSaveTaskEnergyNum = sizeof(gSaveTaskEnergy)/sizeof(uint32) - 1;  //gSaveTaskEnergy的元素个数

/*******************************************************************************
* 交采模块实时存储任务(修改后, 添加存储周期)
********************************************************************************/
const uint32 gSaveTaskDemand[] =
{
    /* 需量 */
    0x10100200,             //(当前)正向有功总尖峰平谷最大需量
    0x10110200,             //(A相)正向有功总最大需量
    0x10120200,             //(B相)正向有功总最大需量
    0x10130200,             //(C相)正向有功总最大需量
    0x10200200,             //(当前)反向有功总尖峰平谷最大需量
    0x10210200,             //(A相)反向有功最大需量
    0x10220200,             //(B相)反向有功最大需量
    0x10230200,             //(C相)反向有功最大需量
    0x10300200,             //(当前)正向无功总尖峰平谷最大需量
    0x10310200,             //(A相)组合无功1最大需量
    0x10320200,             //(B相)组合无功1最大需量
    0x10330200,             //(C相)组合无功1最大需量
    0x10400200,             //(当前)反向无功总尖峰平谷最大需量
    0x10410200,             //(A相)组合无功2最大需量
    0x10420200,             //(B相)组合无功2最大需量
    0x10430200,             //(C相)组合无功2最大需量
    0x10500200,             //(当前)第一象限最大需量总尖峰平谷
    0x10510200,             //(A相)第一象限最大需量
    0x10520200,             //(B相)第一象限最大需量
    0x10530200,             //(C相)第一象限最大需量
    0x10600200,             //(当前)第二象限最大需量总尖峰平谷
    0x10610200,             //(A相)第二象限最大需量
    0x10620200,             //(B相)第二象限最大需量
    0x10630200,             //(C相)第二象限最大需量
    0x10700200,             //(当前)第三象限最大需量总尖峰平谷
    0x10710200,             //(A相)第三象限最大需量
    0x10720200,             //(B相)第三象限最大需量
    0x10730200,             //(C相)第三象限最大需量
    0x10800200,             //(当前)第四象限最大需量总尖峰平谷
    0x10810200,             //(A相)第四象限最大需量
    0x10820200,             //(B相)第四象限最大需量
    0x10830200,             //(C相)第四象限最大需量
    0x10900200,             //(当前)正向视在最大需量总尖峰平谷
    0x10910200,             //(A相)正向视在最大需量
    0x10920200,             //(B相)正向视在最大需量
    0x10930200,             //(C相)正向视在最大需量
    0x10A00200,             //(当前)反向视在最大需量总尖峰平谷
    0x10A10200,             //(A相)反向视在最大需量
    0x10A20200,             //(B相)反向视在最大需量
    0x10A30200,             //(C相)反向视在最大需量

    /* 实时数据 */
    0x20000200, 			 //(当前)三相电压
    0x20000600,              //零序电压
    0x20010200, 			 //(当前)三相电流
    0x20010400,              //零线电流
    0x20010600,              //零序电流
    0x20020200,              //电压相角
    0x20030200,              //电压电流相角 
    0x20040200,              //(当前)瞬时正向有功功率
    0x20050200, 		     //(当前)瞬时正向无功功率
    0x20060200,              //(当前)瞬时正向视在功率
    0x200A0200,              //(当前)瞬时总及分相功率因数
    0x200F0200,              //电网频率
    0x20140200,             //电表运行状态字1-7
    0x20260200,             //电压不平衡率
    0x20270200,             //电流不平衡率
    0xFFFFFFFF
};

uint16 gSaveTaskDemandNum = sizeof(gSaveTaskDemand)/sizeof(uint32) - 1;  //gSaveTaskDemand的元素个数

/*******************************************************************************
* 交采模块实时存储任务(修改后, 添加存储周期)
********************************************************************************/
const uint32 gSaveTaskRealtime[] =
{
    /* 实时数据 */
    0x20000200, 			 //(当前)三相电压
    0x20000600,              //零序电压
    0x20010200, 			 //(当前)三相电流
    0x20010400,              //零线电流
    0x20010600,              //零序电流
    0x20020200,              //电压相角
    0x20030200,              //电压电流相角 
    0x20040200,              //(当前)瞬时正向有功功率
    0x20050200, 		     //(当前)瞬时正向无功功率
    0x20060200,              //(当前)瞬时正向视在功率
    0x200A0200,              //(当前)瞬时总及分相功率因数
    0x200F0200,              //电网频率
    0x20140200,             //电表运行状态字1-7
    0x20260200,             //电压不平衡率
    0x20270200,             //电流不平衡率
    0xFFFFFFFF
};

uint16 gSaveTaskRealtimeNum = sizeof(gSaveTaskRealtime)/sizeof(uint32) - 1;  //gSaveTaskRealtime的元素个数

/*******************************************************************************
* 交采模块实时存储任务(修改后, 添加存储周期)
********************************************************************************/
const uint32 gSaveTaskHarmonic[] =
{
    /* 谐波 */
    0x200D0200,           	//A相电压谐波含有率（总及2…n次）
    0x200D0300,           	//B相电压谐波含有率（总及2…n次）
    0x200D0400,           	//C相电压谐波含有率（总及2…n次）
    0x200E0200,           	//A相电流谐波含有率（总及2…n次）
    0x200E0300,           	//B相电流谐波含有率（总及2…n次）
    0x200E0400,           	//C相电流谐波含有率（总及2…n次）

    0x20330200,           	//A相电压谐波含量（2…n次）
    0x20330300,           	//B相电压谐波含量（2…n次）
    0x20330400,           	//C相电压谐波含量（2…n次）
    0x20340200,           	//A相电流谐波含量（2…n次）
    0x20340300,           	//B相电流谐波含量（2…n次）
    0x20340400,           	//C相电流谐波含量（2…n次）

    /* 实时数据 */
    0x20000200, 			 //(当前)三相电压
    0x20000600,              //零序电压
    0x20010200, 			 //(当前)三相电流
    0x20010400,              //零线电流
    0x20010600,              //零序电流
    0x20020200,              //电压相角
    0x20030200,              //电压电流相角 
    0x20040200,              //(当前)瞬时正向有功功率
    0x20050200, 		     //(当前)瞬时正向无功功率
    0x20060200,              //(当前)瞬时正向视在功率
    0x200A0200,              //(当前)瞬时总及分相功率因数
    0x200F0200,              //电网频率
    0x20140200,             //电表运行状态字1-7
    0x20260200,             //电压不平衡率
    0x20270200,             //电流不平衡率
    0xFFFFFFFF
};

uint16 gSaveTaskHarmonicNum = sizeof(gSaveTaskHarmonic)/sizeof(uint32) - 1;  //gSaveTaskHarmonic的元素个数

/*******************************************************************************
* 交采模块特殊存储任务(非消息接口涉及的数据)
********************************************************************************/
const uint32 gSaveTaskSpecial[] =
{
    /* 特殊数据 */
    0xAAAA0001,              //电流相角(特殊 暂时)
    0xFFFFFFFF
};

uint16 gSaveTaskSpecialNum = sizeof(gSaveTaskSpecial)/sizeof(uint32) - 1;  //gSaveTaskSpecial 的元素个数

/*******************************************************************************
* 交采模块实时存储任务(修改后, 添加存储周期)
********************************************************************************/
const uint32 gSaveTaskContainer[] =
{
    /* 对象容器OAD */
    0xF2130201,           	//电量
    0xF2130202,           	//需量
    0xF2130203,           	//实时数据
    0xF2130204,           	//谐波
    0xFFFFFFFF
};

uint16 gSaveTaskContainerNum = sizeof(gSaveTaskContainer)/sizeof(uint32) - 1;  //gSaveTaskContainer的元素个数


/*******************************************************************************
* 全局变量
********************************************************************************/

COMMON_DATA_TYPE        gSaveCommonData;             // 公共交互变量 数据中心交互计时器
PRIVATE_DATA_TYPE       gSavePrivateData;            // 私有数据变量 数据中心交互计时器

SAVE_FLAG_T             gSaveFlag;                   //存储公共标记

EVENT_COMM_INFO         gEventCommInfo;              //公共事件信息
extern OOP_OCTETVAR16_T tmnAddr;                     //终端通信地址
extern OOP_OCTETVAR64_T MAC;                         //校验码
OOP_CHANNEL_T           g_tnmPort;                   //终端上报端口

char       *gEventParaPath = "/data/app/acMeter/EventPara";  //磁场干扰事件参数私有文件
uint16     gAcTopoEventNum = 0;  //终端本体拓扑识别事件个数
uint16     gAcEventNum = 0;  //终端本体事件个数
TOTAL_EVENT_INFO gTotalEventInfo;//所有事件状态汇总
EVENT_300F_INFO event_300F;  //终端相序异常事件

STA_PARAM_UPDATE g_staUpdateData = {{{0}},0xff,0xff,0xff,0xff};
/*冻结参数链表*/
FrzRunParaList_t* g_staFrozenParaList[STA_FROZEN_OBJNUMS]={NULL};
uint32 g_frozen_index[STA_FROZEN_OBJNUMS] = {0};

/****************************************************************************
*模块编号：
*名称：FindDetailInfoByOad
*功能：查找oad对应详细特征
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
const Map645ToOop_NEW* FindDetailInfoByOad(uint32 OAD)
{
    const Map645ToOop_NEW *pMap645ToOop = NULL;

    pMap645ToOop = gMap645ToOop_RT;//实时数据
    
    if(pMap645ToOop==NULL)
    {
        return NULL;
    }  

    while(pMap645ToOop->Oad.value != 0xFFFFFFFF)
    {
        if(pMap645ToOop->Oad.value == OAD) 
        {
            return pMap645ToOop;
        }
        pMap645ToOop++;
    }
    
    return NULL;
}

/**********************************************************************
* @name      : InitEventPara
* @brief     ：事件参数初始化
* @param[in] ：
* @param[out]：
* @return    ：
* @Create    : 梅安宁
* @Date      ：2020-02-14
* @Update    :
**********************************************************************/
void InitEventPara(void)
{
    int         ret     = -1;
    uint32      len     = 0;
    NOMAL_OAD_T nomalOAD;

    ACDB_FMT_DEBUG("InitEventPara() start...\n");

    memset(&nomalOAD, 0, sizeof(NOMAL_OAD_T));
    memset(&g_tnmPort, 0, sizeof(OOP_CHANNEL_T));
    memset(&tmnAddr, 0, sizeof(OOP_OCTETVAR16_T));
    memset(&MAC, 0, sizeof(OOP_OCTETVAR64_T));

    //读取终端地址
    nomalOAD.oad.value = 0x40010200;
    ret = db_read_nomal(gDataCenterClient, &nomalOAD, sizeof(OOP_OCTETVAR16_T), (uint8 *)&tmnAddr, &len);
    if(0 == ret && len == sizeof(OOP_OCTETVAR16_T))
    {
        MAC.nNum = 6;
        memcpy(MAC.value, tmnAddr.value, MAC.nNum);
        ACDB_FMT_DEBUG("InitEventPara() 校验MAC=%02X %02X %02X %02X %02X %02X \n", MAC.value[0], MAC.value[1], MAC.value[2], MAC.value[3], MAC.value[4], MAC.value[5]);
    }
    else
    {
        ACDB_FMT_DEBUG("InitEventPara() 终端地址 nomal_data_read() 失败! OAD=%08X, ret=%d, len=%d\n", nomalOAD.oad.value, ret, len);
    }

    //读取通道上报状态
    memset(&nomalOAD, 0, sizeof(NOMAL_OAD_T));
    nomalOAD.oad.value = 0x43000a00;
    ret = db_read_nomal(gDataCenterClient, &nomalOAD, sizeof(OOP_CHANNEL_T), (uint8 *)&g_tnmPort, &len);
    if(0 == ret && len == sizeof(OOP_CHANNEL_T))
    {
        ACDB_FMT_DEBUG("InitEventPara() 上报通道信息 g_tnmPort num %u, port1=%08X\n", g_tnmPort.nNum, g_tnmPort.port[0].value);
    }
    else
    {
        ACDB_FMT_DEBUG("InitEventPara() 通道上报状态 nomal_data_read()失败! OAD=%08X, ret=%d, len=%d\n", nomalOAD.oad.value, ret, len);
    }

    ACDB_FMT_DEBUG("InitEventPara() end...\n");
}

/**********************************************************************
* @name      : cur_abn_event_read
* @brief     ：读取当前事件个数和索引
* @param[in] ：
* @param[out]：
* @return    ：
* @Create    : 
* @Date      ：
* @Update    :
**********************************************************************/
int cur_abn_event_read(DB_CLIENT client_id, RECORD_OAD_T recordOAD, OOP_OCTETVAR64_T mac, uint16* nEventNum, uint32* nIndex)
{
    READ_RECORD_T startReadRecord;
    STEP_READ_RECORD_T stepReadRecord;
    RECORD_UNIT_T stepRecordOut;
    OOP_EVENT_T *pTemp = NULL;
    uint32 handle = 0;
    uint32 recNum = 0;
    int  ret = 0;
    time_t timep;

    memset(&startReadRecord,0,sizeof(READ_RECORD_T));
    memset(&stepReadRecord,0,sizeof(STEP_READ_RECORD_T));
    memset(&stepRecordOut,0,sizeof(RECORD_UNIT_T));

    time(&timep); //获取从1970至今过了多少秒，存入time_t类型的timep
    timep += COMPENSATION_TIME;
    startReadRecord.recordOAD = recordOAD;
    startReadRecord.cType = 0x02;
    startReadRecord.cStart = 0;
    startReadRecord.cEnd = timep;
    startReadRecord.sortType = 0x01;
   
    ret = db_read_record_start(client_id, &startReadRecord, &handle, &recNum);
    if (ret != ERR_OK)
    {
        ACDB_FMT_DEBUG("db_read_record_start, OAD=%8X error ret %d\n", recordOAD.road.oadMain.value, ret);
        return ret;

    }

    *nEventNum = (uint16)recNum;
    
    if(recNum == 0)
    {
        db_read_record_end(client_id, handle);
        
        return ERR_OK;
    }

    stepReadRecord.MAC = mac;
    
    ret = db_read_record_step(client_id, handle, &stepReadRecord, &stepRecordOut);   
    db_read_record_end(client_id, handle);
    
    if (ret != ERR_OK)
    {
        ACDB_FMT_DEBUG("db_read_record_step,infoNum=%hu, OAD=%8X error ret %d\n", recordOAD.infoNum, recordOAD.road.oadMain.value, ret);
        return ret;

    }
    else
    {
        pTemp = (OOP_EVENT_T *)stepRecordOut.record[0].outDataBuf;
        *nIndex = pTemp->nIndex;
    }

    return ERR_OK;
}

/**********************************************************************
* @name      : InitEventPara
* @brief     ：事件参数初始化
* @param[in] ：
* @param[out]：
* @return    ：
* @Create    : 梅安宁
* @Date      ：2020-02-14
* @Update    :
**********************************************************************/
void InitEventRptPara(void)
{
    int         ret     = -1;
    uint32      len     = 0;
    NOMAL_OAD_T nomalOAD;

    ACDB_FMT_DEBUG("InitEventPara() start...\n");

    memset(&nomalOAD, 0, sizeof(NOMAL_OAD_T));
    memset(&g_tnmPort, 0, sizeof(OOP_CHANNEL_T));
    memset(&tmnAddr, 0, sizeof(OOP_OCTETVAR16_T));
    memset(&MAC, 0, sizeof(OOP_OCTETVAR64_T));

    if (gRptClient <= 0)
    {
        gRptClient  = db_client_create(DB_AC_AGENT, DB_AC_CLIENT_RPT);
        if (gRptClient <= 0)
        {
            EVENT_FMT_DEBUG("创建事件上报存储句柄失败\n");
            return;
        }
    }

    //读取终端地址
    nomalOAD.oad.value = 0x40010200;
    ret = db_read_nomal(gRptClient, &nomalOAD, sizeof(OOP_OCTETVAR16_T), (uint8 *)&tmnAddr, &len);
    if(0 == ret && len == sizeof(OOP_OCTETVAR16_T))
    {
        MAC.nNum = 6;
        memcpy(MAC.value, tmnAddr.value, MAC.nNum);
        ACDB_FMT_DEBUG("InitEventPara() 校验MAC=%02X %02X %02X %02X %02X %02X \n", MAC.value[0], MAC.value[1], MAC.value[2], MAC.value[3], MAC.value[4], MAC.value[5]);
    }
    else
    {
        ACDB_FMT_DEBUG("InitEventPara() 终端地址 nomal_data_read() 失败! OAD=%08X, ret=%d, len=%d\n", nomalOAD.oad.value, ret, len);
    }

    //读取通道上报状态
    memset(&nomalOAD, 0, sizeof(NOMAL_OAD_T));
    nomalOAD.oad.value = 0x43000a00;
    ret = db_read_nomal(gRptClient, &nomalOAD, sizeof(OOP_CHANNEL_T), (uint8 *)&g_tnmPort, &len);
    if(0 == ret && len == sizeof(OOP_CHANNEL_T))
    {
        ACDB_FMT_DEBUG("InitEventPara() 上报通道信息 g_tnmPort num %u, port1=%08X\n", g_tnmPort.nNum, g_tnmPort.port[0].value);
    }
    else
    {
        ACDB_FMT_DEBUG("InitEventPara() 通道上报状态 nomal_data_read()失败! OAD=%08X, ret=%d, len=%d\n", nomalOAD.oad.value, ret, len);
    }

    ACDB_FMT_DEBUG("InitEventPara() end...\n");
}


/****************************************************************************
*模块编号：
*名称： SaveMagneticEventOccur
*功能：将磁场干扰事件发生存入数据中心(新增)
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int SaveMagneticEventOccur()
{
    ACDB_FMT_DEBUG("SaveMagneticEventOccur() 磁场干扰事件发生存入数据中心 start... \n");
    
    WRITE_RECORD_T recInData;
    NOMAL_OAD_T nomalOAD;
    OOP_EVENT_T MagneticEffectEvent;  //标准事件单元(电能表恒定磁场干扰事件)
    uint16 recNum = 0;
    uint32 evtIndex = 0;
    int ret = -1;
    int i = 0;
    
    memset(&recInData,0,sizeof(WRITE_RECORD_T));
    memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
    memset(&MagneticEffectEvent,0,sizeof(OOP_EVENT_T));

    gEventCommInfo.eventOAD.value = 0x302A0200;
    time(&gEventCommInfo.tStartTime); /*获取time_t类型的当前时间*/
    systm_to_ooptm(gEventCommInfo.tStartTime, &gEventCommInfo.starttime);  //事件发生时间

    //step1: 存储事件
    recInData.recordOAD.logicId = 0;
    recInData.recordOAD.classtag = CLASS_DATA_EVENT;
    recInData.recordOAD.road.oadCols.nNum = 1;
    recInData.recordOAD.road.oadCols.oad[0] = gEventCommInfo.eventOAD;//电能表恒定磁场干扰事件
//    recInData.MAC = MAC;

    cur_abn_event_read(gDataCenterClient, recInData.recordOAD, recInData.MAC, &recNum, &evtIndex);
    gEventCommInfo.recordnum = evtIndex + 1;
    
    recInData.colStartTm = gEventCommInfo.tStartTime;//开始时间
    recInData.colEndTm = gEventCommInfo.tStartTime;//结束时间
    recInData.colStoreTm = gEventCommInfo.recordnum;  //存储时间为事件序号

    ACDB_FMT_DEBUG("recInData信息: logicId=%d, classtag=%d, nNum=%d, oad[0]=0x%08x, colStartTm=%u, colEndTm=%u, colStoreTm=%u \n", 
        recInData.recordOAD.logicId, recInData.recordOAD.classtag, recInData.recordOAD.road.oadCols.nNum, 
        recInData.recordOAD.road.oadCols.oad[0].value, recInData.colStartTm, recInData.colEndTm, recInData.colStoreTm);
    
    MagneticEffectEvent.nIndex = gEventCommInfo.recordnum;  //事件记录序号
    MagneticEffectEvent.tmStart = gEventCommInfo.starttime;  //事件发生时间
    memset(&MagneticEffectEvent.tmEnd, 0x00, sizeof(OOP_DATETIME_S_T));  //事件结束时间

    //上报状态
    MagneticEffectEvent.state.nNum = g_tnmPort.nNum;
    for(i=0; i<g_tnmPort.nNum; i++)
    {
        MagneticEffectEvent.state.state[i].oad = g_tnmPort.port[i];
        MagneticEffectEvent.state.state[i].state = 0;
    }
    memcpy(recInData.inDataBuf, &MagneticEffectEvent, sizeof(OOP_EVENT_T));
    recInData.inDatalen = sizeof(OOP_EVENT_T);
    ACDB_BUF_DEBUG(recInData.inDataBuf, sizeof(OOP_EVENT_T), "recInData事件内容:");
    
    ret = db_write_record(gDataCenterClient, &recInData, &gEventCommInfo.storagenum);
    ACDB_FMT_DEBUG("db_write_record() 事件存储返回结果 ret=%d, storagenum=%u \n", ret, gEventCommInfo.storagenum);
    if (ret != ERR_OK)
    {
        ACDB_FMT_DEBUG("db_write_record() 事件存储失败! ret=%d \n", ret);
        return -1;
    }
    else
    {
        //step2: 事件记录条数
        gEventCommInfo.eventNum = recNum + 1;
        
        memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
        nomalOAD.logicId = 0;
        nomalOAD.oad.value = Uint16To32(gEventCommInfo.eventOAD.nObjID, 0X0400);
        nomalOAD.classtag = CLASS_DATA_EVENT;
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8 *)&gEventCommInfo.eventNum, 2);
        ACDB_FMT_DEBUG("事件记录条数 db_write_nomal() logicId=%d, oad=0x%08x, classtag=%d, eventNum=%d, ret = %d\n", 
            nomalOAD.logicId, nomalOAD.oad.value, nomalOAD.classtag, gEventCommInfo.eventNum, ret);


        //step3: 事件当前值记录
        gEventCommInfo.eventState.dwCount = gEventCommInfo.eventNum;
        gEventCommInfo.eventState.dbIdx = gEventCommInfo.recordnum;
        gEventCommInfo.eventState.tmStart = gEventCommInfo.tStartTime;

        memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
        nomalOAD.logicId = 0;
        nomalOAD.oad.value = Uint16To32(gEventCommInfo.eventOAD.nObjID, 0X0700);
        nomalOAD.classtag = CLASS_DATA_EVENT;
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8 *)&gEventCommInfo.eventState, sizeof(EVTSTATE));
        ACDB_FMT_DEBUG("事件当前值记录 db_write_nomal() logicId=%d, oad=0x%08x, classtag=%d, dwCount=%u, dbIdx=%u, tmStart=%u, ret = %d\n", 
            nomalOAD.logicId, nomalOAD.oad.value, nomalOAD.classtag, gEventCommInfo.eventState.dwCount, gEventCommInfo.eventState.dbIdx, 
            gEventCommInfo.eventState.tmStart, ret);


        //step4: 事件时间状态记录
        gEventCommInfo.eventTime.dbIdx = gEventCommInfo.recordnum;
        gEventCommInfo.eventTime.tmStart = gEventCommInfo.starttime;

        memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
        nomalOAD.logicId = 0;
        nomalOAD.oad.value = Uint16To32(gEventCommInfo.eventOAD.nObjID, 0X0A00);
        nomalOAD.classtag = CLASS_DATA_EVENT;
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8 *)&gEventCommInfo.eventTime, sizeof(EVTTIME));
        ACDB_FMT_DEBUG("事件时间状态记录 db_write_nomal() logicId=%d, oad=0x%08x, classtag=%d, dbIdx=%u, %u-%u-%u %u:%u:%u, week %u, ret=%d\n", 
            nomalOAD.logicId, nomalOAD.oad.value, nomalOAD.classtag, gEventCommInfo.eventState.dbIdx, gEventCommInfo.eventTime.tmStart.year,
            gEventCommInfo.eventTime.tmStart.month, gEventCommInfo.eventTime.tmStart.day, gEventCommInfo.eventTime.tmStart.hour,
            gEventCommInfo.eventTime.tmStart.minute, gEventCommInfo.eventTime.tmStart.second, gEventCommInfo.eventTime.tmStart.week, ret);
    }

    //磁场干扰参数保存至私有文件
    ret = write_pdata_xram(gEventParaPath, (char *)&gEventCommInfo, 0, sizeof(EVENT_COMM_INFO));
    ACDB_FMT_DEBUG("SaveMagneticEventOccur() 保存磁场干扰事件参数 write_pdata_xram() ret=%d \n", ret);
    
    return 1;
}

/****************************************************************************
*模块编号：
*名称： SaveMagneticEventRecover
*功能：将磁场干扰事件恢复存入数据中心(更新)
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int SaveMagneticEventRecover()
{
    ACDB_FMT_DEBUG("SaveMagneticEventRecover() 磁场干扰事件恢复存入数据中心 start... \n");
    
    UPDATE_RECORD_T updateRecordData;
    NOMAL_OAD_T nomalOAD;
    OOP_EVENT_T MagneticEffectEvent;  //标准事件单元(电能表恒定磁场干扰事件)
    int ret = -1;
    int i = 0;
    
    memset(&updateRecordData,0,sizeof(UPDATE_RECORD_T));
    memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
    memset(&MagneticEffectEvent,0,sizeof(OOP_EVENT_T));

    gEventCommInfo.eventOAD.value = 0x302A0200;
    current_tm_to_ooptm(&gEventCommInfo.endtime);

    //step1: 更新事件
    updateRecordData.recordOAD.logicId = 0;
    updateRecordData.recordOAD.optional = 0;
    updateRecordData.recordOAD.road.oadCols.nNum = 1;
    updateRecordData.recordOAD.road.oadCols.oad[0] = gEventCommInfo.eventOAD;
//    updateRecordData.MAC = MAC;
    updateRecordData.filter.choice = 2;
    updateRecordData.filter.storeNo = gEventCommInfo.storagenum;

    ACDB_FMT_DEBUG("updateRecordData信息 logicId=%d, optional=%d, nNum=%d, oad[0]=0x%08x, choice=%d, storeNo=%u, tStartTime=%u \n", 
        updateRecordData.recordOAD.logicId, updateRecordData.recordOAD.optional, updateRecordData.recordOAD.road.oadCols.nNum, 
        updateRecordData.recordOAD.road.oadCols.oad[0].value, updateRecordData.filter.choice, updateRecordData.filter.storeNo, 
        gEventCommInfo.tStartTime);

    if(0 == gEventCommInfo.tStartTime)
    {
        return -1;
    }

    MagneticEffectEvent.nIndex = gEventCommInfo.recordnum;  //事件记录序号
    MagneticEffectEvent.tmStart = gEventCommInfo.starttime;  //事件发生时间
    MagneticEffectEvent.tmEnd = gEventCommInfo.endtime;  //事件结束时间

    ACDB_FMT_DEBUG("MagneticEffectEvent信息: nIndex=%d; tmStart %u-%u-%u %u:%u:%u, week %u; tmEnd %u-%u-%u %u:%u:%u, week %u\n", 
        MagneticEffectEvent.nIndex, 
        MagneticEffectEvent.tmStart.year,
        MagneticEffectEvent.tmStart.month, MagneticEffectEvent.tmStart.day, MagneticEffectEvent.tmStart.hour,
        MagneticEffectEvent.tmStart.minute, MagneticEffectEvent.tmStart.second, MagneticEffectEvent.tmStart.week, 
        MagneticEffectEvent.tmStart.year,
        MagneticEffectEvent.tmStart.month, MagneticEffectEvent.tmStart.day, MagneticEffectEvent.tmStart.hour,
        MagneticEffectEvent.tmStart.minute, MagneticEffectEvent.tmStart.second, MagneticEffectEvent.tmStart.week);

    //上报状态
    MagneticEffectEvent.state.nNum = g_tnmPort.nNum;
    for(i=0; i<g_tnmPort.nNum; i++)
    {
        MagneticEffectEvent.state.state[i].oad = g_tnmPort.port[i];
        MagneticEffectEvent.state.state[i].state = 0;
    }

    memcpy(updateRecordData.inDataBuf, &MagneticEffectEvent, sizeof(OOP_EVENT_T));
    updateRecordData.inDatalen = sizeof(OOP_EVENT_T);
    ACDB_BUF_DEBUG(updateRecordData.inDataBuf, sizeof(OOP_EVENT_T), "updateRecordData事件内容:");

    ret = db_update_record(gDataCenterClient, &updateRecordData);
    ACDB_FMT_DEBUG("事件更新结果 ret=%d \n", ret);

    //磁场干扰参数保存至私有文件
    ret = write_pdata_xram(gEventParaPath, (char *)&gEventCommInfo, 0, sizeof(EVENT_COMM_INFO));
    ACDB_FMT_DEBUG("SaveMagneticEventRecover() 保存磁场干扰事件参数 write_pdata_xram() ret=%d \n", ret);

    return 1;
}

/****************************************************************************
*名称： SaveTopoEventOccur
*功能：将拓扑识别事件发生存入数据中心(新增)
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int SaveTopoEventOccur()
{
    ACDB_FMT_DEBUG("SaveTopoEventOccur() 拓扑识别事件发生存入数据中心 start... \n");

    EVENT_COMM_INFO stEventCommInfo;  //事件信息
    WRITE_RECORD_T recInData;
    NOMAL_OAD_T nomalOAD;
    OOP_IdentifyResult_T TopoIdenEvent;  //拓扑识别结果事件单元
    uint16 recNum = 0;
    uint32 evtIndex = 0;
    int ret = -1;
    int i = 0;

    memset(&stEventCommInfo,0,sizeof(EVENT_COMM_INFO));
    memset(&recInData,0,sizeof(WRITE_RECORD_T));
    memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
    memset(&TopoIdenEvent,0,sizeof(OOP_IdentifyResult_T));

    stEventCommInfo.EffectState = 1;//事件发生

    stEventCommInfo.eventOAD.value = 0x3E030200;//拓扑识别结果事件
    time(&stEventCommInfo.tStartTime); /*获取time_t类型的当前时间*/
    systm_to_ooptm(stEventCommInfo.tStartTime, &stEventCommInfo.starttime);  //事件发生时间

    //step1: 存储事件
    recInData.recordOAD.logicId = 0;
    recInData.recordOAD.classtag = CLASS_DATA_EVENT;
    recInData.recordOAD.road.oadCols.nNum = 1;
    recInData.recordOAD.road.oadCols.oad[0] = stEventCommInfo.eventOAD;//拓扑识别结果事件
//    recInData.MAC = MAC;

    cur_abn_event_read(gDataCenterClient, recInData.recordOAD, recInData.MAC, &recNum, &evtIndex);
    stEventCommInfo.recordnum = evtIndex + 1;
    
    recInData.colStartTm = stEventCommInfo.tStartTime;//开始时间
    recInData.colEndTm = stEventCommInfo.tStartTime;//结束时间
    recInData.colStoreTm = stEventCommInfo.recordnum;  //存储时间为事件序号

    ACDB_FMT_DEBUG("recInData信息: logicId=%d, classtag=%d, nNum=%d, oad[0]=0x%08x, colStartTm=%u, colEndTm=%u, colStoreTm=%u \n", 
        recInData.recordOAD.logicId, recInData.recordOAD.classtag, recInData.recordOAD.road.oadCols.nNum, 
        recInData.recordOAD.road.oadCols.oad[0].value, recInData.colStartTm, recInData.colEndTm, recInData.colStoreTm);
    
    TopoIdenEvent.nIndex = stEventCommInfo.recordnum;  //事件记录序号
    TopoIdenEvent.tmStart = stEventCommInfo.starttime;  //事件发生时间
    memset(&TopoIdenEvent.tmEnd, 0x00, sizeof(OOP_DATETIME_S_T));  //事件结束时间

    //上报状态
    TopoIdenEvent.evtState.nNum = g_tnmPort.nNum;
    for(i=0; i<g_tnmPort.nNum; i++)
    {
        TopoIdenEvent.evtState.state[i].oad = g_tnmPort.port[i];
        TopoIdenEvent.evtState.state[i].state = 0;
    }

    //识别结果信息
    TopoIdenEvent.IdentifyInformations.Identifynum = 1;
    TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].Suctime = TermSharedData.TopoIdenResult.stIdenTime;//识别成功时间
    TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].signalphase = TermSharedData.TopoIdenResult.nPhase;//识别信号相位

    if(1 == gPriMeasurePara.SignalIdenType.SignalS1Flag)
    {
        TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].Signalstrength1 = 0 - TermSharedData.TopoIdenResult.nSignalS1;//识别信号强度1
    }
    else
    {
        TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].Signalstrength1 = TermSharedData.TopoIdenResult.nSignalS1;//识别信号强度1
    }

    if(1 == gPriMeasurePara.SignalIdenType.SignalS2Flag)
    {
        TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].Signalstrength2 = 0 - TermSharedData.TopoIdenResult.nSignalS2;//识别信号强度2
    }
    else
    {
        TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].Signalstrength2 = TermSharedData.TopoIdenResult.nSignalS2;//识别信号强度2
    }

    if(1 == gPriMeasurePara.SignalIdenType.NoiseFlag)
    {
        TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].BackgroundNoise = 0 - TermSharedData.TopoIdenResult.nPhase;//背景噪声
    }
    else
    {
        TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].BackgroundNoise = TermSharedData.TopoIdenResult.nPhase;//背景噪声
    }
    
    memcpy(&TopoIdenEvent.IdentifyInformations.IdentifyInformation[0].Signatureinformation.nValue[0], &TermSharedData.TopoIdenResult.aInfo[0], 2);//特征码信息

    memcpy(recInData.inDataBuf, &TopoIdenEvent, sizeof(OOP_IdentifyResult_T));
    recInData.inDatalen = sizeof(OOP_IdentifyResult_T);
    ACDB_BUF_DEBUG(recInData.inDataBuf, sizeof(OOP_IdentifyResult_T), "recInData事件内容:");
    
    ret = db_write_record(gDataCenterClient, &recInData, &stEventCommInfo.storagenum);
    ACDB_FMT_DEBUG("db_write_record() 事件存储返回结果 ret=%d, storagenum=%u \n", ret, stEventCommInfo.storagenum);
    if (ret != ERR_OK)
    {
        ACDB_FMT_DEBUG("db_write_record() 事件存储失败! ret=%d \n", ret);
        return -1;
    }
    else
    {
        //step2: 事件记录条数
        stEventCommInfo.eventNum = recNum + 1;
        
        memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
        nomalOAD.logicId = 0;
        nomalOAD.oad.value = Uint16To32(stEventCommInfo.eventOAD.nObjID, 0X0400);
        nomalOAD.classtag = CLASS_DATA_EVENT;
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8 *)&stEventCommInfo.eventNum, 2);
        ACDB_FMT_DEBUG("事件记录条数 db_write_nomal() logicId=%d, oad=0x%08x, classtag=%d, eventNum=%d, ret = %d\n", 
            nomalOAD.logicId, nomalOAD.oad.value, nomalOAD.classtag, stEventCommInfo.eventNum, ret);


        //step3: 事件当前值记录
        stEventCommInfo.eventState.dwCount = stEventCommInfo.eventNum;
        stEventCommInfo.eventState.dbIdx = stEventCommInfo.recordnum;
        stEventCommInfo.eventState.tmStart = stEventCommInfo.tStartTime;

        memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
        nomalOAD.logicId = 0;
        nomalOAD.oad.value = Uint16To32(stEventCommInfo.eventOAD.nObjID, 0X0700);
        nomalOAD.classtag = CLASS_DATA_EVENT;
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8 *)&stEventCommInfo.eventState, sizeof(EVTSTATE));
        ACDB_FMT_DEBUG("事件当前值记录 db_write_nomal() logicId=%d, oad=0x%08x, classtag=%d, dwCount=%u, dbIdx=%u, tmStart=%u, ret = %d\n", 
            nomalOAD.logicId, nomalOAD.oad.value, nomalOAD.classtag, stEventCommInfo.eventState.dwCount, stEventCommInfo.eventState.dbIdx, 
            stEventCommInfo.eventState.tmStart, ret);


        //step4: 事件时间状态记录
        stEventCommInfo.eventTime.dbIdx = stEventCommInfo.recordnum;
        stEventCommInfo.eventTime.tmStart = stEventCommInfo.starttime;

        memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
        nomalOAD.logicId = 0;
        nomalOAD.oad.value = Uint16To32(stEventCommInfo.eventOAD.nObjID, 0X0A00);
        nomalOAD.classtag = CLASS_DATA_EVENT;
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8 *)&stEventCommInfo.eventTime, sizeof(EVTTIME));
        ACDB_FMT_DEBUG("事件时间状态记录 db_write_nomal() logicId=%d, oad=0x%08x, classtag=%d, dbIdx=%u, %u-%u-%u %u:%u:%u, week %u, ret=%d\n", 
            nomalOAD.logicId, nomalOAD.oad.value, nomalOAD.classtag, stEventCommInfo.eventState.dbIdx, stEventCommInfo.eventTime.tmStart.year,
            stEventCommInfo.eventTime.tmStart.month, stEventCommInfo.eventTime.tmStart.day, stEventCommInfo.eventTime.tmStart.hour,
            stEventCommInfo.eventTime.tmStart.minute, stEventCommInfo.eventTime.tmStart.second, stEventCommInfo.eventTime.tmStart.week, ret);
    }

    ACDB_FMT_DEBUG("SaveTopoEventOccur() 拓扑识别事件发生存入数据中心 end... \n");
    return 1;
}

/****************************************************************************
*名称： SaveTopoResultRecord
*功能：将拓扑识别信息结果存入数据中心(新增)
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int SaveTopoResultRecord()
{
    //array 一个拓扑关系识别信息
    Oop_Identify_Result IdentifyInformations;
    memset(&IdentifyInformations, 0, sizeof(Oop_Identify_Result));
    
    //一个拓扑关系识别信息
    Circuit_Breaker_Identify_Result IdentifyInformation;
    memset(&IdentifyInformation, 0, sizeof(Circuit_Breaker_Identify_Result));

    int ret;
    uint32 storeNo=0;
    WRITE_RECORD_T WriteRecord;
    memset(&WriteRecord, 0, sizeof(WRITE_RECORD_T));
    NOMAL_OAD_T NomalOad;
    memset(&NomalOad, 0, sizeof(NOMAL_OAD_T));
    uint32 OadValue = 0x4E070200;//台区拓扑关系识别

    /* step1 组织结构体内容 */
    IdentifyInformation.Suctime = TermSharedData.TopoIdenResult.stIdenTime;//识别成功时间
    IdentifyInformation.signalphase = TermSharedData.TopoIdenResult.nPhase;//识别信号相位

    if(1 == gPriMeasurePara.SignalIdenType.SignalS1Flag)
        IdentifyInformation.Signalstrength1 = 0 - TermSharedData.TopoIdenResult.nSignalS1;//识别信号强度1
    else
        IdentifyInformation.Signalstrength1 = TermSharedData.TopoIdenResult.nSignalS1;//识别信号强度1

    if(1 == gPriMeasurePara.SignalIdenType.SignalS2Flag)
        IdentifyInformation.Signalstrength2 = 0 - TermSharedData.TopoIdenResult.nSignalS2;//识别信号强度2
    else
        IdentifyInformation.Signalstrength2 = TermSharedData.TopoIdenResult.nSignalS2;//识别信号强度2

    if(1 == gPriMeasurePara.SignalIdenType.NoiseFlag)
        IdentifyInformation.BackgroundNoise = 0 - TermSharedData.TopoIdenResult.nPhase;//背景噪声
    else
        IdentifyInformation.BackgroundNoise = TermSharedData.TopoIdenResult.nPhase;//背景噪声
    
    memcpy(&IdentifyInformation.Signatureinformation.nValue[0], &TermSharedData.TopoIdenResult.aInfo[0], 2);//特征码信息

    IdentifyInformation.Extendedinformation.nNum = 12;//扩展信息12个字节, 默认为0

    //汇总
    IdentifyInformations.Identifynum = 1;//只有一条拓扑识别信息
    memcpy(&IdentifyInformations.IdentifyInformation[0], &IdentifyInformation, sizeof(Circuit_Breaker_Identify_Result));
    ACDB_FMT_DEBUG("Identifynum=%d, signalphase=%d \n", 
            IdentifyInformations.Identifynum, IdentifyInformations.IdentifyInformation[0].signalphase);

    /* step2 存储记录型数据 */
    WriteRecord.recordOAD.logicId = 0;
    WriteRecord.recordOAD.infoNum = 0;
    WriteRecord.recordOAD.road.oadMain.value = 0;
    WriteRecord.recordOAD.road.oadCols.nNum = 1;
    WriteRecord.recordOAD.road.oadCols.oad[0].value = OadValue;
    WriteRecord.recordOAD.classtag = CLASS_DATA_COLLEC;
    
    WriteRecord.MAC.nNum = 6;
//    WriteRecord.MAC = MAC;

    WriteRecord.colStartTm = time(NULL);
    WriteRecord.colStoreTm = time(NULL);
    WriteRecord.colEndTm = time(NULL);

    WriteRecord.inDatalen = sizeof(IdentifyInformations);
    memcpy(WriteRecord.inDataBuf, &IdentifyInformations, sizeof(IdentifyInformations));
    ret = db_write_record(gDataCenterClient, &WriteRecord, &storeNo);
    
    ACDB_FMT_DEBUG("Identifynum=%d, signalphase=%d \n", 
                IdentifyInformations.Identifynum, IdentifyInformations.IdentifyInformation[0].signalphase);
    ACDB_FMT_DEBUG("SaveTopoResultRecord() record: ret=%d, oad=%08x, storeNo=%u \n", ret, OadValue, storeNo);

    /* step3 存储普通型数据 */
    NomalOad.logicId = 0;  //逻辑地址
    NomalOad.infoNum = 0;  //信息点
    NomalOad.oad.value = OadValue;  //普通OAD
    NomalOad.classtag = CLASS_DATA_NORMAL;
    ret = db_write_nomal(gDataCenterClient, &NomalOad, (uint8*)&IdentifyInformations, sizeof(IdentifyInformations));
    
    ACDB_FMT_DEBUG("Identifynum=%d, signalphase=%d \n", 
                IdentifyInformations.Identifynum, IdentifyInformations.IdentifyInformation[0].signalphase);
    ACDB_FMT_DEBUG("SaveTopoResultRecord() nomal: ret:%d, oad=%08x \n", ret, OadValue);

    /* step4 存储普通型数据(供主站读取识别结果) */
    OadValue = 0x4E080200;//一个拓扑关系识别信息
    NomalOad.logicId = 0;  //逻辑地址
    gAcTopoEventNum++;
    if(gAcTopoEventNum > AC_TOPO_EVENT_NUM_MAX)
    {
        gAcTopoEventNum = 1;
    }
    NomalOad.infoNum = gAcTopoEventNum;  //信息点
    NomalOad.oad.value = OadValue;  //普通OAD
    NomalOad.classtag = CLASS_DATA_NORMAL;
    ret = db_write_nomal(gDataCenterClient, &NomalOad, (uint8*)&IdentifyInformation, sizeof(IdentifyInformation));
    
    ACDB_FMT_DEBUG("signalphase=%d \n", IdentifyInformation.signalphase);
    ACDB_FMT_DEBUG("SaveTopoResultRecord() nomal: ret:%d, oad=%08x \n", ret, OadValue);
    
    return 1;
}

int GetEventNumAndIndex(int clientid, uint32 eventOAD, uint16* nEventNum, uint32* nIndex)
{
    READ_RECORD_T startReadRecord;
    STEP_READ_RECORD_T stepReadRecord;
    RECORD_UNIT_T stepRecordOut;
    OOP_EVENT_T *pTemp = NULL;
    uint32 handle = 0;
    uint32 recNum = 0;
    int  ret = 0;
    time_t timep;
    memset(&startReadRecord,0,sizeof(READ_RECORD_T));
    memset(&stepReadRecord,0,sizeof(STEP_READ_RECORD_T));
    memset(&stepRecordOut,0,sizeof(RECORD_UNIT_T));
    time(&timep); //获取从1970至今过了多少秒，存入time_t类型的timep
    timep += COMPENSATION_TIME;
    startReadRecord.recordOAD.logicId = 1;
    startReadRecord.recordOAD.road.oadMain.value = 0;
    startReadRecord.recordOAD.road.oadCols.nNum = 1;
    startReadRecord.recordOAD.road.oadCols.oad[0].value = eventOAD;
    startReadRecord.recordOAD.logicId = 1;
    startReadRecord.recordOAD.infoNum = 0;
    startReadRecord.cType = 0x02;
    startReadRecord.cStart = 0;
    startReadRecord.cEnd = timep;
    startReadRecord.sortType = 0x01;
    ret = db_read_record_start(clientid, &startReadRecord, &handle, &recNum);
    if (ret != ERR_OK)
    {
        EVENT_FMT_DEBUG("db_read_record_start, OAD=%8X error ret %d\n", eventOAD, ret);
        return ret;
    }
    *nEventNum = (uint16)recNum;
    if(recNum == 0)
    {
        db_read_record_end(clientid, handle);
        return ERR_OK;
    }
    stepReadRecord.MAC = MAC;
    ret = db_read_record_step(clientid, handle, &stepReadRecord, &stepRecordOut);   
    db_read_record_end(clientid, handle);
    if (ret != ERR_OK)
    {
        EVENT_FMT_DEBUG("db_read_record_step, OAD=%8X error ret %d\n", eventOAD, ret);
        return ret;
    }
    else
    {
        pTemp = (OOP_EVENT_T *)stepRecordOut.record[0].outDataBuf;
        *nIndex = pTemp->nIndex;
    }
    return ERR_OK;
}
int evt_get_oop_struct_data(mtrnum_t mtr_id, EVENT_COMM_INFO *eventCommInfo, OOP_EVTSOURCE_T eventSource, OOP_EVTBUF_T eventData, uint32 max_len, uint8 *pout_buf, uint8 bType)
{
    int                 out_len = 0;
    OOP_EVENT_T         oopEvent;        //标准事件单元
    memset(&oopEvent,0,sizeof(OOP_EVENT_T));
    oopEvent.source = eventSource;
    oopEvent.data = eventData;
    if(bType <= 1)
    {
        current_tm_to_ooptm(&oopEvent.tmStart);
        oopEvent.nIndex = eventCommInfo->recordnum+1;
    }
    else if(bType == 2)
    {
        if(gTotalEventInfo.stEvent300F.tOccurTime == 0)
        {
            return 0;
        }
        systm_to_ooptm(gTotalEventInfo.stEvent300F.tOccurTime, &oopEvent.tmStart);
        current_tm_to_ooptm(&oopEvent.tmEnd);
        oopEvent.nIndex = eventCommInfo->recordnum;
    }
    if(bType == 0)
    {
        oopEvent.tmEnd = oopEvent.tmStart;
    }
    switch(eventCommInfo->eventOAD.value)
    {
        case 0X3E030200:            //拓扑识别事件
        {
            break;
        }
        default:                    //标准事件单元
        {
            out_len = sizeof(OOP_EVENT_T);
            if(out_len <= max_len)
            {
                memcpy(pout_buf, &oopEvent, out_len);
            }
        }
    }
    if(out_len > max_len)
    {
        ACDB_FMT_TRACE("evt_get_writedb_record_data oda[%08X],out_len[%d]>max_len[%u]\n", eventCommInfo->eventOAD.value, out_len, max_len);
        return 0;
    }
    return out_len;
}
int evt_db_write(DB_CLIENT fd, EVENT_COMM_INFO *eventCommInfo, uint8 *pevt_data, uint32 data_len, OOP_REPORTS_T state)
{  
    time_t              timep = 0;
    WRITE_RECORD_T      recInData;   
    memset(&recInData,0,sizeof(WRITE_RECORD_T));
    time(&timep); /*获取time_t类型的当前时间*/
    recInData.recordOAD.logicId = 1;
    recInData.recordOAD.classtag = CLASS_DATA_EVENT;
    recInData.recordOAD.road.oadCols.nNum = 1;
    recInData.recordOAD.road.oadCols.oad[0] = eventCommInfo->eventOAD;
//    recInData.MAC = MAC;
    recInData.colStartTm = timep + COMPENSATION_TIME;
    recInData.colEndTm = timep + COMPENSATION_TIME;
    recInData.colStoreTm = eventCommInfo->recordnum+1;
    recInData.inDatalen = data_len;
    memcpy(recInData.inDataBuf, pevt_data, data_len);
    return db_write_record(fd, &recInData, &eventCommInfo->storagenum);
}
int evt_db_update(DB_CLIENT fd, OOP_OAD_U evt_oad, uint32 storagenum, uint8 *pevt_data, uint32 data_len, OOP_REPORTS_T state)
{  
    UPDATE_RECORD_T     updateRecordData;
    memset(&updateRecordData,0,sizeof(UPDATE_RECORD_T));
    updateRecordData.recordOAD.optional = 0;
    updateRecordData.recordOAD.logicId = 1;
    updateRecordData.recordOAD.road.oadCols.nNum = 1;
    updateRecordData.recordOAD.road.oadCols.oad[0] = evt_oad;
//    updateRecordData.MAC = MAC;
    updateRecordData.filter.choice = 2;
    updateRecordData.inDatalen = data_len;
    updateRecordData.filter.storeNo = storagenum;
    memcpy(updateRecordData.inDataBuf, pevt_data, data_len);
    return db_update_record(fd, &updateRecordData);
}
int SetEventNum(DB_CLIENT fd, EVENT_COMM_INFO *eventCommInfo)
{
    int             ret     = -1;
    NOMAL_OAD_T     nomalOAD;
    memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
    eventCommInfo->eventNum++;
    nomalOAD.oad.value = Uint16To32(eventCommInfo->eventOAD.nObjID, 0X0400);
    nomalOAD.logicId = 1;
    nomalOAD.classtag = CLASS_DATA_EVENT;
    ret = db_write_nomal(fd, &nomalOAD, (uint8 *)&eventCommInfo->eventNum, 2);
    if (ret != ERR_OK)
    {
        ACDB_FMT_TRACE("db_write_nomal oad[%08X]记录事件条数=%d失败返回%d\n", nomalOAD.oad.value, eventCommInfo->eventNum, ret);
    }
    ACDB_FMT_TRACE("db_write_nomal oad[%08X]记录事件条数=%d成功\n", nomalOAD.oad.value, eventCommInfo->eventNum);
    return ret;
}
int SetEventStat(DB_CLIENT fd, mtrnum_t mtr_id, EVENT_COMM_INFO *eventCommInfo, OOP_EVTSOURCE_T eventSource, uint8 bType)
{
    int             ret     = -1;
    uint32          time    = 0;
    NOMAL_OAD_T     nomalOAD;
    memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
    eventCommInfo->eventState.source = eventSource;
    eventCommInfo->eventState.dwCount = eventCommInfo->eventNum;
    eventCommInfo->eventState.dbIdx = eventCommInfo->storagenum;
    if(bType == 2)
    {   
        ooptm_to_systm(eventCommInfo->endtime, (time_t *)&time);
        eventCommInfo->eventState.dwTimes += time - eventCommInfo->eventState.tmStart;
    }
    else
    {
        ooptm_to_systm(eventCommInfo->starttime, (time_t *)&time);
        eventCommInfo->eventState.tmStart = time;
    }
    nomalOAD.oad.value = Uint16To32(eventCommInfo->eventOAD.nObjID, 0X0700);
    nomalOAD.logicId = 1;
    nomalOAD.classtag = CLASS_DATA_EVENT;
    ret = db_write_nomal(fd, &nomalOAD, (uint8 *)&eventCommInfo->eventState, sizeof(EVTSTATE));
    if (ret != ERR_OK)
    {
        ACDB_FMT_TRACE("db_write_nomal oad[%08X]记录事件当前值失败 返回%d\n", nomalOAD.oad.value, ret);
    }
    return ret;
}
int SetEventTime(DB_CLIENT fd, mtrnum_t mtr_id, EVENT_COMM_INFO *eventCommInfo, OOP_EVTSOURCE_T eventSource, uint8 bType)
{
    int             ret     = -1;
    NOMAL_OAD_T     nomalOAD;
    memset(&nomalOAD,0,sizeof(NOMAL_OAD_T));
    eventCommInfo->eventTime.source = eventSource;
    eventCommInfo->eventTime.dbIdx = eventCommInfo->storagenum;
    if(bType == 2)
    {   
        eventCommInfo->eventTime.tmEnd = eventCommInfo->endtime;
    }
    else
    {
        eventCommInfo->eventTime.tmStart = eventCommInfo->starttime;
    }
    nomalOAD.oad.value = Uint16To32(eventCommInfo->eventOAD.nObjID, 0X0A00);
    nomalOAD.logicId = 1;
    nomalOAD.classtag = CLASS_DATA_EVENT;
    ret = db_write_nomal(fd, &nomalOAD, (uint8 *)&eventCommInfo->eventTime, sizeof(EVTTIME));
    if (ret != ERR_OK)
    {
        ACDB_FMT_TRACE("db_write_nomal oad[%08X]记录事件时间状态失败 返回%d\n", nomalOAD.oad.value, ret);
    }
    return ret;
}
int WriteEventToDB(DB_CLIENT fd, mtrnum_t mtr_id, EVENT_COMM_INFO *eventCommInfo, OOP_EVTSOURCE_T eventSource, OOP_EVTBUF_T eventData, uint8 bType)
{ 
    int                 ret                    = 0;
    uint8               bDatabuf[DATA_LEN_MAX] = {0};
    uint32              bufLen                 = 0;
    OOP_REPORTS_T       state;//上报状态
    memset(&state,0,sizeof(OOP_REPORTS_T));
    if(eventCommInfo->recordnum == 0)
    {
        GetEventNumAndIndex(fd, eventCommInfo->eventOAD.value, &eventCommInfo->eventNum, &eventCommInfo->recordnum);
    }
    bufLen = evt_get_oop_struct_data(mtr_id, eventCommInfo, eventSource, eventData, DATA_LEN_MAX, bDatabuf, bType);
    if(bufLen == 0)
    {
        return ERR_O_RANGE;
    }
    if(bType <= 1)//发生
    {
        ret = evt_db_write(fd, eventCommInfo, bDatabuf, bufLen, state);
        if (ret != ERR_OK)
        {
            return ret;
        }
        SetEventNum(fd,eventCommInfo);
        SetEventStat(fd,mtr_id, eventCommInfo, eventSource, bType);
        SetEventTime(fd,mtr_id, eventCommInfo, eventSource, bType);
        eventCommInfo->recordnum++;
    }
    else if(bType == 2)
    {
        ret = evt_db_update(fd, eventCommInfo->eventOAD, eventCommInfo->storagenum, bDatabuf, bufLen, state);
        if (ret != ERR_OK)
        {
            return ret;
        }
    }
    return ERR_OK;
}
int CheckEvent300F()
{
    if(0 == gTotalEventInfo.stEvent300F.nState && 0 == MidTermSharedData.MetStusPara.Rsw7.BitSect.VoltConvFlag)
    {
        gTotalEventInfo.stEvent300F.tRecovTime = time(NULL);
        return -1;
    }
    else if(1 == gTotalEventInfo.stEvent300F.nState && 1 == MidTermSharedData.MetStusPara.Rsw7.BitSect.VoltConvFlag)
    {
        gTotalEventInfo.stEvent300F.tOccurTime = time(NULL);
        return -1;
    }
    OOP_EVTSOURCE_T eventSource; //事件发生源
    OOP_EVTBUF_T    eventData;   //事件关联数据
    NOMAL_OAD_T     NomalOad;
    int ret = 0;
    memset(&eventSource,0,sizeof(OOP_EVTSOURCE_T));
    memset(&eventData,0,sizeof(OOP_EVTBUF_T));
    memset(&NomalOad,0,sizeof(NOMAL_OAD_T));
    uint8   aRecvBuff[MAX_DB_R_W_LEN] = {0};
    uint32  nRevcBuffLen = 0;
    uint32   VoltLimit = 0;                       //电压限值(.XXXX V)
    uint32   StdVoltValue = 2200;                 //额定电压 单位0.1V
    uint8    OperType = 0;                        //事件类型 0无事件 1发生 2恢复
    ACDB_FMT_TRACE("CheckEvent300F start!\n");
    NomalOad.logicId = 1;  //逻辑地址
    NomalOad.infoNum = 0;  //信息点
    NomalOad.classtag = CLASS_DATA_NORMAL;  //普通数据类型
    NomalOad.oad.value = 0x300f0900;  //普通OAD
    ret = db_read_nomal(gDataCenterClient, &NomalOad, sizeof(aRecvBuff), (uint8*)aRecvBuff, &nRevcBuffLen);
    ACDB_FMT_TRACE("db_read_nomal() ret:%d, NomalOad.oad=%08x \n", ret, NomalOad.oad);
    if(ret == 0)
    {
        memcpy(&event_300F.eventCommInfo.checkflag, aRecvBuff, 1);
        ACDB_FMT_TRACE("event_300F.eventCommInfo.checkflag=%d \n", event_300F.eventCommInfo.checkflag);
        if(event_300F.eventCommInfo.checkflag == 0)
        {
            return -2;
        }
    }
    else
    {
        return -3;
    }
    VoltLimit = StdVoltValue * 0.6;
    OOP_WORD3V_T Voltage;
    memset((uint8*)&Voltage,0x00,sizeof(OOP_WORD3V_T));
    Voltage.nNum = 3;
    Voltage.rsv = 0;
    Voltage.nValue[0] = MidTermSharedData.PhaAVolt;
    Voltage.nValue[1] = MidTermSharedData.PhaBVolt;
    Voltage.nValue[2] = MidTermSharedData.PhaCVolt;
    event_300F.valTemp = Voltage;
    ACDB_FMT_TRACE("evt_check_300F 电压限值VoltLimit=%u A、B、C相电压:%u,%u,%u, VoltConvFlag=%d \n", VoltLimit, event_300F.valTemp.nValue[0], event_300F.valTemp.nValue[1],event_300F.valTemp.nValue[2], 
        MidTermSharedData.MetStusPara.Rsw7.BitSect.VoltConvFlag);
    if ((event_300F.valTemp.nValue[0] > VoltLimit)
        && (event_300F.valTemp.nValue[1] > VoltLimit)
        && (event_300F.valTemp.nValue[2] > VoltLimit))
    {
        NomalOad.oad.value = 0x300f0600;  //普通OAD
        ret = db_read_nomal(gDataCenterClient, &NomalOad, sizeof(aRecvBuff), (uint8*)aRecvBuff, &nRevcBuffLen);
        ACDB_FMT_TRACE("db_read_nomal() ret:%d, NomalOad.oad=%08x \n", ret, NomalOad.oad);
        if(ret == 0)
        {
            memcpy(&event_300F.nDelay, aRecvBuff, 1);
            ACDB_FMT_TRACE("event_300F.nDelay=%d \n", event_300F.nDelay);
        }
        else
        {
            return -4;
        }
        if(0 == gTotalEventInfo.stEvent300F.nState && 1 == MidTermSharedData.MetStusPara.Rsw7.BitSect.VoltConvFlag)
        {
            if( abs(time(NULL) - gTotalEventInfo.stEvent300F.tRecovTime) >= event_300F.nDelay)
            {
                OperType = 1;//发生
                gTotalEventInfo.stEvent300F.nState = 1;
                gTotalEventInfo.stEvent300F.tOccurTime = time(NULL);
                ACDB_FMT_TRACE("电压逆向序事件产生! OperType=%d \n", OperType);
            }
        }
        else if(1 == gTotalEventInfo.stEvent300F.nState && 0 == MidTermSharedData.MetStusPara.Rsw7.BitSect.VoltConvFlag)
        {
            if( abs(time(NULL) - gTotalEventInfo.stEvent300F.tOccurTime) >= event_300F.nDelay)
            {
                OperType = 2;//恢复
                gTotalEventInfo.stEvent300F.nState = 0;
                gTotalEventInfo.stEvent300F.tRecovTime = time(NULL);
                ACDB_FMT_TRACE("电压逆向序事件恢复! OperType=%d \n", OperType);
            }
        }
    }
    else
    {
        ACDB_FMT_TRACE("evt_check_300F 电压异常 电压限值VoltLimit=%u A、B、C相电压:%u,%u,%u!\n", VoltLimit, event_300F.valTemp.nValue[0], event_300F.valTemp.nValue[1],event_300F.valTemp.nValue[2]);
        return -4;
    }
    if(0 == OperType)
    {
        return -5;
    }
    eventSource.choice = DT_NULL;
    eventData.oadNum = 32;
    eventData.cols.nNum = 32;
    eventData.cols.oad[0].value = 0X00102201;
    eventData.cols.oad[1].value = 0X00202201;
    eventData.cols.oad[2].value = 0X00302201;
    eventData.cols.oad[3].value = 0X00402201;
    eventData.idLen[0] = sizeof(uint32);
    eventData.idLen[1] = sizeof(uint32);
    eventData.idLen[2] = sizeof(int);
    eventData.idLen[3] = sizeof(int);
    eventData.cols.oad[4].value = 0X00112201;
    eventData.cols.oad[5].value = 0X00212201;
    eventData.cols.oad[6].value = 0X00312201;
    eventData.cols.oad[7].value = 0X00412201;
    eventData.idLen[4] = sizeof(uint32);
    eventData.idLen[5] = sizeof(uint32);
    eventData.idLen[6] = sizeof(int);
    eventData.idLen[7] = sizeof(int);
    eventData.cols.oad[8].value = 0X00122201;
    eventData.cols.oad[9].value = 0X00222201;
    eventData.cols.oad[10].value = 0X00322201;
    eventData.cols.oad[11].value = 0X00422201;
    eventData.idLen[8] = sizeof(uint32);
    eventData.idLen[9] = sizeof(uint32);
    eventData.idLen[10] = sizeof(int);
    eventData.idLen[11] = sizeof(int);
    eventData.cols.oad[12].value = 0X00132201;
    eventData.cols.oad[13].value = 0X00232201;
    eventData.cols.oad[14].value = 0X00332201;
    eventData.cols.oad[15].value = 0X00432201;
    eventData.idLen[12] = sizeof(uint32);
    eventData.idLen[13] = sizeof(uint32);
    eventData.idLen[14] = sizeof(int);
    eventData.idLen[15] = sizeof(int);
    eventData.cols.oad[16].value = 0X00108201;
    eventData.cols.oad[17].value = 0X00208201;
    eventData.cols.oad[18].value = 0X00308201;
    eventData.cols.oad[19].value = 0X00408201;
    eventData.idLen[16] = sizeof(uint32);
    eventData.idLen[17] = sizeof(uint32);
    eventData.idLen[18] = sizeof(int);
    eventData.idLen[19] = sizeof(int);
    eventData.cols.oad[20].value = 0X00118201;
    eventData.cols.oad[21].value = 0X00218201;
    eventData.cols.oad[22].value = 0X00318201;
    eventData.cols.oad[23].value = 0X00418201;
    eventData.idLen[20] = sizeof(uint32);
    eventData.idLen[21] = sizeof(uint32);
    eventData.idLen[22] = sizeof(int);
    eventData.idLen[23] = sizeof(int);
    eventData.cols.oad[24].value = 0X00128201;
    eventData.cols.oad[25].value = 0X00228201;
    eventData.cols.oad[26].value = 0X00328201;
    eventData.cols.oad[27].value = 0X00428201;
    eventData.idLen[24] = sizeof(uint32);
    eventData.idLen[25] = sizeof(uint32);
    eventData.idLen[26] = sizeof(int);
    eventData.idLen[27] = sizeof(int);
    eventData.cols.oad[28].value = 0X00138201;
    eventData.cols.oad[29].value = 0X00238201;
    eventData.cols.oad[30].value = 0X00338201;
    eventData.cols.oad[31].value = 0X00438201;
    eventData.idLen[28] = sizeof(uint32);
    eventData.idLen[29] = sizeof(uint32);
    eventData.idLen[30] = sizeof(int);
    eventData.idLen[31] = sizeof(int);
    eventData.len = 4*32;
    InitEventPara();
    if(OperType == 1)
    {
        ret = WriteEventToDB(gDataCenterClient, 0, &event_300F.eventCommInfo, eventSource, eventData, 1);
        if (ret < ERR_OK)
        {
            ACDB_FMT_TRACE("evt_check_300F 终端相序异常事件记录失败返回%d\n", ret);
        }
        else
            ACDB_FMT_TRACE("evt_check_300F 终端相序异常事件 记录成功, storagenum=%u !\n", event_300F.eventCommInfo.storagenum);
    }
    else
    { 
        ret = WriteEventToDB(gDataCenterClient, 0, &event_300F.eventCommInfo, eventSource, eventData, 2);
        if (ret < ERR_OK)
        {
            ACDB_FMT_TRACE("evt_check_300F 终端相序异常恢复事件 记录失败返回%d\n", ret);
        }
        else
            ACDB_FMT_TRACE("evt_check_300F 终端相序异常恢复事件 记录成功, storagenum=%u !\n", event_300F.eventCommInfo.storagenum);
    }
    return ret;
}
/****************************************************************************
*模块编号：
*名称：SynReportedInfoToHis
*功能：将存入数据中心的数据同步至历史数据，作为下次比较基准
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int SynReportedInfoToHis(const Map645ToOop_NEW *pOadInfo)
{
    int 	i	 = 0;
    uint16	nNum = 0;
    uint32	nOAD = 0;

    nOAD = pOadInfo->Oad.value;
    
    switch(nOAD)
    {
        case 0x00100200:						//(当前)正向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PosActEng[i].ULinteger = MidTermSharedData.PosActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePosActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向有功电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00200200:						//(当前)反向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.NegActEng[i].ULinteger = MidTermSharedData.NegActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateNegActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向有功电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00300200:						//(当前)正向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PosReaEnergyType[i] = gMidPriMeasurePara.PosReaEnergyType[i];
                HisTermSharedData.PosReaEng[i].ULinteger = MidTermSharedData.PosReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePosReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向无功电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00400200:						//(当前)反向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.NegReaEnergyType[i] = gMidPriMeasurePara.NegReaEnergyType[i];
                HisTermSharedData.NegReaEng[i].ULinteger = MidTermSharedData.NegReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateNegReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向无功电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00500200:						//(当前)第一象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad1ReaEng[i].ULinteger = MidTermSharedData.Quad1ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad1ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第一象限无功总尖峰平谷电能示值! \n", nOAD, i);
        }
            break;

        case 0x00600200:						//(当前)第二象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad2ReaEng[i].ULinteger = MidTermSharedData.Quad2ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad2ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第二象限无功总尖峰平谷电能示值! \n", nOAD, i);
        }
            break;

        case 0x00700200:						//(当前)第三象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad3ReaEng[i].ULinteger = MidTermSharedData.Quad3ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad3ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第三象限无功总尖峰平谷电能示值! \n", nOAD, i);
        }
            break;

        case 0x00800200:						//(当前)第四象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad4ReaEng[i].ULinteger = MidTermSharedData.Quad4ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad4ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第四象限无功总尖峰平谷电能示值! \n", nOAD, i);
        }
            break;

        case 0x00010200:                        //(A相)组合有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                HisTermSharedData.PhaACmbActEng[i].ULinteger = MidTermSharedData.PhaACmbActEng[i].ULinteger;
            }
        }
            break;

        case 0x00110200:						//(A相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaAPosActEng[i].ULinteger = MidTermSharedData.PhaAPosActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaAPosActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)正向有功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00210200:						//(A相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaANegActEng[i].ULinteger = MidTermSharedData.PhaANegActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaANegActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)反向有功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00310200:						//(A相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaAPosReaEngType[i] = gMidPriMeasurePara.PhaAPosReaEngType[i];
                HisTermSharedData.PhaAPosReaEng[i].ULinteger = MidTermSharedData.PhaAPosReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaAPosReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)正向无功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00410200:						//(A相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaANegReaEngType[i] = gMidPriMeasurePara.PhaANegReaEngType[i];
                HisTermSharedData.PhaANegReaEng[i].ULinteger = MidTermSharedData.PhaANegReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaANegReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)反向无功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00020200:                        //(B相)组合有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                HisTermSharedData.PhaBCmbActEng[i].ULinteger = MidTermSharedData.PhaBCmbActEng[i].ULinteger;
            }
        }
            break;

        case 0x00120200:						//(B相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBPosActEng[i].ULinteger = MidTermSharedData.PhaBPosActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBPosActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)正向有功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00220200:						//(B相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBNegActEng[i].ULinteger = MidTermSharedData.PhaBNegActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBNegActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)反向有功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00320200:						//(B相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaBPosReaEngType[i] = gMidPriMeasurePara.PhaBPosReaEngType[i];
                HisTermSharedData.PhaBPosReaEng[i].ULinteger = MidTermSharedData.PhaBPosReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBPosReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)正向无功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00420200:						//(B相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaBNegReaEngType[i] = gMidPriMeasurePara.PhaBNegReaEngType[i];
                HisTermSharedData.PhaBNegReaEng[i].ULinteger = MidTermSharedData.PhaBNegReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBNegReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)反向无功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00030200:                        //(C相)组合有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                HisTermSharedData.PhaCCmbActEng[i].ULinteger = MidTermSharedData.PhaCCmbActEng[i].ULinteger;
            }
        }
            break;

        case 0x00130200:						//(C相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCPosActEng[i].ULinteger = MidTermSharedData.PhaCPosActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCPosActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)正向有功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00230200:						//(C相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCNegActEng[i].ULinteger = MidTermSharedData.PhaCNegActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCNegActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)反向有功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00330200:						//(C相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaCPosReaEngType[i] = gMidPriMeasurePara.PhaCPosReaEngType[i];
                HisTermSharedData.PhaCPosReaEng[i].ULinteger = MidTermSharedData.PhaCPosReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCPosReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)正向无功总电能示值! \n", nOAD, i);
        }
            break;

        case 0x00430200:						//(C相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaCNegReaEngType[i] = gMidPriMeasurePara.PhaCNegReaEngType[i];
                HisTermSharedData.PhaCNegReaEng[i].ULinteger = MidTermSharedData.PhaCNegReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCNegReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)反向无功总电能示值! \n", nOAD, i);
        }
            break;


        /* 增加 电能 start*/
        case 0x00000200:						//(当前)组合有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.CmbEnergyType[i] = gMidPriMeasurePara.CmbEnergyType[i];
                HisTermSharedData.CmbActEng[i].ULinteger = MidTermSharedData.CmbActEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateCmbActEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (当前)组合有功电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00900200:						//(当前)正向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PosAppEng[i].ULinteger = MidTermSharedData.PosAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePosAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (当前)正向视在电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00A00200:						//(当前)反向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.NegAppEng[i].ULinteger = MidTermSharedData.NegAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdateNegAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (当前)反向视在电能总尖峰平谷示值! \n", nOAD, i);
        }
            break;

        case 0x00510200:						//A相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA1ReaEng[i].ULinteger = MidTermSharedData.PhaA1ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA1ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第一象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00520200:						//B相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB1ReaEng[i].ULinteger = MidTermSharedData.PhaB1ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB1ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第一象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00530200:						//C相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC1ReaEng[i].ULinteger = MidTermSharedData.PhaC1ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC1ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第一象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00610200:						//A相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA2ReaEng[i].ULinteger = MidTermSharedData.PhaA2ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA2ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第二象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00620200:						//B相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB2ReaEng[i].ULinteger = MidTermSharedData.PhaB2ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB2ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第二象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00630200:						//C相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC2ReaEng[i].ULinteger = MidTermSharedData.PhaC2ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC2ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第二象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00710200:						//A相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA3ReaEng[i].ULinteger = MidTermSharedData.PhaA3ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA3ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第三象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00720200:						//B相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB3ReaEng[i].ULinteger = MidTermSharedData.PhaB3ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB3ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第三象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00730200:						//C相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC3ReaEng[i].ULinteger = MidTermSharedData.PhaC3ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC3ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第三象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00810200:						//A相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA4ReaEng[i].ULinteger = MidTermSharedData.PhaA4ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA4ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第四象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00820200:						//B相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB4ReaEng[i].ULinteger = MidTermSharedData.PhaB4ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB4ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第四象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00830200:						//C相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC4ReaEng[i].ULinteger = MidTermSharedData.PhaC4ReaEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC4ReaEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第四象限无功电能! \n", nOAD, i);
        }
            break;

        case 0x00910200:						//A相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaAActAppEng[i].ULinteger = MidTermSharedData.PhaAActAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaAActAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相正向视在电能! \n", nOAD, i);
        }
            break;

        case 0x00920200:						//B相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBActAppEng[i].ULinteger = MidTermSharedData.PhaBActAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBActAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相正向视在电能! \n", nOAD, i);
        }
            break;

        case 0x00930200:						//C相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCActAppEng[i].ULinteger = MidTermSharedData.PhaCActAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCActAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相正向视在电能! \n", nOAD, i);
        }
            break;

        case 0x00A10200:						//A相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaANegAppEng[i].ULinteger = MidTermSharedData.PhaANegAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaANegAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相反向视在电能! \n", nOAD, i);
        }
            break;

        case 0x00A20200:						//B相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBNegAppEng[i].ULinteger = MidTermSharedData.PhaBNegAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBNegAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相反向视在电能! \n", nOAD, i);
        }
            break;

        case 0x00A30200:						//C相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCNegAppEng[i].ULinteger = MidTermSharedData.PhaCNegAppEng[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCNegAppEng = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相反向视在电能! \n", nOAD, i);
        }
            break;

        /* 增加 电能 end*/

        /***高精度 电能量 begin***/

        case 0x00100400:						//(当前)正向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PosActEngHD[i].ULinteger = MidTermSharedData.PosActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePosActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向有功电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00200400:						//(当前)反向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.NegActEngHD[i].ULinteger = MidTermSharedData.NegActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateNegActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向有功电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00300400:						//(当前)正向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PosReaEnergyTypeHD[i] = gMidPriMeasurePara.PosReaEnergyTypeHD[i];
                HisTermSharedData.PosReaEngHD[i].ULinteger = MidTermSharedData.PosReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePosReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向无功电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00400400:						//(当前)反向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.NegReaEnergyTypeHD[i] = gMidPriMeasurePara.NegReaEnergyTypeHD[i];
                HisTermSharedData.NegReaEngHD[i].ULinteger = MidTermSharedData.NegReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateNegReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向无功电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00500400:						//(当前)第一象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad1ReaEngHD[i].ULinteger = MidTermSharedData.Quad1ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad1ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第一象限无功总尖峰平谷电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00600400:						//(当前)第二象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad2ReaEngHD[i].ULinteger = MidTermSharedData.Quad2ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad2ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第二象限无功总尖峰平谷电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00700400:						//(当前)第三象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad3ReaEngHD[i].ULinteger = MidTermSharedData.Quad3ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad3ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第三象限无功总尖峰平谷电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00800400:						//(当前)第四象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.Quad4ReaEngHD[i].ULinteger = MidTermSharedData.Quad4ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateQuad4ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 第四象限无功总尖峰平谷电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00110400:						//(A相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaAPosActEngHD[i].ULinteger = MidTermSharedData.PhaAPosActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaAPosActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)正向有功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00210400:						//(A相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaANegActEngHD[i].ULinteger = MidTermSharedData.PhaANegActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaANegActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)反向有功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00310400:						//(A相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaAPosReaEngTypeHD[i] = gMidPriMeasurePara.PhaAPosReaEngTypeHD[i];
                HisTermSharedData.PhaAPosReaEngHD[i].ULinteger = MidTermSharedData.PhaAPosReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaAPosReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)正向无功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00410400:						//(A相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaANegReaEngTypeHD[i] = gMidPriMeasurePara.PhaANegReaEngTypeHD[i];
                HisTermSharedData.PhaANegReaEngHD[i].ULinteger = MidTermSharedData.PhaANegReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaANegReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (A相)反向无功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00120400:						//(B相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBPosActEngHD[i].ULinteger = MidTermSharedData.PhaBPosActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBPosActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)正向有功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00220400:						//(B相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBNegActEngHD[i].ULinteger = MidTermSharedData.PhaBNegActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBNegActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)反向有功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00320400:						//(B相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaBPosReaEngTypeHD[i] = gMidPriMeasurePara.PhaBPosReaEngTypeHD[i];
                HisTermSharedData.PhaBPosReaEngHD[i].ULinteger = MidTermSharedData.PhaBPosReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBPosReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)正向无功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00420400:						//(B相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaBNegReaEngTypeHD[i] = gMidPriMeasurePara.PhaBNegReaEngTypeHD[i];
                HisTermSharedData.PhaBNegReaEngHD[i].ULinteger = MidTermSharedData.PhaBNegReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBNegReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (B相)反向无功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00130400:						//(C相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCPosActEngHD[i].ULinteger = MidTermSharedData.PhaCPosActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCPosActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)正向有功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00230400:						//(C相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCNegActEngHD[i].ULinteger = MidTermSharedData.PhaCNegActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCNegActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)反向有功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00330400:						//(C相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaCPosReaEngTypeHD[i] = gMidPriMeasurePara.PhaCPosReaEngTypeHD[i];
                HisTermSharedData.PhaCPosReaEngHD[i].ULinteger = MidTermSharedData.PhaCPosReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCPosReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)正向无功总电能示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00430400:						//(C相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.PhaCNegReaEngTypeHD[i] = gMidPriMeasurePara.PhaCNegReaEngTypeHD[i];
                HisTermSharedData.PhaCNegReaEngHD[i].ULinteger = MidTermSharedData.PhaCNegReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCNegReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (C相)反向无功总电能示值! 高精度\n", nOAD, i);
        }
            break;


        /* 增加 电能 start*/
        case 0x00000400:						//(当前)组合有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                gHisPriMeasurePara.CmbEnergyTypeHD[i] = gMidPriMeasurePara.CmbEnergyTypeHD[i];
                HisTermSharedData.CmbActEngHD[i].ULinteger = MidTermSharedData.CmbActEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateCmbActEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (当前)组合有功电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00900400:						//(当前)正向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PosAppEngHD[i].ULinteger = MidTermSharedData.PosAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePosAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (当前)正向视在电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00A00400:						//(当前)反向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.NegAppEngHD[i].ULinteger = MidTermSharedData.NegAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdateNegAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, (当前)反向视在电能总尖峰平谷示值! 高精度\n", nOAD, i);
        }
            break;

        case 0x00510400:						//A相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA1ReaEngHD[i].ULinteger = MidTermSharedData.PhaA1ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA1ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第一象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00520400:						//B相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB1ReaEngHD[i].ULinteger = MidTermSharedData.PhaB1ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB1ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第一象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00530400:						//C相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC1ReaEngHD[i].ULinteger = MidTermSharedData.PhaC1ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC1ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第一象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00610400:						//A相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA2ReaEngHD[i].ULinteger = MidTermSharedData.PhaA2ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA2ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第二象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00620400:						//B相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB2ReaEngHD[i].ULinteger = MidTermSharedData.PhaB2ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB2ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第二象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00630400:						//C相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC2ReaEngHD[i].ULinteger = MidTermSharedData.PhaC2ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC2ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第二象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00710400:						//A相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA3ReaEngHD[i].ULinteger = MidTermSharedData.PhaA3ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA3ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第三象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00720400:						//B相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB3ReaEngHD[i].ULinteger = MidTermSharedData.PhaB3ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB3ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第三象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00730400:						//C相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC3ReaEngHD[i].ULinteger = MidTermSharedData.PhaC3ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC3ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第三象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00810400:						//A相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaA4ReaEngHD[i].ULinteger = MidTermSharedData.PhaA4ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaA4ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相第四象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00820400:						//B相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaB4ReaEngHD[i].ULinteger = MidTermSharedData.PhaB4ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaB4ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相第四象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00830400:						//C相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaC4ReaEngHD[i].ULinteger = MidTermSharedData.PhaC4ReaEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaC4ReaEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相第四象限无功电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00910400:						//A相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaAActAppEngHD[i].ULinteger = MidTermSharedData.PhaAActAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaAActAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相正向视在电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00920400:						//B相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBActAppEngHD[i].ULinteger = MidTermSharedData.PhaBActAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBActAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相正向视在电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00930400:						//C相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCActAppEngHD[i].ULinteger = MidTermSharedData.PhaCActAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCActAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相正向视在电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00A10400:						//A相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaANegAppEngHD[i].ULinteger = MidTermSharedData.PhaANegAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaANegAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相反向视在电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00A20400:						//B相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBNegAppEngHD[i].ULinteger = MidTermSharedData.PhaBNegAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaBNegAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相反向视在电能! 高精度\n", nOAD, i);
        }
            break;

        case 0x00A30400:						//C相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCNegAppEngHD[i].ULinteger = MidTermSharedData.PhaCNegAppEngHD[i].ULinteger;
            }
            gUpdateFlag.bUpdatePhaCNegAppEngHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相反向视在电能! 高精度\n", nOAD, i);
        }
            break;

        /* 增加 电能 end*/

        /***高精度 电能量 end***/

        case 0x10100200:				//(当前)正向有功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.CurrDemand[0][i].DemNum[0], &MidTermSharedData.CurrDemand[0][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.CurrDemandTime[0][i].DemTime[0], &MidTermSharedData.CurrDemandTime[0][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdatePosActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向有功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10200200:				//(当前)反向有功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.CurrDemand[1][i].DemNum[0], &MidTermSharedData.CurrDemand[1][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.CurrDemandTime[1][i].DemTime[0], &MidTermSharedData.CurrDemandTime[1][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateNegActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向有功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10300200:				//(当前)正向无功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.CurrDemand[2][i].DemNum[0], &MidTermSharedData.CurrDemand[2][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.CurrDemandTime[2][i].DemTime[0], &MidTermSharedData.CurrDemandTime[2][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdatePosReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向无功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10400200:				//(当前)反向无功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.CurrDemand[3][i].DemNum[0], &MidTermSharedData.CurrDemand[3][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.CurrDemandTime[3][i].DemTime[0], &MidTermSharedData.CurrDemandTime[3][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateNegReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向无功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        /* 增加 需量 begin*/
        case 0x10500200:				//(当前)1象限无功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.QuaDemand[0][i].DemNum[0], &MidTermSharedData.QuaDemand[0][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.QuaDemandTime[0][i].DemTime[0], &MidTermSharedData.QuaDemandTime[0][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateQuad1ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 1象限无功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10600200:				//(当前)2象限无功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.QuaDemand[1][i].DemNum[0], &MidTermSharedData.QuaDemand[1][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.QuaDemandTime[1][i].DemTime[0], &MidTermSharedData.QuaDemandTime[1][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateQuad2ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 2象限无功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10700200:				//(当前)3象限无功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.QuaDemand[2][i].DemNum[0], &MidTermSharedData.QuaDemand[2][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.QuaDemandTime[2][i].DemTime[0], &MidTermSharedData.QuaDemandTime[2][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateQuad3ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 3象限无功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10800200:				//(当前)4象限无功总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.QuaDemand[3][i].DemNum[0], &MidTermSharedData.QuaDemand[3][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.QuaDemandTime[3][i].DemTime[0], &MidTermSharedData.QuaDemandTime[3][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateQuad4ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 4象限无功总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10900200:				//(当前)正向视在电能总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.AppaDemand[0][i].DemNum[0], &MidTermSharedData.AppaDemand[0][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.AppaDemandTime[0][i].DemTime[0], &MidTermSharedData.AppaDemandTime[0][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdatePosAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 正向视在电能总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        case 0x10A00200:				//(当前)反向视在电能总尖峰平谷最大需量
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                memcpy(&HisTermSharedData.AppaDemand[1][i].DemNum[0], &MidTermSharedData.AppaDemand[1][i].DemNum[0], 3);
                memcpy(&HisTermSharedData.AppaDemandTime[1][i].DemTime[0], &MidTermSharedData.AppaDemandTime[1][i].DemTime[0], 6);
            }
            gUpdateFlag.bUpdateNegAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 反向视在电能总尖峰平谷最大需量! \n", nOAD, i);
        }
            break;

        /* 增加 需量 end*/

        /* 增加 分项需量 begin*/
        case 0x10110200:				//(当前)A相 正向有功最大需量
        {
            memcpy(&HisTermSharedData.PosActDemand[0].DemNum[0], &MidTermSharedData.PosActDemand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.PosActDemandTime[0].DemTime[0], &MidTermSharedData.PosActDemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaAPosActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 正向有功最大需量! \n", nOAD, i);
        }
            break;

        case 0x10120200:				//(当前)B相 正向有功最大需量
        {
            memcpy(&HisTermSharedData.PosActDemand[1].DemNum[0], &MidTermSharedData.PosActDemand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.PosActDemandTime[1].DemTime[0], &MidTermSharedData.PosActDemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaBPosActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 正向有功最大需量! \n", nOAD, i);
        }
            break;

        case 0x10130200:				//(当前)C相 正向有功最大需量
        {
            memcpy(&HisTermSharedData.PosActDemand[2].DemNum[0], &MidTermSharedData.PosActDemand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.PosActDemandTime[2].DemTime[0], &MidTermSharedData.PosActDemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaCPosActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 正向有功最大需量! \n", nOAD, i);
        }
            break;


        case 0x10210200:				//(当前)A相 反向有功最大需量
        {
            memcpy(&HisTermSharedData.NegActDemand[0].DemNum[0], &MidTermSharedData.NegActDemand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegActDemandTime[0].DemTime[0], &MidTermSharedData.NegActDemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaANegActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 反向有功最大需量! \n", nOAD, i);
        }
            break;

        case 0x10220200:				//(当前)B相 反向有功最大需量
        {
            memcpy(&HisTermSharedData.NegActDemand[1].DemNum[0], &MidTermSharedData.NegActDemand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegActDemandTime[1].DemTime[0], &MidTermSharedData.NegActDemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaBNegActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 反向有功最大需量! \n", nOAD, i);
        }
            break;

        case 0x10230200:				//(当前)C相 反向有功最大需量
        {
            memcpy(&HisTermSharedData.NegActDemand[2].DemNum[0], &MidTermSharedData.NegActDemand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegActDemandTime[2].DemTime[0], &MidTermSharedData.NegActDemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaCNegActDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 反向有功最大需量! \n", nOAD, i);
        }
            break;


        case 0x10310200:				//(当前)A相 组合无功1最大需量
        {
            memcpy(&HisTermSharedData.PosReaDemand[0].DemNum[0], &MidTermSharedData.PosReaDemand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.PosReaDemandTime[0].DemTime[0], &MidTermSharedData.PosReaDemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaAPosReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 组合无功1最大需量! \n", nOAD, i);
        }
            break;

        case 0x10320200:				//(当前)B相 组合无功1最大需量
        {
            memcpy(&HisTermSharedData.PosReaDemand[1].DemNum[0], &MidTermSharedData.PosReaDemand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.PosReaDemandTime[1].DemTime[0], &MidTermSharedData.PosReaDemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaBPosReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 组合无功1最大需量! \n", nOAD, i);
        }
            break;

        case 0x10330200:				//(当前)C相 组合无功1最大需量
        {
            memcpy(&HisTermSharedData.PosReaDemand[2].DemNum[0], &MidTermSharedData.PosReaDemand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.PosReaDemandTime[2].DemTime[0], &MidTermSharedData.PosReaDemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaCPosReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 组合无功1最大需量! \n", nOAD, i);
        }
            break;


        case 0x10410200:				//(当前)A相 组合无功2最大需量
        {
            memcpy(&HisTermSharedData.NegReaDemand[0].DemNum[0], &MidTermSharedData.NegReaDemand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegReaDemandTime[0].DemTime[0], &MidTermSharedData.NegReaDemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaANegReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 组合无功2最大需量! \n", nOAD, i);
        }
            break;

        case 0x10420200:				//(当前)B相 组合无功2最大需量
        {
            memcpy(&HisTermSharedData.NegReaDemand[1].DemNum[0], &MidTermSharedData.NegReaDemand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegReaDemandTime[1].DemTime[0], &MidTermSharedData.NegReaDemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaBNegReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 组合无功2最大需量! \n", nOAD, i);
        }
            break;

        case 0x10430200:				//(当前)C相 组合无功2最大需量
        {
            memcpy(&HisTermSharedData.NegReaDemand[2].DemNum[0], &MidTermSharedData.NegReaDemand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegReaDemandTime[2].DemTime[0], &MidTermSharedData.NegReaDemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaCNegReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 组合无功2最大需量! \n", nOAD, i);
        }
            break;


        case 0x10510200:				//(当前)A相 第一象限最大需量
        {
            memcpy(&HisTermSharedData.Qua1Demand[0].DemNum[0], &MidTermSharedData.Qua1Demand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua1DemandTime[0].DemTime[0], &MidTermSharedData.Qua1DemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaA1ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 第一象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10520200:				//(当前)B相 第一象限最大需量
        {
            memcpy(&HisTermSharedData.Qua1Demand[1].DemNum[0], &MidTermSharedData.Qua1Demand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua1DemandTime[1].DemTime[0], &MidTermSharedData.Qua1DemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaB1ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 第一象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10530200:				//(当前)C相 第一象限最大需量
        {
            memcpy(&HisTermSharedData.Qua1Demand[2].DemNum[0], &MidTermSharedData.Qua1Demand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua1DemandTime[2].DemTime[0], &MidTermSharedData.Qua1DemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaC1ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 第一象限最大需量! \n", nOAD, i);
        }
            break;


        case 0x10610200:				//(当前)A相 第二象限最大需量
        {
            memcpy(&HisTermSharedData.Qua2Demand[0].DemNum[0], &MidTermSharedData.Qua2Demand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua2DemandTime[0].DemTime[0], &MidTermSharedData.Qua2DemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaA2ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 第二象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10620200:				//(当前)B相 第二象限最大需量
        {
            memcpy(&HisTermSharedData.Qua2Demand[1].DemNum[0], &MidTermSharedData.Qua2Demand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua2DemandTime[1].DemTime[0], &MidTermSharedData.Qua2DemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaB2ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 第二象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10630200:				//(当前)C相 第二象限最大需量
        {
            memcpy(&HisTermSharedData.Qua2Demand[2].DemNum[0], &MidTermSharedData.Qua2Demand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua2DemandTime[2].DemTime[0], &MidTermSharedData.Qua2DemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaC2ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 第二象限最大需量! \n", nOAD, i);
        }
            break;


        case 0x10710200:				//(当前)A相 第三象限最大需量
        {
            memcpy(&HisTermSharedData.Qua3Demand[0].DemNum[0], &MidTermSharedData.Qua3Demand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua3DemandTime[0].DemTime[0], &MidTermSharedData.Qua3DemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaA3ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 第三象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10720200:				//(当前)B相 第三象限最大需量
        {
            memcpy(&HisTermSharedData.Qua3Demand[1].DemNum[0], &MidTermSharedData.Qua3Demand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua3DemandTime[1].DemTime[0], &MidTermSharedData.Qua3DemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaB3ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 第三象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10730200:				//(当前)C相 第三象限最大需量
        {
            memcpy(&HisTermSharedData.Qua3Demand[2].DemNum[0], &MidTermSharedData.Qua3Demand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua3DemandTime[2].DemTime[0], &MidTermSharedData.Qua3DemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaC3ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 第三象限最大需量! \n", nOAD, i);
        }
            break;


        case 0x10810200:				//(当前)A相 第四象限最大需量
        {
            memcpy(&HisTermSharedData.Qua4Demand[0].DemNum[0], &MidTermSharedData.Qua4Demand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua4DemandTime[0].DemTime[0], &MidTermSharedData.Qua4DemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaA4ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 第四象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10820200:				//(当前)B相 第四象限最大需量
        {
            memcpy(&HisTermSharedData.Qua4Demand[1].DemNum[0], &MidTermSharedData.Qua4Demand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua4DemandTime[1].DemTime[0], &MidTermSharedData.Qua4DemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaB4ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 第四象限最大需量! \n", nOAD, i);
        }
            break;

        case 0x10830200:				//(当前)C相 第四象限最大需量
        {
            memcpy(&HisTermSharedData.Qua4Demand[2].DemNum[0], &MidTermSharedData.Qua4Demand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.Qua4DemandTime[2].DemTime[0], &MidTermSharedData.Qua4DemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaC4ReaDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 第四象限最大需量! \n", nOAD, i);
        }
            break;


        case 0x10910200:				//(当前)A相 正向视在最大需量
        {
            memcpy(&HisTermSharedData.ActAppDemand[0].DemNum[0], &MidTermSharedData.ActAppDemand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.ActAppDemandTime[0].DemTime[0], &MidTermSharedData.ActAppDemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaAActAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 正向视在最大需量! \n", nOAD, i);
        }
            break;

        case 0x10920200:				//(当前)B相 正向视在最大需量
        {
            memcpy(&HisTermSharedData.ActAppDemand[1].DemNum[0], &MidTermSharedData.ActAppDemand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.ActAppDemandTime[1].DemTime[0], &MidTermSharedData.ActAppDemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaBActAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 正向视在最大需量! \n", nOAD, i);
        }
            break;

        case 0x10930200:				//(当前)C相 正向视在最大需量
        {
            memcpy(&HisTermSharedData.ActAppDemand[2].DemNum[0], &MidTermSharedData.ActAppDemand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.ActAppDemandTime[2].DemTime[0], &MidTermSharedData.ActAppDemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaCActAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 正向视在最大需量! \n", nOAD, i);
        }
            break;


        case 0x10A10200:				//(当前)A相 反向视在最大需量
        {
            memcpy(&HisTermSharedData.NegAppDemand[0].DemNum[0], &MidTermSharedData.NegAppDemand[0].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegAppDemandTime[0].DemTime[0], &MidTermSharedData.NegAppDemandTime[0].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaANegAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 反向视在最大需量! \n", nOAD, i);
        }
            break;

        case 0x10A20200:				//(当前)B相 反向视在最大需量
        {
            memcpy(&HisTermSharedData.NegAppDemand[1].DemNum[0], &MidTermSharedData.NegAppDemand[1].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegAppDemandTime[1].DemTime[0], &MidTermSharedData.NegAppDemandTime[1].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaBNegAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 反向视在最大需量! \n", nOAD, i);
        }
            break;

        case 0x10A30200:				//(当前)C相 反向视在最大需量
        {
            memcpy(&HisTermSharedData.NegAppDemand[2].DemNum[0], &MidTermSharedData.NegAppDemand[2].DemNum[0], 3);
            memcpy(&HisTermSharedData.NegAppDemandTime[2].DemTime[0], &MidTermSharedData.NegAppDemandTime[2].DemTime[0], 6);
            gUpdateFlag.bUpdatePhaCNegAppDmd = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 反向视在最大需量! \n", nOAD, i);
        }
            break;

        /* 增加 分项需量 end*/
            

        case 0x20040200:						//(当前)瞬时有功功率
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.ActPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.ActPowFlag;
                    HisTermSharedData.NegActPower = MidTermSharedData.NegActPower;
                    HisTermSharedData.PosActPower = MidTermSharedData.PosActPower;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag;
                    HisTermSharedData.PhaAActPower = MidTermSharedData.PhaAActPower;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag;
                    HisTermSharedData.PhaBActPower = MidTermSharedData.PhaBActPower;
                }
                if(i == 3)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag;
                    HisTermSharedData.PhaCActPower = MidTermSharedData.PhaCActPower;
                }
            }
            gUpdateFlag.bUpdateActPower = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 瞬时有功功率! \n", nOAD, i);
        }
            break;

        case 0x20050200:			   //(当前)瞬时无功功率
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.ReaPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.ReaPowFlag;
                    HisTermSharedData.NegReaPower = MidTermSharedData.NegReaPower;
                    HisTermSharedData.PosReaPower = MidTermSharedData.PosReaPower;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag;
                    HisTermSharedData.PhaAReaPower = MidTermSharedData.PhaAReaPower;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag;
                    HisTermSharedData.PhaBReaPower = MidTermSharedData.PhaBReaPower;
                }
                if(i == 3)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag;
                    HisTermSharedData.PhaCReaPower = MidTermSharedData.PhaCReaPower;
                }
            }
            gUpdateFlag.bUpdateReaPower = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 瞬时无功功率! \n", nOAD, i);
        }
            break;


        /* 增加	视在功率 begin*/
        case 0x20060200:						//(当前)瞬时视在功率
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.AppPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.AppPowFlag;
                    HisTermSharedData.NegApparentPower = MidTermSharedData.NegApparentPower;
                    HisTermSharedData.PosApparentPower = MidTermSharedData.PosApparentPower;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag;
                    HisTermSharedData.PhaAAppPower = MidTermSharedData.PhaAAppPower;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag;
                    HisTermSharedData.PhaBAppPower = MidTermSharedData.PhaBAppPower;
                }
                if(i == 3)
                {
                    gHisPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag = gMidPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag;
                    HisTermSharedData.PhaCAppPower = MidTermSharedData.PhaCAppPower;
                }
            }
            gUpdateFlag.bUpdateAppPower = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 瞬时视在功率! \n", nOAD, i);
        }
            break;

        /* 增加	视在功率 end*/
        

        case 0x20000200:			   //(当前)三相电压
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    HisTermSharedData.PhaAVolt = MidTermSharedData.PhaAVolt;
                }
                if(i == 1)
                {
                    HisTermSharedData.PhaBVolt = MidTermSharedData.PhaBVolt;
                }
                if(i == 2)
                {
                    HisTermSharedData.PhaCVolt = MidTermSharedData.PhaCVolt;
                }
            }
            gUpdateFlag.bUpdateVolt = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 三相电压! \n", nOAD, i);
        }
            break;

        case 0x20000400:			   //(当前)高精度三相电压
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for(i = 0; i < nNum; i++)
            {
                if(i == 0)
                {
                    HisTermSharedData.PhaAVoltHD = MidTermSharedData.PhaAVoltHD;
                }
                if(i == 1)
                {
                    HisTermSharedData.PhaBVoltHD = MidTermSharedData.PhaBVoltHD;
                }
                if(i == 2)
                {
                    HisTermSharedData.PhaCVoltHD = MidTermSharedData.PhaCVoltHD;
                }
            }
            gUpdateFlag.bUpdateVoltHD = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 高精度三相电压! \n", nOAD, i);
        }
            break;
            
        case 0x20000600:			   //(当前)零序电压
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    HisTermSharedData.PhaZeroVolt = MidTermSharedData.PhaZeroVolt;
                }
            }
            gUpdateFlag.bUpdateZeroVolt = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 零序电压! \n", nOAD, i);
        }
            break;

        case 0x20010200:						//(当前)三相电流
        {
            //nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            nNum = 3;  //目前只使用前3个数据项, 手动填3
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag = gMidPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag;
                    HisTermSharedData.PhaACurr = MidTermSharedData.PhaACurr;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag = gMidPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag;
                    HisTermSharedData.PhaBCurr = MidTermSharedData.PhaBCurr;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag = gMidPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag;
                    HisTermSharedData.PhaCCurr = MidTermSharedData.PhaCCurr;
                }
            }
            gUpdateFlag.bUpdateCurr = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 三相电流! \n", nOAD, i);
        }
            break;

        case 0x20010400:						//(当前)零线电流
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                if (i == 0)
                {
                    gHisPriMeasurePara.CurrentSignType.ZeroLineCurrentFlag = gMidPriMeasurePara.CurrentSignType.ZeroLineCurrentFlag;
                    HisTermSharedData.PhaGCurr = MidTermSharedData.PhaGCurr;
                }
            }
            gUpdateFlag.bUpdateCurr = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 零线电流! \n", nOAD, i);
        }
        break;

        case 0x20010600:						//(当前)零序电流
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.CurrentSignType.ZeroCurrentFlag = gMidPriMeasurePara.CurrentSignType.ZeroCurrentFlag;
                    HisTermSharedData.PhaMCurr = MidTermSharedData.PhaMCurr;
                }
            }
            gUpdateFlag.bUpdateCurr = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 零序电流! \n", nOAD, i);
        }
            break;

        case 0x200F0200:						//(当前)电网频率
        {
            HisTermSharedData.LineFrz = MidTermSharedData.LineFrz;
            gUpdateFlag.bUpdateLineFrz = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电网频率! \n", nOAD, i);
        }
            break;

        /***增加 电压不平衡率 begin***/
        case 0x20260200:						//电压不平衡率
        {
            HisTermSharedData.VoltUnbalanceRate = MidTermSharedData.VoltUnbalanceRate;
            gUpdateFlag.bUpdateVoltUnRate = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电压不平衡率! \n", nOAD, i);
        }
            break;
        /***增加 电压不平衡率 end***/

        /***增加 电流不平衡率 begin***/
        case 0x20270200:						//电流不平衡率
        {
            HisTermSharedData.CurrUnbalanceRate = MidTermSharedData.CurrUnbalanceRate;
            gUpdateFlag.bUpdateCurrUnRate = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电流不平衡率! \n", nOAD, i);
        }
            break;
        /***增加 电流不平衡率 end***/

        case 0x200A0200:						//(当前)瞬时总及分相功率因数
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.PowerFactorType.AppPfFlag = gMidPriMeasurePara.PowerFactorType.AppPfFlag;
                    HisTermSharedData.PowerFactor = MidTermSharedData.PowerFactor;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.PowerFactorType.PhaAAppPfFlag = gMidPriMeasurePara.PowerFactorType.PhaAAppPfFlag;
                    HisTermSharedData.PhaAPowerFactor = MidTermSharedData.PhaAPowerFactor;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.PowerFactorType.PhaBAppPfFlag = gMidPriMeasurePara.PowerFactorType.PhaBAppPfFlag;
                    HisTermSharedData.PhaBPowerFactor = MidTermSharedData.PhaBPowerFactor;
                }
                if(i == 3)
                {
                    gHisPriMeasurePara.PowerFactorType.PhaCAppPfFlag = gMidPriMeasurePara.PowerFactorType.PhaCAppPfFlag;
                    HisTermSharedData.PhaCPowerFactor = MidTermSharedData.PhaCPowerFactor;
                }
            }
            gUpdateFlag.bUpdatePowerFactor = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 瞬时总及分相功率因数! \n", nOAD, i);
        }
            break;

        /* 增加	电表状态字1-7 begin*/
        case 0x20140200:						//电表运行状态字1-7
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    HisTermSharedData.MetStusPara.Rsw1.Word = MidTermSharedData.MetStusPara.Rsw1.Word;
                }
                else if(i == 1)
                {
                    HisTermSharedData.MetStusPara.Rsw2.Word = MidTermSharedData.MetStusPara.Rsw2.Word;
                }
                else if(i == 2)
                {
                    HisTermSharedData.MetStusPara.Rsw3.Word = MidTermSharedData.MetStusPara.Rsw3.Word;
                }
                else if(i == 3)
                {
                    HisTermSharedData.MetStusPara.Rsw4.Word = MidTermSharedData.MetStusPara.Rsw4.Word;
                }
                else if(i == 4)
                {
                    HisTermSharedData.MetStusPara.Rsw5.Word = MidTermSharedData.MetStusPara.Rsw5.Word;
                }
                else if(i == 5)
                {
                    HisTermSharedData.MetStusPara.Rsw6.Word = MidTermSharedData.MetStusPara.Rsw6.Word;
                }
                else if(i == 6)
                {
                    HisTermSharedData.MetStusPara.Rsw7.Word = MidTermSharedData.MetStusPara.Rsw7.Word;
                }
            }
            gUpdateFlag.bUpdateMetStusPara = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电表运行状态字1-7! \n", nOAD, i);
        }
            break;
        
        /* 增加	电表状态字1-7 end*/


        /* 增加	相角 begin*/
        case 0x20020200:			   //(当前)电压相角
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag;
                    HisTermSharedData.PhaAVoltAngle = MidTermSharedData.PhaAVoltAngle;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag;
                    HisTermSharedData.PhaBVoltAngle = MidTermSharedData.PhaBVoltAngle;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag;
                    HisTermSharedData.PhaCVoltAngle = MidTermSharedData.PhaCVoltAngle;
                }
            }
            gUpdateFlag.bUpdateVoltAngle = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电流相角! \n", nOAD, i);
        }
            break;
        case 0xAAAA0001:			   //(当前)电流相角
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag;
                    HisTermSharedData.PhaACurrAngle = MidTermSharedData.PhaACurrAngle;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag;
                    HisTermSharedData.PhaBCurrAngle = MidTermSharedData.PhaBCurrAngle;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag;
                    HisTermSharedData.PhaCCurrAngle = MidTermSharedData.PhaCCurrAngle;
                }
            }
            gUpdateFlag.bUpdateCurrAngle = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电压相角! \n", nOAD, i);
        }
            break;

        case 0x20030200:			   //(当前)电压电流相角
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag;
                    HisTermSharedData.PhaAAngle = MidTermSharedData.PhaAAngle;
                }
                if(i == 1)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag;
                    HisTermSharedData.PhaBAngle = MidTermSharedData.PhaBAngle;
                }
                if(i == 2)
                {
                    gHisPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag = gMidPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag;
                    HisTermSharedData.PhaCAngle = MidTermSharedData.PhaCAngle;
                }
            }
            gUpdateFlag.bUpdateVoltCurrAngle = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, 电压电流相角! \n", nOAD, i);
        }
            break;

        /* 增加	相角 end*/

        /* 增加 谐波 begin*/
        case 0x200D0200:			   //(当前)A相 电压谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaAVoltHarmonic[i] = MidTermSharedData.PhaAVoltHarmonic[i];
            }
            gUpdateFlag.bUpdateAVoltHarmonic = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 电压谐波含有率! \n", nOAD, i);
        }
            break;

        case 0x200D0300:			   //(当前)B相 电压谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBVoltHarmonic[i] = MidTermSharedData.PhaBVoltHarmonic[i];
            }
            gUpdateFlag.bUpdateBVoltHarmonic = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 电压谐波含有率! \n", nOAD, i);
        }
            break;

        case 0x200D0400:			   //(当前)C相 电压谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCVoltHarmonic[i] = MidTermSharedData.PhaCVoltHarmonic[i];
            }
            gUpdateFlag.bUpdateCVoltHarmonic = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 电压谐波含有率! \n", nOAD, i);
        }
            break;

        case 0x200E0200:			   //(当前)A相 电流谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaACurrHarmonic[i] = MidTermSharedData.PhaACurrHarmonic[i];
            }
            gUpdateFlag.bUpdateACurrHarmonic = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 电流谐波含有率! \n", nOAD, i);
        }
            break;

        case 0x200E0300:			   //(当前)B相 电流谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaBCurrHarmonic[i] = MidTermSharedData.PhaBCurrHarmonic[i];
            }
            gUpdateFlag.bUpdateBCurrHarmonic = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 电流谐波含有率! \n", nOAD, i);
        }
            break;

        case 0x200E0400:			   //(当前)C相 电流谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                HisTermSharedData.PhaCCurrHarmonic[i] = MidTermSharedData.PhaCCurrHarmonic[i];
            }
            gUpdateFlag.bUpdateCCurrHarmonic = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 电流谐波含有率! \n", nOAD, i);
        }
            break;

        /* 增加 谐波 end*/

        /* 增加 谐波含量 begin*/
        case 0x20330200:			   //(当前)A相 电压谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                HisTermSharedData.PhaAVoltHarmonicValue[i] = MidTermSharedData.PhaAVoltHarmonicValue[i];
            }
            gUpdateFlag.bUpdateAVoltHarmonicValue = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 电压谐波含量! \n", nOAD, i);
        }
            break;

        case 0x20330300:			   //(当前)B相 电压谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                HisTermSharedData.PhaBVoltHarmonicValue[i] = MidTermSharedData.PhaBVoltHarmonicValue[i];
            }
            gUpdateFlag.bUpdateBVoltHarmonicValue = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 电压谐波含量! \n", nOAD, i);
        }
            break;

        case 0x20330400:			   //(当前)C相 电压谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                HisTermSharedData.PhaCVoltHarmonicValue[i] = MidTermSharedData.PhaCVoltHarmonicValue[i];
            }
            gUpdateFlag.bUpdateCVoltHarmonicValue = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 电压谐波含量! \n", nOAD, i);
        }
            break;

        case 0x20340200:			   //(当前)A相 电流谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                HisTermSharedData.PhaACurrHarmonicValue[i] = MidTermSharedData.PhaACurrHarmonicValue[i];
                gHisPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i] = gMidPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i];
            }
            gUpdateFlag.bUpdateACurrHarmonicValue = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, A相 电流谐波含量! \n", nOAD, i);
        }
            break;

        case 0x20340300:			   //(当前)B相 电流谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                HisTermSharedData.PhaBCurrHarmonicValue[i] = MidTermSharedData.PhaBCurrHarmonicValue[i];
                gHisPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i] = gMidPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i];
            }
            gUpdateFlag.bUpdateBCurrHarmonicValue = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, B相 电流谐波含量! \n", nOAD, i);
        }
            break;

        case 0x20340400:			   //(当前)C相 电流谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                HisTermSharedData.PhaCCurrHarmonicValue[i] = MidTermSharedData.PhaCCurrHarmonicValue[i];
                gHisPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i] = gMidPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i];
            }
            gUpdateFlag.bUpdateCCurrHarmonicValue = 0;
            ACDB_FMT_LOGCC("更新历史记录 nOAD=0x%08x, i=%d, C相 电流谐波含量! \n", nOAD, i);
        }
            break;

        /* 增加 谐波含量 end*/


        default:
            return -1;
            break;
   }

    return 1;
}



/****************************************************************************
*模块编号：
*名称：CheckDataDeadZone
*功能：检测交采数据是否越过变化死区
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int CheckDataDeadZone(const Map645ToOop_NEW *pOadInfo)
{
    int 	i	 = 0;
    uint16	nNum = 0;
    uint32	nOAD = 0;
    int     result = -1; //1:越过死区；-1:没有越过死区

    nOAD = pOadInfo->Oad.value;

    switch(nOAD)
    {
        case 0x00100200:						//(当前)正向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PosActEng[i].ULinteger - HisTermSharedData.PosActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PosActEng[i].ULinteger=%d, HisTermSharedData.PosActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PosActEng[i].ULinteger, HisTermSharedData.PosActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePosActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePosActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePosActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00200200:						//(当前)反向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.NegActEng[i].ULinteger - HisTermSharedData.NegActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.NegActEng[i].ULinteger=%d, HisTermSharedData.NegActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.NegActEng[i].ULinteger, HisTermSharedData.NegActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateNegActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateNegActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateNegActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00300200:						//(当前)正向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PosReaEnergyType[i] != gHisPriMeasurePara.PosReaEnergyType[i])
                {
                    gUpdateFlag.bUpdatePosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PosReaEnergyType[i]=%d, gHisPriMeasurePara.PosReaEnergyType[i]=%d, gUpdateFlag.bUpdatePosReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PosReaEnergyType[i], gHisPriMeasurePara.PosReaEnergyType[i], gUpdateFlag.bUpdatePosReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PosReaEng[i].ULinteger - HisTermSharedData.PosReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PosReaEng[i].ULinteger=%d, HisTermSharedData.PosReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PosReaEng[i].ULinteger, HisTermSharedData.PosReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePosReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePosReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00400200:						//(当前)反向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.NegReaEnergyType[i] != gHisPriMeasurePara.NegReaEnergyType[i])
                {
                    gUpdateFlag.bUpdateNegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.NegReaEnergyType[i]=%d, gHisPriMeasurePara.NegReaEnergyType[i]=%d, gUpdateFlag.bUpdateNegReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.NegReaEnergyType[i], gHisPriMeasurePara.NegReaEnergyType[i], gUpdateFlag.bUpdateNegReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.NegReaEng[i].ULinteger - HisTermSharedData.NegReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.NegReaEng[i].ULinteger=%d, HisTermSharedData.NegReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.NegReaEng[i].ULinteger, HisTermSharedData.NegReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateNegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateNegReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateNegReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00500200:						//(当前)第一象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad1ReaEng[i].ULinteger - HisTermSharedData.Quad1ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad1ReaEng[i].ULinteger=%d, HisTermSharedData.Quad1ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad1ReaEng[i].ULinteger, HisTermSharedData.Quad1ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateQuad1ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad1ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateQuad1ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00600200:						//(当前)第二象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad2ReaEng[i].ULinteger - HisTermSharedData.Quad2ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad2ReaEng[i].ULinteger=%d, HisTermSharedData.Quad2ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad2ReaEng[i].ULinteger, HisTermSharedData.Quad2ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateQuad2ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad2ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateQuad2ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00700200:						//(当前)第三象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad3ReaEng[i].ULinteger - HisTermSharedData.Quad3ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad3ReaEng[i].ULinteger=%d, HisTermSharedData.Quad3ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad3ReaEng[i].ULinteger, HisTermSharedData.Quad3ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateQuad3ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad3ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateQuad3ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00800200:						//(当前)第四象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad4ReaEng[i].ULinteger - HisTermSharedData.Quad4ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad4ReaEng[i].ULinteger=%d, HisTermSharedData.Quad4ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad4ReaEng[i].ULinteger, HisTermSharedData.Quad4ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateQuad4ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad4ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateQuad4ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00010200:                          //(A相)组合有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                int DValue = MidTermSharedData.PhaACmbActEng[i].SLinteger - HisTermSharedData.PhaACmbActEng[i].SLinteger;
                if (abs(DValue) >= DEAD_ZONE_ENG)
                {
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, result=%d 电量变化值越过死区值\n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, result);
                    break;
                }
            }
        }
            break;

        case 0x00110200:						//(A相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaAPosActEng[i].ULinteger - HisTermSharedData.PhaAPosActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaAPosActEng[i].ULinteger=%d, HisTermSharedData.PhaAPosActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaAPosActEng[i].ULinteger, HisTermSharedData.PhaAPosActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaAPosActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaAPosActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaAPosActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00210200:						//(A相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaANegActEng[i].ULinteger - HisTermSharedData.PhaANegActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaANegActEng[i].ULinteger=%d, HisTermSharedData.PhaANegActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaANegActEng[i].ULinteger, HisTermSharedData.PhaANegActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaANegActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaANegActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaANegActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00310200:						//(A相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaAPosReaEngType[i] != gHisPriMeasurePara.PhaAPosReaEngType[i])
                {
                    gUpdateFlag.bUpdatePhaAPosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaAPosReaEngType[i]=%d, gHisPriMeasurePara.PhaAPosReaEngType[i]=%d, gUpdateFlag.bUpdatePhaAPosReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaAPosReaEngType[i], gHisPriMeasurePara.PhaAPosReaEngType[i], gUpdateFlag.bUpdatePhaAPosReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaAPosReaEng[i].ULinteger - HisTermSharedData.PhaAPosReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaAPosReaEng[i].ULinteger=%d, HisTermSharedData.PhaAPosReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaAPosReaEng[i].ULinteger, HisTermSharedData.PhaAPosReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaAPosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaAPosReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaAPosReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00410200:						//(A相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaANegReaEngType[i] != gHisPriMeasurePara.PhaANegReaEngType[i])
                {
                    gUpdateFlag.bUpdatePhaANegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaANegReaEngType[i]=%d, gHisPriMeasurePara.PhaANegReaEngType[i]=%d, gUpdateFlag.bUpdatePhaANegReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaANegReaEngType[i], gHisPriMeasurePara.PhaANegReaEngType[i], gUpdateFlag.bUpdatePhaANegReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaANegReaEng[i].ULinteger - HisTermSharedData.PhaANegReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaANegReaEng[i].ULinteger=%d, HisTermSharedData.PhaANegReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaANegReaEng[i].ULinteger, HisTermSharedData.PhaANegReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaANegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaANegReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaANegReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00020200:                          //(B相)组合有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBCmbActEng[i].SLinteger - HisTermSharedData.PhaBCmbActEng[i].SLinteger;
                if (abs(DValue) >= DEAD_ZONE_ENG)
                {
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, result=%d 电量变化值越过死区值\n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, result);
                    break;
                }
            }
        }
            break;

        case 0x00120200:						//(B相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBPosActEng[i].ULinteger - HisTermSharedData.PhaBPosActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBPosActEng[i].ULinteger=%d, HisTermSharedData.PhaBPosActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBPosActEng[i].ULinteger, HisTermSharedData.PhaBPosActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaBPosActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBPosActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaBPosActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00220200:						//(B相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBNegActEng[i].ULinteger - HisTermSharedData.PhaBNegActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBNegActEng[i].ULinteger=%d, HisTermSharedData.PhaBNegActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBNegActEng[i].ULinteger, HisTermSharedData.PhaBNegActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaBNegActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBNegActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaBNegActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00320200:						//(B相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBPosReaEngType[i] != gHisPriMeasurePara.PhaBPosReaEngType[i])
                {
                    gUpdateFlag.bUpdatePhaBPosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaBPosReaEngType[i]=%d, gHisPriMeasurePara.PhaBPosReaEngType[i]=%d, gUpdateFlag.bUpdatePhaBPosReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaBPosReaEngType[i], gHisPriMeasurePara.PhaBPosReaEngType[i], gUpdateFlag.bUpdatePhaBPosReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaBPosReaEng[i].ULinteger - HisTermSharedData.PhaBPosReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBPosReaEng[i].ULinteger=%d, HisTermSharedData.PhaBPosReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBPosReaEng[i].ULinteger, HisTermSharedData.PhaBPosReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaBPosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBPosReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaBPosReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00420200:						//(B相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBNegReaEngType[i] != gHisPriMeasurePara.PhaBNegReaEngType[i])
                {
                    gUpdateFlag.bUpdatePhaBNegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaBNegReaEngType[i]=%d, gHisPriMeasurePara.PhaBNegReaEngType[i]=%d, gUpdateFlag.bUpdatePhaBNegReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaBNegReaEngType[i], gHisPriMeasurePara.PhaBNegReaEngType[i], gUpdateFlag.bUpdatePhaBNegReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaBNegReaEng[i].ULinteger - HisTermSharedData.PhaBNegReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBNegReaEng[i].ULinteger=%d, HisTermSharedData.PhaBNegReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBNegReaEng[i].ULinteger, HisTermSharedData.PhaBNegReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaBNegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBNegReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaBNegReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00030200:                          //(C相)组合有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCCmbActEng[i].SLinteger - HisTermSharedData.PhaCCmbActEng[i].SLinteger;
                if (abs(DValue) >= DEAD_ZONE_ENG)
                {
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, result=%d 电量变化值越过死区值\n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, result);
                    break;
                }
            }
        }
            break;

        case 0x00130200:						//(C相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCPosActEng[i].ULinteger - HisTermSharedData.PhaCPosActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCPosActEng[i].ULinteger=%d, HisTermSharedData.PhaCPosActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCPosActEng[i].ULinteger, HisTermSharedData.PhaCPosActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaCPosActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCPosActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaCPosActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00230200:						//(C相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCNegActEng[i].ULinteger - HisTermSharedData.PhaCNegActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCNegActEng[i].ULinteger=%d, HisTermSharedData.PhaCNegActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCNegActEng[i].ULinteger, HisTermSharedData.PhaCNegActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaCNegActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCNegActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaCNegActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00330200:						//(C相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCPosReaEngType[i] != gHisPriMeasurePara.PhaCPosReaEngType[i])
                {
                    gUpdateFlag.bUpdatePhaCPosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaCPosReaEngType[i]=%d, gHisPriMeasurePara.PhaCPosReaEngType[i]=%d, gUpdateFlag.bUpdatePhaCPosReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaCPosReaEngType[i], gHisPriMeasurePara.PhaCPosReaEngType[i], gUpdateFlag.bUpdatePhaCPosReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaCPosReaEng[i].ULinteger - HisTermSharedData.PhaCPosReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCPosReaEng[i].ULinteger=%d, HisTermSharedData.PhaCPosReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCPosReaEng[i].ULinteger, HisTermSharedData.PhaCPosReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaCPosReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCPosReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaCPosReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00430200:						//(C相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCNegReaEngType[i] != gHisPriMeasurePara.PhaCNegReaEngType[i])
                {
                    gUpdateFlag.bUpdatePhaCNegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaCNegReaEngType[i]=%d, gHisPriMeasurePara.PhaCNegReaEngType[i]=%d, gUpdateFlag.bUpdatePhaCNegReaEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaCNegReaEngType[i], gHisPriMeasurePara.PhaCNegReaEngType[i], gUpdateFlag.bUpdatePhaCNegReaEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaCNegReaEng[i].ULinteger - HisTermSharedData.PhaCNegReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCNegReaEng[i].ULinteger=%d, HisTermSharedData.PhaCNegReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCNegReaEng[i].ULinteger, HisTermSharedData.PhaCNegReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaCNegReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCNegReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaCNegReaEng, result);
                    break;
                }
            }
        }
            break;


        /* 增加 电能 start*/
        case 0x00000200:						//(当前)组合有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.CmbEnergyType[i] != gHisPriMeasurePara.CmbEnergyType[i])
                {
                    gUpdateFlag.bUpdateCmbActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CmbEnergyType[i]=%d, gHisPriMeasurePara.CmbEnergyType[i]=%d, gUpdateFlag.bUpdateCmbActEng=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.CmbEnergyType[i], gHisPriMeasurePara.CmbEnergyType[i], gUpdateFlag.bUpdateCmbActEng, result);
                    break;
                }
                
                int DValue = MidTermSharedData.CmbActEng[i].ULinteger - HisTermSharedData.CmbActEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.CmbActEng[i].ULinteger=%d, HisTermSharedData.CmbActEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.CmbActEng[i].ULinteger, HisTermSharedData.CmbActEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateCmbActEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateCmbActEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateCmbActEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00900200:						//(当前)正向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PosAppEng[i].ULinteger - HisTermSharedData.PosAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PosAppEng[i].ULinteger=%d, HisTermSharedData.PosAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PosAppEng[i].ULinteger, HisTermSharedData.PosAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePosAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePosAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePosAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00A00200:						//(当前)反向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.NegAppEng[i].ULinteger - HisTermSharedData.NegAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.NegAppEng[i].ULinteger=%d, HisTermSharedData.NegAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.NegAppEng[i].ULinteger, HisTermSharedData.NegAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdateNegAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateNegAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdateNegAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00510200:						//A相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA1ReaEng[i].ULinteger - HisTermSharedData.PhaA1ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA1ReaEng[i].ULinteger=%d, HisTermSharedData.PhaA1ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA1ReaEng[i].ULinteger, HisTermSharedData.PhaA1ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaA1ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA1ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaA1ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00520200:						//B相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB1ReaEng[i].ULinteger - HisTermSharedData.PhaB1ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB1ReaEng[i].ULinteger=%d, HisTermSharedData.PhaB1ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB1ReaEng[i].ULinteger, HisTermSharedData.PhaB1ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaB1ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB1ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaB1ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00530200:						//C相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC1ReaEng[i].ULinteger - HisTermSharedData.PhaC1ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC1ReaEng[i].ULinteger=%d, HisTermSharedData.PhaC1ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC1ReaEng[i].ULinteger, HisTermSharedData.PhaC1ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaC1ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC1ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaC1ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00610200:						//A相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA2ReaEng[i].ULinteger - HisTermSharedData.PhaA2ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA2ReaEng[i].ULinteger=%d, HisTermSharedData.PhaA2ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA2ReaEng[i].ULinteger, HisTermSharedData.PhaA2ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaA2ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA2ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaA2ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00620200:						//B相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB2ReaEng[i].ULinteger - HisTermSharedData.PhaB2ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB2ReaEng[i].ULinteger=%d, HisTermSharedData.PhaB2ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB2ReaEng[i].ULinteger, HisTermSharedData.PhaB2ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaB2ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB2ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaB2ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00630200:						//C相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC2ReaEng[i].ULinteger - HisTermSharedData.PhaC2ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC2ReaEng[i].ULinteger=%d, HisTermSharedData.PhaC2ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC2ReaEng[i].ULinteger, HisTermSharedData.PhaC2ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaC2ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC2ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaC2ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00710200:						//A相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA3ReaEng[i].ULinteger - HisTermSharedData.PhaA3ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA3ReaEng[i].ULinteger=%d, HisTermSharedData.PhaA3ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA3ReaEng[i].ULinteger, HisTermSharedData.PhaA3ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaA3ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA3ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaA3ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00720200:						//B相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB3ReaEng[i].ULinteger - HisTermSharedData.PhaB3ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB3ReaEng[i].ULinteger=%d, HisTermSharedData.PhaB3ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB3ReaEng[i].ULinteger, HisTermSharedData.PhaB3ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaB3ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB3ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaB3ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00730200:						//C相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC3ReaEng[i].ULinteger - HisTermSharedData.PhaC3ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC3ReaEng[i].ULinteger=%d, HisTermSharedData.PhaC3ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC3ReaEng[i].ULinteger, HisTermSharedData.PhaC3ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaC3ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC3ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaC3ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00810200:						//A相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA4ReaEng[i].ULinteger - HisTermSharedData.PhaA4ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA4ReaEng[i].ULinteger=%d, HisTermSharedData.PhaA4ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA4ReaEng[i].ULinteger, HisTermSharedData.PhaA4ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaA4ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA4ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaA4ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00820200:						//B相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB4ReaEng[i].ULinteger - HisTermSharedData.PhaB4ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB4ReaEng[i].ULinteger=%d, HisTermSharedData.PhaB4ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB4ReaEng[i].ULinteger, HisTermSharedData.PhaB4ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaB4ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB4ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaB4ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00830200:						//C相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC4ReaEng[i].ULinteger - HisTermSharedData.PhaC4ReaEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC4ReaEng[i].ULinteger=%d, HisTermSharedData.PhaC4ReaEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC4ReaEng[i].ULinteger, HisTermSharedData.PhaC4ReaEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaC4ReaEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC4ReaEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaC4ReaEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00910200:						//A相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaAActAppEng[i].ULinteger - HisTermSharedData.PhaAActAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaAActAppEng[i].ULinteger=%d, HisTermSharedData.PhaAActAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaAActAppEng[i].ULinteger, HisTermSharedData.PhaAActAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaAActAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaAActAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaAActAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00920200:						//B相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBActAppEng[i].ULinteger - HisTermSharedData.PhaBActAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBActAppEng[i].ULinteger=%d, HisTermSharedData.PhaBActAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBActAppEng[i].ULinteger, HisTermSharedData.PhaBActAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaBActAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBActAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaBActAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00930200:						//C相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCActAppEng[i].ULinteger - HisTermSharedData.PhaCActAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCActAppEng[i].ULinteger=%d, HisTermSharedData.PhaCActAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCActAppEng[i].ULinteger, HisTermSharedData.PhaCActAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaCActAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCActAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaCActAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00A10200:						//A 相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaANegAppEng[i].ULinteger - HisTermSharedData.PhaANegAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaANegAppEng[i].ULinteger=%d, HisTermSharedData.PhaANegAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaANegAppEng[i].ULinteger, HisTermSharedData.PhaANegAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaANegAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaANegAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaANegAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00A20200:						//B相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBNegAppEng[i].ULinteger - HisTermSharedData.PhaBNegAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBNegAppEng[i].ULinteger=%d, HisTermSharedData.PhaBNegAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBNegAppEng[i].ULinteger, HisTermSharedData.PhaBNegAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaBNegAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBNegAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaBNegAppEng, result);
                    break;
                }
            }
        }
            break;

        case 0x00A30200:						//C相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCNegAppEng[i].ULinteger - HisTermSharedData.PhaCNegAppEng[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCNegAppEng[i].ULinteger=%d, HisTermSharedData.PhaCNegAppEng[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCNegAppEng[i].ULinteger, HisTermSharedData.PhaCNegAppEng[i].ULinteger, DEAD_ZONE_ENG);
                if(abs(DValue) >= DEAD_ZONE_ENG)
                {
                    gUpdateFlag.bUpdatePhaCNegAppEng = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCNegAppEng=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG, gUpdateFlag.bUpdatePhaCNegAppEng, result);
                    break;
                }
            }
        }
            break;

        /* 增加 电能 end*/

        /***高精度 电能量 begin***/

        case 0x00100400:						//(当前)正向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PosActEngHD[i].ULinteger - HisTermSharedData.PosActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PosActEngHD[i].ULinteger=%d, HisTermSharedData.PosActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PosActEngHD[i].ULinteger, HisTermSharedData.PosActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePosActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePosActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePosActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00200400:						//(当前)反向有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.NegActEngHD[i].ULinteger - HisTermSharedData.NegActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.NegActEngHD[i].ULinteger=%d, HisTermSharedData.NegActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.NegActEngHD[i].ULinteger, HisTermSharedData.NegActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateNegActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateNegActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateNegActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00300400:						//(当前)正向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PosReaEnergyTypeHD[i] != gHisPriMeasurePara.PosReaEnergyTypeHD[i])
                {
                    gUpdateFlag.bUpdatePosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PosReaEnergyTypeHD[i]=%d, gHisPriMeasurePara.PosReaEnergyTypeHD[i]=%d, gUpdateFlag.bUpdatePosReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PosReaEnergyTypeHD[i], gHisPriMeasurePara.PosReaEnergyTypeHD[i], gUpdateFlag.bUpdatePosReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PosReaEngHD[i].ULinteger - HisTermSharedData.PosReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PosReaEngHD[i].ULinteger=%d, HisTermSharedData.PosReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PosReaEngHD[i].ULinteger, HisTermSharedData.PosReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePosReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePosReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00400400:						//(当前)反向无功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.NegReaEnergyTypeHD[i] != gHisPriMeasurePara.NegReaEnergyTypeHD[i])
                {
                    gUpdateFlag.bUpdateNegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.NegReaEnergyTypeHD[i]=%d, gHisPriMeasurePara.NegReaEnergyTypeHD[i]=%d, gUpdateFlag.bUpdateNegReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.NegReaEnergyTypeHD[i], gHisPriMeasurePara.NegReaEnergyTypeHD[i], gUpdateFlag.bUpdateNegReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.NegReaEngHD[i].ULinteger - HisTermSharedData.NegReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.NegReaEngHD[i].ULinteger=%d, HisTermSharedData.NegReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.NegReaEngHD[i].ULinteger, HisTermSharedData.NegReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateNegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateNegReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateNegReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00500400:						//(当前)第一象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad1ReaEngHD[i].ULinteger - HisTermSharedData.Quad1ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad1ReaEngHD[i].ULinteger=%d, HisTermSharedData.Quad1ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad1ReaEngHD[i].ULinteger, HisTermSharedData.Quad1ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateQuad1ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad1ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateQuad1ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00600400:						//(当前)第二象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad2ReaEngHD[i].ULinteger - HisTermSharedData.Quad2ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad2ReaEngHD[i].ULinteger=%d, HisTermSharedData.Quad2ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad2ReaEngHD[i].ULinteger, HisTermSharedData.Quad2ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateQuad2ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad2ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateQuad2ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00700400:						//(当前)第三象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad3ReaEngHD[i].ULinteger - HisTermSharedData.Quad3ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad3ReaEngHD[i].ULinteger=%d, HisTermSharedData.Quad3ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad3ReaEngHD[i].ULinteger, HisTermSharedData.Quad3ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateQuad3ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad3ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateQuad3ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00800400:						//(当前)第四象限无功总尖峰平谷电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.Quad4ReaEngHD[i].ULinteger - HisTermSharedData.Quad4ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.Quad4ReaEngHD[i].ULinteger=%d, HisTermSharedData.Quad4ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.Quad4ReaEngHD[i].ULinteger, HisTermSharedData.Quad4ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateQuad4ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateQuad4ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateQuad4ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00110400:						//(A相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaAPosActEngHD[i].ULinteger - HisTermSharedData.PhaAPosActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaAPosActEngHD[i].ULinteger=%d, HisTermSharedData.PhaAPosActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaAPosActEngHD[i].ULinteger, HisTermSharedData.PhaAPosActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaAPosActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaAPosActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaAPosActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00210400:						//(A相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaANegActEngHD[i].ULinteger - HisTermSharedData.PhaANegActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaANegActEngHD[i].ULinteger=%d, HisTermSharedData.PhaANegActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaANegActEngHD[i].ULinteger, HisTermSharedData.PhaANegActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaANegActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaANegActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaANegActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00310400:						//(A相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaAPosReaEngTypeHD[i] != gHisPriMeasurePara.PhaAPosReaEngTypeHD[i])
                {
                    gUpdateFlag.bUpdatePhaAPosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaAPosReaEngTypeHD[i]=%d, gHisPriMeasurePara.PhaAPosReaEngTypeHD[i]=%d, gUpdateFlag.bUpdatePhaAPosReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaAPosReaEngTypeHD[i], gHisPriMeasurePara.PhaAPosReaEngTypeHD[i], gUpdateFlag.bUpdatePhaAPosReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaAPosReaEngHD[i].ULinteger - HisTermSharedData.PhaAPosReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaAPosReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaAPosReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaAPosReaEngHD[i].ULinteger, HisTermSharedData.PhaAPosReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaAPosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaAPosReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaAPosReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00410400:						//(A相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaANegReaEngTypeHD[i] != gHisPriMeasurePara.PhaANegReaEngTypeHD[i])
                {
                    gUpdateFlag.bUpdatePhaANegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaANegReaEngTypeHD[i]=%d, gHisPriMeasurePara.PhaANegReaEngTypeHD[i]=%d, gUpdateFlag.bUpdatePhaANegReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaANegReaEngTypeHD[i], gHisPriMeasurePara.PhaANegReaEngTypeHD[i], gUpdateFlag.bUpdatePhaANegReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaANegReaEngHD[i].ULinteger - HisTermSharedData.PhaANegReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaANegReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaANegReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaANegReaEngHD[i].ULinteger, HisTermSharedData.PhaANegReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaANegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaANegReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaANegReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00120400:						//(B相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBPosActEngHD[i].ULinteger - HisTermSharedData.PhaBPosActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBPosActEngHD[i].ULinteger=%d, HisTermSharedData.PhaBPosActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBPosActEngHD[i].ULinteger, HisTermSharedData.PhaBPosActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaBPosActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBPosActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaBPosActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00220400:						//(B相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBNegActEngHD[i].ULinteger - HisTermSharedData.PhaBNegActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBNegActEngHD[i].ULinteger=%d, HisTermSharedData.PhaBNegActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBNegActEngHD[i].ULinteger, HisTermSharedData.PhaBNegActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaBNegActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBNegActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaBNegActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00320400:						//(B相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBPosReaEngTypeHD[i] != gHisPriMeasurePara.PhaBPosReaEngTypeHD[i])
                {
                    gUpdateFlag.bUpdatePhaBPosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaBPosReaEngTypeHD[i]=%d, gHisPriMeasurePara.PhaBPosReaEngTypeHD[i]=%d, gUpdateFlag.bUpdatePhaBPosReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaBPosReaEngTypeHD[i], gHisPriMeasurePara.PhaBPosReaEngTypeHD[i], gUpdateFlag.bUpdatePhaBPosReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaBPosReaEngHD[i].ULinteger - HisTermSharedData.PhaBPosReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBPosReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaBPosReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBPosReaEngHD[i].ULinteger, HisTermSharedData.PhaBPosReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaBPosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBPosReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaBPosReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00420400:						//(B相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBNegReaEngTypeHD[i] != gHisPriMeasurePara.PhaBNegReaEngTypeHD[i])
                {
                    gUpdateFlag.bUpdatePhaBNegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaBNegReaEngTypeHD[i]=%d, gHisPriMeasurePara.PhaBNegReaEngTypeHD[i]=%d, gUpdateFlag.bUpdatePhaBNegReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaBNegReaEngTypeHD[i], gHisPriMeasurePara.PhaBNegReaEngTypeHD[i], gUpdateFlag.bUpdatePhaBNegReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaBNegReaEngHD[i].ULinteger - HisTermSharedData.PhaBNegReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBNegReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaBNegReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBNegReaEngHD[i].ULinteger, HisTermSharedData.PhaBNegReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaBNegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBNegReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaBNegReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00130400:						//(C相)正向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCPosActEngHD[i].ULinteger - HisTermSharedData.PhaCPosActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCPosActEngHD[i].ULinteger=%d, HisTermSharedData.PhaCPosActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCPosActEngHD[i].ULinteger, HisTermSharedData.PhaCPosActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaCPosActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCPosActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaCPosActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00230400:						//(C相)反向有功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCNegActEngHD[i].ULinteger - HisTermSharedData.PhaCNegActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCNegActEngHD[i].ULinteger=%d, HisTermSharedData.PhaCNegActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCNegActEngHD[i].ULinteger, HisTermSharedData.PhaCNegActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaCNegActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCNegActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaCNegActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00330400:						//(C相)正向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCPosReaEngTypeHD[i] != gHisPriMeasurePara.PhaCPosReaEngTypeHD[i])
                {
                    gUpdateFlag.bUpdatePhaCPosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaCPosReaEngTypeHD[i]=%d, gHisPriMeasurePara.PhaCPosReaEngTypeHD[i]=%d, gUpdateFlag.bUpdatePhaCPosReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaCPosReaEngTypeHD[i], gHisPriMeasurePara.PhaCPosReaEngTypeHD[i], gUpdateFlag.bUpdatePhaCPosReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaCPosReaEngHD[i].ULinteger - HisTermSharedData.PhaCPosReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCPosReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaCPosReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCPosReaEngHD[i].ULinteger, HisTermSharedData.PhaCPosReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaCPosReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCPosReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaCPosReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00430400:						//(C相)反向无功总电能示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCNegReaEngTypeHD[i] != gHisPriMeasurePara.PhaCNegReaEngTypeHD[i])
                {
                    gUpdateFlag.bUpdatePhaCNegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PhaCNegReaEngTypeHD[i]=%d, gHisPriMeasurePara.PhaCNegReaEngTypeHD[i]=%d, gUpdateFlag.bUpdatePhaCNegReaEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.PhaCNegReaEngTypeHD[i], gHisPriMeasurePara.PhaCNegReaEngTypeHD[i], gUpdateFlag.bUpdatePhaCNegReaEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.PhaCNegReaEngHD[i].ULinteger - HisTermSharedData.PhaCNegReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCNegReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaCNegReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCNegReaEngHD[i].ULinteger, HisTermSharedData.PhaCNegReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaCNegReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCNegReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaCNegReaEngHD, result);
                    break;
                }
            }
        }
            break;


        /* 增加 电能 start*/
        case 0x00000400:						//(当前)组合有功电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.CmbEnergyTypeHD[i] != gHisPriMeasurePara.CmbEnergyTypeHD[i])
                {
                    gUpdateFlag.bUpdateCmbActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CmbEnergyTypeHD[i]=%d, gHisPriMeasurePara.CmbEnergyTypeHD[i]=%d, gUpdateFlag.bUpdateCmbActEngHD=%d, result=%d 电量 方向变位― \n", 
                        nOAD, i, gMidPriMeasurePara.CmbEnergyTypeHD[i], gHisPriMeasurePara.CmbEnergyTypeHD[i], gUpdateFlag.bUpdateCmbActEngHD, result);
                    break;
                }
                
                int DValue = MidTermSharedData.CmbActEngHD[i].ULinteger - HisTermSharedData.CmbActEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.CmbActEngHD[i].ULinteger=%d, HisTermSharedData.CmbActEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.CmbActEngHD[i].ULinteger, HisTermSharedData.CmbActEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateCmbActEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateCmbActEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateCmbActEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00900400:						//(当前)正向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PosAppEngHD[i].ULinteger - HisTermSharedData.PosAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PosAppEngHD[i].ULinteger=%d, HisTermSharedData.PosAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PosAppEngHD[i].ULinteger, HisTermSharedData.PosAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePosAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePosAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePosAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00A00400:						//(当前)反向视在电能总尖峰平谷示值
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.NegAppEngHD[i].ULinteger - HisTermSharedData.NegAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.NegAppEngHD[i].ULinteger=%d, HisTermSharedData.NegAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.NegAppEngHD[i].ULinteger, HisTermSharedData.NegAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdateNegAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdateNegAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdateNegAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00510400:						//A相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA1ReaEngHD[i].ULinteger - HisTermSharedData.PhaA1ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA1ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaA1ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA1ReaEngHD[i].ULinteger, HisTermSharedData.PhaA1ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaA1ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA1ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaA1ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00520400:						//B相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB1ReaEngHD[i].ULinteger - HisTermSharedData.PhaB1ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB1ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaB1ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB1ReaEngHD[i].ULinteger, HisTermSharedData.PhaB1ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaB1ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB1ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaB1ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00530400:						//C相第一象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC1ReaEngHD[i].ULinteger - HisTermSharedData.PhaC1ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC1ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaC1ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC1ReaEngHD[i].ULinteger, HisTermSharedData.PhaC1ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaC1ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC1ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaC1ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00610400:						//A相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA2ReaEngHD[i].ULinteger - HisTermSharedData.PhaA2ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA2ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaA2ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA2ReaEngHD[i].ULinteger, HisTermSharedData.PhaA2ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaA2ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA2ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaA2ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00620400:						//B相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB2ReaEngHD[i].ULinteger - HisTermSharedData.PhaB2ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB2ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaB2ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB2ReaEngHD[i].ULinteger, HisTermSharedData.PhaB2ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaB2ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB2ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaB2ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00630400:						//C相第二象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC2ReaEngHD[i].ULinteger - HisTermSharedData.PhaC2ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC2ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaC2ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC2ReaEngHD[i].ULinteger, HisTermSharedData.PhaC2ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaC2ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC2ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaC2ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00710400:						//A相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA3ReaEngHD[i].ULinteger - HisTermSharedData.PhaA3ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA3ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaA3ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA3ReaEngHD[i].ULinteger, HisTermSharedData.PhaA3ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaA3ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA3ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaA3ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00720400:						//B相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB3ReaEngHD[i].ULinteger - HisTermSharedData.PhaB3ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB3ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaB3ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB3ReaEngHD[i].ULinteger, HisTermSharedData.PhaB3ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaB3ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB3ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaB3ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00730400:						//C相第三象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC3ReaEngHD[i].ULinteger - HisTermSharedData.PhaC3ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC3ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaC3ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC3ReaEngHD[i].ULinteger, HisTermSharedData.PhaC3ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaC3ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC3ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaC3ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00810400:						//A相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaA4ReaEngHD[i].ULinteger - HisTermSharedData.PhaA4ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaA4ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaA4ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaA4ReaEngHD[i].ULinteger, HisTermSharedData.PhaA4ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaA4ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaA4ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaA4ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00820400:						//B相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaB4ReaEngHD[i].ULinteger - HisTermSharedData.PhaB4ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaB4ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaB4ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaB4ReaEngHD[i].ULinteger, HisTermSharedData.PhaB4ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaB4ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaB4ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaB4ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00830400:						//C相第四象限无功电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaC4ReaEngHD[i].ULinteger - HisTermSharedData.PhaC4ReaEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaC4ReaEngHD[i].ULinteger=%d, HisTermSharedData.PhaC4ReaEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaC4ReaEngHD[i].ULinteger, HisTermSharedData.PhaC4ReaEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaC4ReaEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaC4ReaEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaC4ReaEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00910400:						//A相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaAActAppEngHD[i].ULinteger - HisTermSharedData.PhaAActAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaAActAppEngHD[i].ULinteger=%d, HisTermSharedData.PhaAActAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaAActAppEngHD[i].ULinteger, HisTermSharedData.PhaAActAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaAActAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaAActAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaAActAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00920400:						//B相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBActAppEngHD[i].ULinteger - HisTermSharedData.PhaBActAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBActAppEngHD[i].ULinteger=%d, HisTermSharedData.PhaBActAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBActAppEngHD[i].ULinteger, HisTermSharedData.PhaBActAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaBActAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBActAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaBActAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00930400:						//C相正向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCActAppEngHD[i].ULinteger - HisTermSharedData.PhaCActAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCActAppEngHD[i].ULinteger=%d, HisTermSharedData.PhaCActAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCActAppEngHD[i].ULinteger, HisTermSharedData.PhaCActAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaCActAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCActAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaCActAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00A10400:						//A 相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaANegAppEngHD[i].ULinteger - HisTermSharedData.PhaANegAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaANegAppEngHD[i].ULinteger=%d, HisTermSharedData.PhaANegAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaANegAppEngHD[i].ULinteger, HisTermSharedData.PhaANegAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaANegAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaANegAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaANegAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00A20400:						//B相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaBNegAppEngHD[i].ULinteger - HisTermSharedData.PhaBNegAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaBNegAppEngHD[i].ULinteger=%d, HisTermSharedData.PhaBNegAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaBNegAppEngHD[i].ULinteger, HisTermSharedData.PhaBNegAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaBNegAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaBNegAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaBNegAppEngHD, result);
                    break;
                }
            }
        }
            break;

        case 0x00A30400:						//C相反向视在电能
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                int DValue = MidTermSharedData.PhaCNegAppEngHD[i].ULinteger - HisTermSharedData.PhaCNegAppEngHD[i].ULinteger;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, MidTermSharedData.PhaCNegAppEngHD[i].ULinteger=%d, HisTermSharedData.PhaCNegAppEngHD[i].ULinteger=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), MidTermSharedData.PhaCNegAppEngHD[i].ULinteger, HisTermSharedData.PhaCNegAppEngHD[i].ULinteger, DEAD_ZONE_ENG_HD);
                if(abs(DValue) >= DEAD_ZONE_ENG_HD)
                {
                    gUpdateFlag.bUpdatePhaCNegAppEngHD = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, DEAD_ZONE=%d, gUpdateFlag.bUpdatePhaCNegAppEngHD=%d, result=%d 电量 变化值越过死区值― \n", 
                        nOAD, i, abs(DValue), DEAD_ZONE_ENG_HD, gUpdateFlag.bUpdatePhaCNegAppEngHD, result);
                    break;
                }
            }
        }
            break;

        /* 增加 电能 end*/

        /***高精度 电能量 end***/

        case 0x10100200:				//(当前)正向有功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.CurrDemand[0][i].DemNum[0] + 
                    MidTermSharedData.CurrDemand[0][i].DemNum[1]*256 + 
                    MidTermSharedData.CurrDemand[0][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.CurrDemand[0][i].DemNum[0] + 
                    HisTermSharedData.CurrDemand[0][i].DemNum[1]*256 + 
                    HisTermSharedData.CurrDemand[0][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;

                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemand[0][i].DemNum[0], 3, "MidTermSharedData.CurrDemand[0][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemand[0][i].DemNum[0], 3, "HisTermSharedData.CurrDemand[0][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemandTime[0][i].DemTime[0], 6, "MidTermSharedData.CurrDemandTime[0][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemandTime[0][i].DemTime[0], 6, "HisTermSharedData.CurrDemandTime[0][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 正向有功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.CurrDemandTime[0][i].DemTime[0]), &(HisTermSharedData.CurrDemandTime[0][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 正向有功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10200200:                //(当前)反向有功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.CurrDemand[1][i].DemNum[0] + 
                    MidTermSharedData.CurrDemand[1][i].DemNum[1]*256 + 
                    MidTermSharedData.CurrDemand[1][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.CurrDemand[1][i].DemNum[0] + 
                    HisTermSharedData.CurrDemand[1][i].DemNum[1]*256 + 
                    HisTermSharedData.CurrDemand[1][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemand[1][i].DemNum[0], 3, "MidTermSharedData.CurrDemand[1][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemand[1][i].DemNum[0], 3, "HisTermSharedData.CurrDemand[1][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemandTime[1][i].DemTime[0], 6, "MidTermSharedData.CurrDemandTime[1][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemandTime[1][i].DemTime[0], 6, "HisTermSharedData.CurrDemandTime[1][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateNegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 反向有功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.CurrDemandTime[1][i].DemTime[0]), &(HisTermSharedData.CurrDemandTime[1][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateNegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 反向有功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10300200:                //(当前)正向无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.CurrDemand[2][i].DemNum[0] + 
                    MidTermSharedData.CurrDemand[2][i].DemNum[1]*256 + 
                    MidTermSharedData.CurrDemand[2][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.CurrDemand[2][i].DemNum[0] + 
                    HisTermSharedData.CurrDemand[2][i].DemNum[1]*256 + 
                    HisTermSharedData.CurrDemand[2][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemand[2][i].DemNum[0], 3, "MidTermSharedData.CurrDemand[2][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemand[2][i].DemNum[0], 3, "HisTermSharedData.CurrDemand[2][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemandTime[2][i].DemTime[0], 6, "MidTermSharedData.CurrDemandTime[2][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemandTime[2][i].DemTime[0], 6, "HisTermSharedData.CurrDemandTime[2][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 正向无功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.CurrDemandTime[2][i].DemTime[0]), &(HisTermSharedData.CurrDemandTime[2][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 正向无功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10400200:                //(当前)反向无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.CurrDemand[3][i].DemNum[0] + 
                    MidTermSharedData.CurrDemand[3][i].DemNum[1]*256 + 
                    MidTermSharedData.CurrDemand[3][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.CurrDemand[3][i].DemNum[0] + 
                    HisTermSharedData.CurrDemand[3][i].DemNum[1]*256 + 
                    HisTermSharedData.CurrDemand[3][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemand[3][i].DemNum[0], 3, "MidTermSharedData.CurrDemand[3][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemand[3][i].DemNum[0], 3, "HisTermSharedData.CurrDemand[3][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.CurrDemandTime[3][i].DemTime[0], 6, "MidTermSharedData.CurrDemandTime[3][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.CurrDemandTime[3][i].DemTime[0], 6, "HisTermSharedData.CurrDemandTime[3][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateNegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 反向无功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.CurrDemandTime[3][i].DemTime[0]), &(HisTermSharedData.CurrDemandTime[3][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateNegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 反向无功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        /* 增加 需量 begin*/
        case 0x10500200:                //(当前)1象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.QuaDemand[0][i].DemNum[0] + 
                    MidTermSharedData.QuaDemand[0][i].DemNum[1]*256 + 
                    MidTermSharedData.QuaDemand[0][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.QuaDemand[0][i].DemNum[0] + 
                    HisTermSharedData.QuaDemand[0][i].DemNum[1]*256 + 
                    HisTermSharedData.QuaDemand[0][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemand[0][i].DemNum[0], 3, "MidTermSharedData.QuaDemand[0][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemand[0][i].DemNum[0], 3, "HisTermSharedData.QuaDemand[0][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemandTime[0][i].DemTime[0], 6, "MidTermSharedData.QuaDemandTime[0][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemandTime[0][i].DemTime[0], 6, "HisTermSharedData.QuaDemandTime[0][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateQuad1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 1象限无功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.QuaDemandTime[0][i].DemTime[0]), &(HisTermSharedData.QuaDemandTime[0][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateQuad1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 1象限无功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10600200:                //(当前)2象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.QuaDemand[1][i].DemNum[0] + 
                    MidTermSharedData.QuaDemand[1][i].DemNum[1]*256 + 
                    MidTermSharedData.QuaDemand[1][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.QuaDemand[1][i].DemNum[0] + 
                    HisTermSharedData.QuaDemand[1][i].DemNum[1]*256 + 
                    HisTermSharedData.QuaDemand[1][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemand[1][i].DemNum[0], 3, "MidTermSharedData.QuaDemand[1][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemand[1][i].DemNum[0], 3, "HisTermSharedData.QuaDemand[1][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemandTime[1][i].DemTime[0], 6, "MidTermSharedData.QuaDemandTime[1][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemandTime[1][i].DemTime[0], 6, "HisTermSharedData.QuaDemandTime[1][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateQuad2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 2象限无功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.QuaDemandTime[1][i].DemTime[0]), &(HisTermSharedData.QuaDemandTime[1][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateQuad2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 2象限无功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10700200:                //(当前)3象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.QuaDemand[2][i].DemNum[0] + 
                    MidTermSharedData.QuaDemand[2][i].DemNum[1]*256 + 
                    MidTermSharedData.QuaDemand[2][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.QuaDemand[2][i].DemNum[0] + 
                    HisTermSharedData.QuaDemand[2][i].DemNum[1]*256 + 
                    HisTermSharedData.QuaDemand[2][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemand[2][i].DemNum[0], 3, "MidTermSharedData.QuaDemand[2][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemand[2][i].DemNum[0], 3, "HisTermSharedData.QuaDemand[2][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemandTime[2][i].DemTime[0], 6, "MidTermSharedData.QuaDemandTime[2][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemandTime[2][i].DemTime[0], 6, "HisTermSharedData.QuaDemandTime[2][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateQuad3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 3象限无功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.QuaDemandTime[2][i].DemTime[0]), &(HisTermSharedData.QuaDemandTime[2][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateQuad3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 3象限无功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10800200:                //(当前)4象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.QuaDemand[3][i].DemNum[0] + 
                    MidTermSharedData.QuaDemand[3][i].DemNum[1]*256 + 
                    MidTermSharedData.QuaDemand[3][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.QuaDemand[3][i].DemNum[0] + 
                    HisTermSharedData.QuaDemand[3][i].DemNum[1]*256 + 
                    HisTermSharedData.QuaDemand[3][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemand[3][i].DemNum[0], 3, "MidTermSharedData.QuaDemand[3][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemand[3][i].DemNum[0], 3, "HisTermSharedData.QuaDemand[3][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.QuaDemandTime[3][i].DemTime[0], 6, "MidTermSharedData.QuaDemandTime[3][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.QuaDemandTime[3][i].DemTime[0], 6, "HisTermSharedData.QuaDemandTime[3][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateQuad4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 4象限无功总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.QuaDemandTime[3][i].DemTime[0]), &(HisTermSharedData.QuaDemandTime[3][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateQuad4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 4象限无功总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10900200:                //(当前)正向视在电能总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.AppaDemand[0][i].DemNum[0] + 
                    MidTermSharedData.AppaDemand[0][i].DemNum[1]*256 + 
                    MidTermSharedData.AppaDemand[0][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.AppaDemand[0][i].DemNum[0] + 
                    HisTermSharedData.AppaDemand[0][i].DemNum[1]*256 + 
                    HisTermSharedData.AppaDemand[0][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.AppaDemand[0][i].DemNum[0], 3, "MidTermSharedData.AppaDemand[0][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.AppaDemand[0][i].DemNum[0], 3, "HisTermSharedData.AppaDemand[0][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.AppaDemandTime[0][i].DemTime[0], 6, "MidTermSharedData.AppaDemandTime[0][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.AppaDemandTime[0][i].DemTime[0], 6, "HisTermSharedData.AppaDemandTime[0][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePosAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 正向视在电能总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.AppaDemandTime[0][i].DemTime[0]), &(HisTermSharedData.AppaDemandTime[0][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePosAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 正向视在电能总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10A00200:                //(当前)反向视在电能总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                Demand.demand[i].nValue = MidTermSharedData.AppaDemand[1][i].DemNum[0] + 
                    MidTermSharedData.AppaDemand[1][i].DemNum[1]*256 + 
                    MidTermSharedData.AppaDemand[1][i].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.AppaDemand[1][i].DemNum[0] + 
                    HisTermSharedData.AppaDemand[1][i].DemNum[1]*256 + 
                    HisTermSharedData.AppaDemand[1][i].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.AppaDemand[1][i].DemNum[0], 3, "MidTermSharedData.AppaDemand[1][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.AppaDemand[1][i].DemNum[0], 3, "HisTermSharedData.AppaDemand[1][i].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.AppaDemandTime[1][i].DemTime[0], 6, "MidTermSharedData.AppaDemandTime[1][i].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.AppaDemandTime[1][i].DemTime[0], 6, "HisTermSharedData.AppaDemandTime[1][i].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdateNegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d 反向视在电能总尖峰平谷最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.AppaDemandTime[1][i].DemTime[0]), &(HisTermSharedData.AppaDemandTime[1][i].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdateNegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 反向视在电能总尖峰平谷最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        /* 增加 需量 end*/

        /* 增加 分项需量 begin*/
        case 0x10110200:                //(当前)A相 正向有功最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosActDemand[0].DemNum[0] + 
                    MidTermSharedData.PosActDemand[0].DemNum[1]*256 + 
                    MidTermSharedData.PosActDemand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.PosActDemand[0].DemNum[0] + 
                    HisTermSharedData.PosActDemand[0].DemNum[1]*256 + 
                    HisTermSharedData.PosActDemand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.PosActDemand[0].DemNum[0], 3, "MidTermSharedData.PosActDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosActDemand[0].DemNum[0], 3, "HisTermSharedData.PosActDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.PosActDemandTime[0].DemTime[0], 6, "MidTermSharedData.PosActDemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosActDemandTime[0].DemTime[0], 6, "HisTermSharedData.PosActDemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaAPosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 正向有功最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.PosActDemandTime[0].DemTime[0]), &(HisTermSharedData.PosActDemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaAPosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 正向有功最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10120200:                //(当前)B相 正向有功最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosActDemand[1].DemNum[0] + 
                    MidTermSharedData.PosActDemand[1].DemNum[1]*256 + 
                    MidTermSharedData.PosActDemand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.PosActDemand[1].DemNum[0] + 
                    HisTermSharedData.PosActDemand[1].DemNum[1]*256 + 
                    HisTermSharedData.PosActDemand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.PosActDemand[1].DemNum[0], 3, "MidTermSharedData.PosActDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosActDemand[1].DemNum[0], 3, "HisTermSharedData.PosActDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.PosActDemandTime[1].DemTime[0], 6, "MidTermSharedData.PosActDemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosActDemandTime[1].DemTime[0], 6, "HisTermSharedData.PosActDemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaBPosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 正向有功最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.PosActDemandTime[1].DemTime[0]), &(HisTermSharedData.PosActDemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaBPosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 正向有功最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10130200:                //(当前)C相 正向有功最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosActDemand[2].DemNum[0] + 
                    MidTermSharedData.PosActDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.PosActDemand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.PosActDemand[2].DemNum[0] + 
                    HisTermSharedData.PosActDemand[2].DemNum[1]*256 + 
                    HisTermSharedData.PosActDemand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.PosActDemand[2].DemNum[0], 3, "MidTermSharedData.PosActDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosActDemand[2].DemNum[0], 3, "HisTermSharedData.PosActDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.PosActDemandTime[2].DemTime[0], 6, "MidTermSharedData.PosActDemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosActDemandTime[2].DemTime[0], 6, "HisTermSharedData.PosActDemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaCPosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 正向有功最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.PosActDemandTime[2].DemTime[0]), &(HisTermSharedData.PosActDemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaCPosActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 正向有功最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


            case 0x10210200:                //(当前)A相 反向有功最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegActDemand[0].DemNum[0] + 
                    MidTermSharedData.NegActDemand[0].DemNum[1]*256 + 
                    MidTermSharedData.NegActDemand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegActDemand[0].DemNum[0] + 
                    HisTermSharedData.NegActDemand[0].DemNum[1]*256 + 
                    HisTermSharedData.NegActDemand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegActDemand[0].DemNum[0], 3, "MidTermSharedData.NegActDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegActDemand[0].DemNum[0], 3, "HisTermSharedData.NegActDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegActDemandTime[0].DemTime[0], 6, "MidTermSharedData.NegActDemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegActDemandTime[0].DemTime[0], 6, "HisTermSharedData.NegActDemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaANegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 反向有功最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegActDemandTime[0].DemTime[0]), &(HisTermSharedData.NegActDemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaANegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 反向有功最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10220200:                //(当前)B相 反向有功最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegActDemand[1].DemNum[0] + 
                    MidTermSharedData.NegActDemand[1].DemNum[1]*256 + 
                    MidTermSharedData.NegActDemand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegActDemand[1].DemNum[0] + 
                    HisTermSharedData.NegActDemand[1].DemNum[1]*256 + 
                    HisTermSharedData.NegActDemand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegActDemand[1].DemNum[0], 3, "MidTermSharedData.NegActDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegActDemand[1].DemNum[0], 3, "HisTermSharedData.NegActDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegActDemandTime[1].DemTime[0], 6, "MidTermSharedData.NegActDemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegActDemandTime[1].DemTime[0], 6, "HisTermSharedData.NegActDemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaBNegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 反向有功最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegActDemandTime[1].DemTime[0]), &(HisTermSharedData.NegActDemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaBNegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 反向有功最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10230200:                //(当前)C相 反向有功最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegActDemand[2].DemNum[0] + 
                    MidTermSharedData.NegActDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.NegActDemand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegActDemand[2].DemNum[0] + 
                    HisTermSharedData.NegActDemand[2].DemNum[1]*256 + 
                    HisTermSharedData.NegActDemand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegActDemand[2].DemNum[0], 3, "MidTermSharedData.NegActDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegActDemand[2].DemNum[0], 3, "HisTermSharedData.NegActDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegActDemandTime[2].DemTime[0], 6, "MidTermSharedData.NegActDemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegActDemandTime[2].DemTime[0], 6, "HisTermSharedData.NegActDemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaCNegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 反向有功最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegActDemandTime[2].DemTime[0]), &(HisTermSharedData.NegActDemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaCNegActDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 反向有功最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10310200:                //(当前)A相 组合无功1最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosReaDemand[0].DemNum[0] + 
                    MidTermSharedData.PosReaDemand[0].DemNum[1]*256 + 
                    MidTermSharedData.PosReaDemand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.PosReaDemand[0].DemNum[0] + 
                    HisTermSharedData.PosReaDemand[0].DemNum[1]*256 + 
                    HisTermSharedData.PosReaDemand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.PosReaDemand[0].DemNum[0], 3, "MidTermSharedData.PosReaDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosReaDemand[0].DemNum[0], 3, "HisTermSharedData.PosReaDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.PosReaDemandTime[0].DemTime[0], 6, "MidTermSharedData.PosReaDemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosReaDemandTime[0].DemTime[0], 6, "HisTermSharedData.PosReaDemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaAPosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 组合无功1最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.PosReaDemandTime[0].DemTime[0]), &(HisTermSharedData.PosReaDemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaAPosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 组合无功1最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10320200:                //(当前)B相 组合无功1最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosReaDemand[1].DemNum[0] + 
                    MidTermSharedData.PosReaDemand[1].DemNum[1]*256 + 
                    MidTermSharedData.PosReaDemand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.PosReaDemand[1].DemNum[0] + 
                    HisTermSharedData.PosReaDemand[1].DemNum[1]*256 + 
                    HisTermSharedData.PosReaDemand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.PosReaDemand[1].DemNum[0], 3, "MidTermSharedData.PosReaDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosReaDemand[1].DemNum[0], 3, "HisTermSharedData.PosReaDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.PosReaDemandTime[1].DemTime[0], 6, "MidTermSharedData.PosReaDemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosReaDemandTime[1].DemTime[0], 6, "HisTermSharedData.PosReaDemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaBPosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 组合无功1最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.PosReaDemandTime[1].DemTime[0]), &(HisTermSharedData.PosReaDemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaBPosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 组合无功1最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10330200:                //(当前)C相 组合无功1最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosReaDemand[2].DemNum[0] + 
                    MidTermSharedData.PosReaDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.PosReaDemand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.PosReaDemand[2].DemNum[0] + 
                    HisTermSharedData.PosReaDemand[2].DemNum[1]*256 + 
                    HisTermSharedData.PosReaDemand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.PosReaDemand[2].DemNum[0], 3, "MidTermSharedData.PosReaDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosReaDemand[2].DemNum[0], 3, "HisTermSharedData.PosReaDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.PosReaDemandTime[2].DemTime[0], 6, "MidTermSharedData.PosReaDemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.PosReaDemandTime[2].DemTime[0], 6, "HisTermSharedData.PosReaDemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaCPosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 组合无功1最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.PosReaDemandTime[2].DemTime[0]), &(HisTermSharedData.PosReaDemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaCPosReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 组合无功1最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10410200:                //(当前)A相 组合无功2最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegReaDemand[0].DemNum[0] + 
                    MidTermSharedData.NegReaDemand[0].DemNum[1]*256 + 
                    MidTermSharedData.NegReaDemand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegReaDemand[0].DemNum[0] + 
                    HisTermSharedData.NegReaDemand[0].DemNum[1]*256 + 
                    HisTermSharedData.NegReaDemand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegReaDemand[0].DemNum[0], 3, "MidTermSharedData.NegReaDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegReaDemand[0].DemNum[0], 3, "HisTermSharedData.NegReaDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegReaDemandTime[0].DemTime[0], 6, "MidTermSharedData.NegReaDemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegReaDemandTime[0].DemTime[0], 6, "HisTermSharedData.NegReaDemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaANegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 组合无功2最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegReaDemandTime[0].DemTime[0]), &(HisTermSharedData.NegReaDemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaANegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 组合无功2最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10420200:                //(当前)B相 组合无功2最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegReaDemand[1].DemNum[0] + 
                    MidTermSharedData.NegReaDemand[1].DemNum[1]*256 + 
                    MidTermSharedData.NegReaDemand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegReaDemand[1].DemNum[0] + 
                    HisTermSharedData.NegReaDemand[1].DemNum[1]*256 + 
                    HisTermSharedData.NegReaDemand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegReaDemand[1].DemNum[0], 3, "MidTermSharedData.NegReaDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegReaDemand[1].DemNum[0], 3, "HisTermSharedData.NegReaDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegReaDemandTime[1].DemTime[0], 6, "MidTermSharedData.NegReaDemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegReaDemandTime[1].DemTime[0], 6, "HisTermSharedData.NegReaDemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaBNegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 组合无功2最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegReaDemandTime[1].DemTime[0]), &(HisTermSharedData.NegReaDemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaBNegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 组合无功2最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10430200:                //(当前)C相 组合无功2最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegReaDemand[2].DemNum[0] + 
                    MidTermSharedData.NegReaDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.NegReaDemand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegReaDemand[2].DemNum[0] + 
                    HisTermSharedData.NegReaDemand[2].DemNum[1]*256 + 
                    HisTermSharedData.NegReaDemand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegReaDemand[2].DemNum[0], 3, "MidTermSharedData.NegReaDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegReaDemand[2].DemNum[0], 3, "HisTermSharedData.NegReaDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegReaDemandTime[2].DemTime[0], 6, "MidTermSharedData.NegReaDemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegReaDemandTime[2].DemTime[0], 6, "HisTermSharedData.NegReaDemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaCNegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 组合无功2最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegReaDemandTime[2].DemTime[0]), &(HisTermSharedData.NegReaDemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaCNegReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 组合无功2最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10510200:                //(当前)A相 第一象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua1Demand[0].DemNum[0] + 
                    MidTermSharedData.Qua1Demand[0].DemNum[1]*256 + 
                    MidTermSharedData.Qua1Demand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua1Demand[0].DemNum[0] + 
                    HisTermSharedData.Qua1Demand[0].DemNum[1]*256 + 
                    HisTermSharedData.Qua1Demand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua1Demand[0].DemNum[0], 3, "MidTermSharedData.Qua1Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua1Demand[0].DemNum[0], 3, "HisTermSharedData.Qua1Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua1DemandTime[0].DemTime[0], 6, "MidTermSharedData.Qua1DemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua1DemandTime[0].DemTime[0], 6, "HisTermSharedData.Qua1DemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaA1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 第一象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua1DemandTime[0].DemTime[0]), &(HisTermSharedData.Qua1DemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaA1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 第一象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10520200:                //(当前)B相 第一象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua1Demand[1].DemNum[0] + 
                    MidTermSharedData.Qua1Demand[1].DemNum[1]*256 + 
                    MidTermSharedData.Qua1Demand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua1Demand[1].DemNum[0] + 
                    HisTermSharedData.Qua1Demand[1].DemNum[1]*256 + 
                    HisTermSharedData.Qua1Demand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua1Demand[1].DemNum[0], 3, "MidTermSharedData.Qua1Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua1Demand[1].DemNum[0], 3, "HisTermSharedData.Qua1Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua1DemandTime[1].DemTime[0], 6, "MidTermSharedData.Qua1DemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua1DemandTime[1].DemTime[0], 6, "HisTermSharedData.Qua1DemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaB1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 第一象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua1DemandTime[1].DemTime[0]), &(HisTermSharedData.Qua1DemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaB1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 第一象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10530200:                //(当前)C相 第一象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua1Demand[2].DemNum[0] + 
                    MidTermSharedData.Qua1Demand[2].DemNum[1]*256 + 
                    MidTermSharedData.Qua1Demand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua1Demand[2].DemNum[0] + 
                    HisTermSharedData.Qua1Demand[2].DemNum[1]*256 + 
                    HisTermSharedData.Qua1Demand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua1Demand[2].DemNum[0], 3, "MidTermSharedData.Qua1Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua1Demand[2].DemNum[0], 3, "HisTermSharedData.Qua1Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua1DemandTime[2].DemTime[0], 6, "MidTermSharedData.Qua1DemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua1DemandTime[2].DemTime[0], 6, "HisTermSharedData.Qua1DemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaC1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 第一象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua1DemandTime[2].DemTime[0]), &(HisTermSharedData.Qua1DemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaC1ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 第一象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10610200:                //(当前)A相 第二象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua2Demand[0].DemNum[0] + 
                    MidTermSharedData.Qua2Demand[0].DemNum[1]*256 + 
                    MidTermSharedData.Qua2Demand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua2Demand[0].DemNum[0] + 
                    HisTermSharedData.Qua2Demand[0].DemNum[1]*256 + 
                    HisTermSharedData.Qua2Demand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua2Demand[0].DemNum[0], 3, "MidTermSharedData.Qua2Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua2Demand[0].DemNum[0], 3, "HisTermSharedData.Qua2Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua2DemandTime[0].DemTime[0], 6, "MidTermSharedData.Qua2DemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua2DemandTime[0].DemTime[0], 6, "HisTermSharedData.Qua2DemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaA2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 第二象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua2DemandTime[0].DemTime[0]), &(HisTermSharedData.Qua2DemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaA2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 第二象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }

        }
            break;

        case 0x10620200:                //(当前)B相 第二象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua2Demand[1].DemNum[0] + 
                    MidTermSharedData.Qua2Demand[1].DemNum[1]*256 + 
                    MidTermSharedData.Qua2Demand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua2Demand[1].DemNum[0] + 
                    HisTermSharedData.Qua2Demand[1].DemNum[1]*256 + 
                    HisTermSharedData.Qua2Demand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua2Demand[1].DemNum[0], 3, "MidTermSharedData.Qua2Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua2Demand[1].DemNum[0], 3, "HisTermSharedData.Qua2Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua2DemandTime[1].DemTime[0], 6, "MidTermSharedData.Qua2DemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua2DemandTime[1].DemTime[0], 6, "HisTermSharedData.Qua2DemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaB2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 第二象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua2DemandTime[1].DemTime[0]), &(HisTermSharedData.Qua2DemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaB2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 第二象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10630200:                //(当前)C相 第二象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua2Demand[2].DemNum[0] + 
                    MidTermSharedData.Qua2Demand[2].DemNum[1]*256 + 
                    MidTermSharedData.Qua2Demand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua2Demand[2].DemNum[0] + 
                    HisTermSharedData.Qua2Demand[2].DemNum[1]*256 + 
                    HisTermSharedData.Qua2Demand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua2Demand[2].DemNum[0], 3, "MidTermSharedData.Qua2Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua2Demand[2].DemNum[0], 3, "HisTermSharedData.Qua2Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua2DemandTime[2].DemTime[0], 6, "MidTermSharedData.Qua2DemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua2DemandTime[2].DemTime[0], 6, "HisTermSharedData.Qua2DemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaC2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 第二象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua2DemandTime[2].DemTime[0]), &(HisTermSharedData.Qua2DemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaC2ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 第二象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10710200:                //(当前)A相 第三象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua3Demand[0].DemNum[0] + 
                    MidTermSharedData.Qua3Demand[0].DemNum[1]*256 + 
                    MidTermSharedData.Qua3Demand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua3Demand[0].DemNum[0] + 
                    HisTermSharedData.Qua3Demand[0].DemNum[1]*256 + 
                    HisTermSharedData.Qua3Demand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua3Demand[0].DemNum[0], 3, "MidTermSharedData.Qua3Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua3Demand[0].DemNum[0], 3, "HisTermSharedData.Qua3Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua3DemandTime[0].DemTime[0], 6, "MidTermSharedData.Qua3DemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua3DemandTime[0].DemTime[0], 6, "HisTermSharedData.Qua3DemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaA3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 第三象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua3DemandTime[0].DemTime[0]), &(HisTermSharedData.Qua3DemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaA3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 第三象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10720200:                //(当前)B相 第三象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua3Demand[1].DemNum[0] + 
                    MidTermSharedData.Qua3Demand[1].DemNum[1]*256 + 
                    MidTermSharedData.Qua3Demand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua3Demand[1].DemNum[0] + 
                    HisTermSharedData.Qua3Demand[1].DemNum[1]*256 + 
                    HisTermSharedData.Qua3Demand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua3Demand[1].DemNum[0], 3, "MidTermSharedData.Qua3Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua3Demand[1].DemNum[0], 3, "HisTermSharedData.Qua3Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua3DemandTime[1].DemTime[0], 6, "MidTermSharedData.Qua3DemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua3DemandTime[1].DemTime[0], 6, "HisTermSharedData.Qua3DemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaB3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 第三象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua3DemandTime[1].DemTime[0]), &(HisTermSharedData.Qua3DemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaB3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 第三象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10730200:                //(当前)C相 第三象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua3Demand[2].DemNum[0] + 
                    MidTermSharedData.Qua3Demand[2].DemNum[1]*256 + 
                    MidTermSharedData.Qua3Demand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua3Demand[2].DemNum[0] + 
                    HisTermSharedData.Qua3Demand[2].DemNum[1]*256 + 
                    HisTermSharedData.Qua3Demand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua3Demand[2].DemNum[0], 3, "MidTermSharedData.Qua3Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua3Demand[2].DemNum[0], 3, "HisTermSharedData.Qua3Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua3DemandTime[2].DemTime[0], 6, "MidTermSharedData.Qua3DemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua3DemandTime[2].DemTime[0], 6, "HisTermSharedData.Qua3DemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaC3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 第三象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua3DemandTime[2].DemTime[0]), &(HisTermSharedData.Qua3DemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaC3ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 第三象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10810200:                //(当前)A相 第四象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua4Demand[0].DemNum[0] + 
                    MidTermSharedData.Qua4Demand[0].DemNum[1]*256 + 
                    MidTermSharedData.Qua4Demand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua4Demand[0].DemNum[0] + 
                    HisTermSharedData.Qua4Demand[0].DemNum[1]*256 + 
                    HisTermSharedData.Qua4Demand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua4Demand[0].DemNum[0], 3, "MidTermSharedData.Qua4Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua4Demand[0].DemNum[0], 3, "HisTermSharedData.Qua4Demand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua4DemandTime[0].DemTime[0], 6, "MidTermSharedData.Qua4DemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua4DemandTime[0].DemTime[0], 6, "HisTermSharedData.Qua4DemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaA4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 第四象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua4DemandTime[0].DemTime[0]), &(HisTermSharedData.Qua4DemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaA4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 第四象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10820200:                //(当前)B相 第四象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua4Demand[1].DemNum[0] + 
                    MidTermSharedData.Qua4Demand[1].DemNum[1]*256 + 
                    MidTermSharedData.Qua4Demand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua4Demand[1].DemNum[0] + 
                    HisTermSharedData.Qua4Demand[1].DemNum[1]*256 + 
                    HisTermSharedData.Qua4Demand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua4Demand[1].DemNum[0], 3, "MidTermSharedData.Qua4Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua4Demand[1].DemNum[0], 3, "HisTermSharedData.Qua4Demand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua4DemandTime[1].DemTime[0], 6, "MidTermSharedData.Qua4DemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua4DemandTime[1].DemTime[0], 6, "HisTermSharedData.Qua4DemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaB4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 第四象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua4DemandTime[1].DemTime[0]), &(HisTermSharedData.Qua4DemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaB4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 第四象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10830200:                //(当前)C相 第四象限最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.Qua4Demand[2].DemNum[0] + 
                    MidTermSharedData.Qua4Demand[2].DemNum[1]*256 + 
                    MidTermSharedData.Qua4Demand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.Qua4Demand[2].DemNum[0] + 
                    HisTermSharedData.Qua4Demand[2].DemNum[1]*256 + 
                    HisTermSharedData.Qua4Demand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua4Demand[2].DemNum[0], 3, "MidTermSharedData.Qua4Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua4Demand[2].DemNum[0], 3, "HisTermSharedData.Qua4Demand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.Qua4DemandTime[2].DemTime[0], 6, "MidTermSharedData.Qua4DemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.Qua4DemandTime[2].DemTime[0], 6, "HisTermSharedData.Qua4DemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaC4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 第四象限最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.Qua4DemandTime[2].DemTime[0]), &(HisTermSharedData.Qua4DemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaC4ReaDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 第四象限最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10910200:                //(当前)A相 正向视在最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.ActAppDemand[0].DemNum[0] + 
                    MidTermSharedData.ActAppDemand[0].DemNum[1]*256 + 
                    MidTermSharedData.ActAppDemand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.ActAppDemand[0].DemNum[0] + 
                    HisTermSharedData.ActAppDemand[0].DemNum[1]*256 + 
                    HisTermSharedData.ActAppDemand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.ActAppDemand[0].DemNum[0], 3, "MidTermSharedData.ActAppDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.ActAppDemand[0].DemNum[0], 3, "HisTermSharedData.ActAppDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.ActAppDemandTime[0].DemTime[0], 6, "MidTermSharedData.ActAppDemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.ActAppDemandTime[0].DemTime[0], 6, "HisTermSharedData.ActAppDemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaAActAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 正向视在最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.ActAppDemandTime[0].DemTime[0]), &(HisTermSharedData.ActAppDemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaAActAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 正向视在最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10920200:                //(当前)B相 正向视在最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.ActAppDemand[1].DemNum[0] + 
                    MidTermSharedData.ActAppDemand[1].DemNum[1]*256 + 
                    MidTermSharedData.ActAppDemand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.ActAppDemand[1].DemNum[0] + 
                    HisTermSharedData.ActAppDemand[1].DemNum[1]*256 + 
                    HisTermSharedData.ActAppDemand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.ActAppDemand[1].DemNum[0], 3, "MidTermSharedData.ActAppDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.ActAppDemand[1].DemNum[0], 3, "HisTermSharedData.ActAppDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.ActAppDemandTime[1].DemTime[0], 6, "MidTermSharedData.ActAppDemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.ActAppDemandTime[1].DemTime[0], 6, "HisTermSharedData.ActAppDemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaBActAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 正向视在最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.ActAppDemandTime[1].DemTime[0]), &(HisTermSharedData.ActAppDemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaBActAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 正向视在最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10930200:                //(当前)C相 正向视在最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.ActAppDemand[2].DemNum[0] + 
                    MidTermSharedData.ActAppDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.ActAppDemand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.ActAppDemand[2].DemNum[0] + 
                    HisTermSharedData.ActAppDemand[2].DemNum[1]*256 + 
                    HisTermSharedData.ActAppDemand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.ActAppDemand[2].DemNum[0], 3, "MidTermSharedData.ActAppDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.ActAppDemand[2].DemNum[0], 3, "HisTermSharedData.ActAppDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.ActAppDemandTime[2].DemTime[0], 6, "MidTermSharedData.ActAppDemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.ActAppDemandTime[2].DemTime[0], 6, "HisTermSharedData.ActAppDemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaCActAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 正向视在最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.ActAppDemandTime[2].DemTime[0]), &(HisTermSharedData.ActAppDemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaCActAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 正向视在最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;


        case 0x10A10200:                //(当前)A相 反向视在最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegAppDemand[0].DemNum[0] + 
                    MidTermSharedData.NegAppDemand[0].DemNum[1]*256 + 
                    MidTermSharedData.NegAppDemand[0].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegAppDemand[0].DemNum[0] + 
                    HisTermSharedData.NegAppDemand[0].DemNum[1]*256 + 
                    HisTermSharedData.NegAppDemand[0].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegAppDemand[0].DemNum[0], 3, "MidTermSharedData.NegAppDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegAppDemand[0].DemNum[0], 3, "HisTermSharedData.NegAppDemand[0].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegAppDemandTime[0].DemTime[0], 6, "MidTermSharedData.NegAppDemandTime[0].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegAppDemandTime[0].DemTime[0], 6, "HisTermSharedData.NegAppDemandTime[0].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaANegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d A相 反向视在最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegAppDemandTime[0].DemTime[0]), &(HisTermSharedData.NegAppDemandTime[0].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaANegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 反向视在最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10A20200:                //(当前)B相 反向视在最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegAppDemand[1].DemNum[0] + 
                    MidTermSharedData.NegAppDemand[1].DemNum[1]*256 + 
                    MidTermSharedData.NegAppDemand[1].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegAppDemand[1].DemNum[0] + 
                    HisTermSharedData.NegAppDemand[1].DemNum[1]*256 + 
                    HisTermSharedData.NegAppDemand[1].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegAppDemand[1].DemNum[0], 3, "MidTermSharedData.NegAppDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegAppDemand[1].DemNum[0], 3, "HisTermSharedData.NegAppDemand[1].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegAppDemandTime[1].DemTime[0], 6, "MidTermSharedData.NegAppDemandTime[1].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegAppDemandTime[1].DemTime[0], 6, "HisTermSharedData.NegAppDemandTime[1].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaBNegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d B相 反向视在最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegAppDemandTime[1].DemTime[0]), &(HisTermSharedData.NegAppDemandTime[1].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaBNegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 反向视在最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x10A30200:                //(当前)C相 反向视在最大需量
        {
            OOP_DEMAND_T Demand;
            OOP_DEMAND_T HisDemand;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            memset((uint8*)&HisDemand,0x00,sizeof(OOP_DEMAND_T));
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.NegAppDemand[2].DemNum[0] + 
                    MidTermSharedData.NegAppDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.NegAppDemand[2].DemNum[2]*256*256;
                HisDemand.demand[i].nValue = HisTermSharedData.NegAppDemand[2].DemNum[0] + 
                    HisTermSharedData.NegAppDemand[2].DemNum[1]*256 + 
                    HisTermSharedData.NegAppDemand[2].DemNum[2]*256*256;

                int DValue = Demand.demand[i].nValue - HisDemand.demand[i].nValue;
                
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, Demand.demand[i].nValue=%d, HisDemand.demand[i].nValue=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, DValue, abs(DValue), Demand.demand[i].nValue, HisDemand.demand[i].nValue, DEAD_ZONE_DMD);
                ACDB_BUF_LOGCC(&MidTermSharedData.NegAppDemand[2].DemNum[0], 3, "MidTermSharedData.NegAppDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegAppDemand[2].DemNum[0], 3, "HisTermSharedData.NegAppDemand[2].DemNum[0]:");
                ACDB_BUF_LOGCC(&MidTermSharedData.NegAppDemandTime[2].DemTime[0], 6, "MidTermSharedData.NegAppDemandTime[2].DemTime[0]:");
                ACDB_BUF_LOGCC(&HisTermSharedData.NegAppDemandTime[2].DemTime[0], 6, "HisTermSharedData.NegAppDemandTime[2].DemTime[0]:");
                
                if(abs(DValue) >= DEAD_ZONE_DMD)
                {
                    gUpdateFlag.bUpdatePhaCNegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, DValue=%d, abs(DValue)=%d, DEAD_ZONE=%d C相 反向视在最大需量 变化值越过死区值! \n", 
                        nOAD, i, DValue, abs(DValue), DEAD_ZONE_DMD);
                    break;
                }
                else if(memcmp(&(MidTermSharedData.NegAppDemandTime[2].DemTime[0]), &(HisTermSharedData.NegAppDemandTime[2].DemTime[0]), 6) != 0)
                {
                    gUpdateFlag.bUpdatePhaCNegAppDmd = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 反向视在最大需量 时间变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        /* 增加 分项需量 end*/
            

        case 0x20040200:						//(当前)瞬时有功功率
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.ActPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.ActPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.ActPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.ActPowFlag);
                    if(gMidPriMeasurePara.CurPowDir.BitSect.ActPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.ActPowFlag)
                    {
                        gUpdateFlag.bUpdateActPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 有功功率ActPowFlag 方向变化! \n", nOAD, i);
                        break;
                    }
                    
                    if(gMidPriMeasurePara.CurPowDir.BitSect.ActPowFlag == 1)
                    {
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.NegActPower=%d, HisTermSharedData.NegActPower=%d, DEAD_ZONE=%d \n", 
                            nOAD, i, abs(MidTermSharedData.NegActPower - HisTermSharedData.NegActPower), MidTermSharedData.NegActPower, HisTermSharedData.NegActPower, DEAD_ZONE_POWER);
                        if(abs(MidTermSharedData.NegActPower - HisTermSharedData.NegActPower) >= DEAD_ZONE_POWER)
                        {
                            gUpdateFlag.bUpdateActPower = 1;
                            result = 1;
                            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 有功功率NegActPower 变化! \n", nOAD, i);
                            break;
                        }
                    }
                    else
                    {
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PosActPower=%d, HisTermSharedData.PosActPower=%d, DEAD_ZONE=%d \n", 
                            nOAD, i, abs(MidTermSharedData.PosActPower - HisTermSharedData.PosActPower), MidTermSharedData.PosActPower, HisTermSharedData.PosActPower, DEAD_ZONE_POWER);
                        if(abs(MidTermSharedData.PosActPower - HisTermSharedData.PosActPower) >= DEAD_ZONE_POWER)
                        {
                            gUpdateFlag.bUpdateActPower = 1;
                            result = 1;
                            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 有功功率NegActPower 变化! \n", nOAD, i);
                            break;
                        }
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAActPower=%d, HisTermSharedData.PhaAActPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAActPower - HisTermSharedData.PhaAActPower), MidTermSharedData.PhaAActPower, HisTermSharedData.PhaAActPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag)
                        || (abs(MidTermSharedData.PhaAActPower - HisTermSharedData.PhaAActPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateActPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 有功功率 PhaAActPowFlag 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBActPower=%d, HisTermSharedData.PhaBActPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBActPower - HisTermSharedData.PhaBActPower), MidTermSharedData.PhaBActPower, HisTermSharedData.PhaBActPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag)
                        || (abs(MidTermSharedData.PhaBActPower - HisTermSharedData.PhaBActPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateActPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 有功功率 PhaBActPower 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 3)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCActPower=%d, HisTermSharedData.PhaCActPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCActPower - HisTermSharedData.PhaCActPower), MidTermSharedData.PhaCActPower, HisTermSharedData.PhaCActPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag)
                        || (abs(MidTermSharedData.PhaCActPower - HisTermSharedData.PhaCActPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateActPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 有功功率 PhaCActPower 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20050200:			   //(当前)瞬时无功功率
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.ReaPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.ReaPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.ReaPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.ReaPowFlag);
                    if(gMidPriMeasurePara.CurPowDir.BitSect.ReaPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.ReaPowFlag)
                    {
                        gUpdateFlag.bUpdateReaPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 无功功率 ReaPowFlag 方向变化! \n", nOAD, i);
                        break;
                    }
                    
                    if(gMidPriMeasurePara.CurPowDir.BitSect.ReaPowFlag == 1)
                    {
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.NegReaPower=%d, HisTermSharedData.NegReaPower=%d, DEAD_ZONE=%d \n", 
                            nOAD, i, abs(MidTermSharedData.NegReaPower - HisTermSharedData.NegReaPower), MidTermSharedData.NegReaPower, HisTermSharedData.NegReaPower, DEAD_ZONE_POWER);
                        if(abs(MidTermSharedData.NegReaPower - HisTermSharedData.NegReaPower) >= DEAD_ZONE_POWER)
                        {
                            gUpdateFlag.bUpdateReaPower = 1;
                            result = 1;
                            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 无功功率 NegReaPower 变化! \n", nOAD, i);
                            break;
                        }
                    }
                    else
                    {
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PosReaPower=%d, HisTermSharedData.PosReaPower=%d, DEAD_ZONE=%d \n", 
                            nOAD, i, abs(MidTermSharedData.PosReaPower - HisTermSharedData.PosReaPower), MidTermSharedData.PosReaPower, HisTermSharedData.PosReaPower, DEAD_ZONE_POWER);
                        if(abs(MidTermSharedData.PosReaPower - HisTermSharedData.PosReaPower) >= DEAD_ZONE_POWER)
                        {
                            gUpdateFlag.bUpdateReaPower = 1;
                            result = 1;
                            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 无功功率 PosReaPower 变化! \n", nOAD, i);
                            break;
                        }
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAReaPower=%d, HisTermSharedData.PhaAReaPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAReaPower - HisTermSharedData.PhaAReaPower), MidTermSharedData.PhaAReaPower, HisTermSharedData.PhaAReaPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag)
                        || (abs(MidTermSharedData.PhaAReaPower - HisTermSharedData.PhaAReaPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateReaPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 无功功率 PhaAReaPower 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBReaPower=%d, HisTermSharedData.PhaBReaPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBReaPower - HisTermSharedData.PhaBReaPower), MidTermSharedData.PhaBReaPower, HisTermSharedData.PhaBReaPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag)
                        || (abs(MidTermSharedData.PhaBReaPower - HisTermSharedData.PhaBReaPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateReaPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 无功功率 PhaBReaPower 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 3)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCReaPower=%d, HisTermSharedData.PhaCReaPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCReaPower - HisTermSharedData.PhaCReaPower), MidTermSharedData.PhaCReaPower, HisTermSharedData.PhaCActPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag)
                        || (abs(MidTermSharedData.PhaCReaPower - HisTermSharedData.PhaCReaPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateReaPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 无功功率 PhaCReaPower 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        /* 增加	视在功率 begin*/
        case 0x20060200:						//(当前)瞬时视在功率
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.AppPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.AppPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.AppPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.AppPowFlag);
                    if(gMidPriMeasurePara.CurPowDir.BitSect.AppPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.AppPowFlag)
                    {
                        gUpdateFlag.bUpdateAppPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 视在功率 AppPowFlag 方向变化! \n", nOAD, i);
                        break;
                    }
                    
                    if(gMidPriMeasurePara.CurPowDir.BitSect.AppPowFlag == 1)
                    {
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.NegApparentPower=%d, HisTermSharedData.NegApparentPower=%d, DEAD_ZONE=%d \n", 
                            nOAD, i, abs(MidTermSharedData.NegApparentPower - HisTermSharedData.NegApparentPower), MidTermSharedData.NegApparentPower, HisTermSharedData.NegApparentPower, DEAD_ZONE_POWER);
                        if(abs(MidTermSharedData.NegApparentPower - HisTermSharedData.NegApparentPower) >= DEAD_ZONE_POWER)
                        {
                            gUpdateFlag.bUpdateAppPower = 1;
                            result = 1;
                            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 视在功率 NegApparentPower 变化! \n", nOAD, i);
                            break;
                        }
                    }
                    else
                    {
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PosApparentPower=%d, HisTermSharedData.PosApparentPower=%d, DEAD_ZONE=%d \n", 
                            nOAD, i, abs(MidTermSharedData.PosApparentPower - HisTermSharedData.PosApparentPower), MidTermSharedData.PosApparentPower, HisTermSharedData.PosApparentPower, DEAD_ZONE_POWER);
                        if(abs(MidTermSharedData.PosApparentPower - HisTermSharedData.PosApparentPower) >= DEAD_ZONE_POWER)
                        {
                            gUpdateFlag.bUpdateAppPower = 1;
                            result = 1;
                            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 视在功率 PosApparentPower 变化! \n", nOAD, i);
                            break;
                        }
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAAppPower=%d, HisTermSharedData.PhaAAppPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAAppPower - HisTermSharedData.PhaAAppPower), MidTermSharedData.PhaAAppPower, HisTermSharedData.PhaAAppPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag)
                        || (abs(MidTermSharedData.PhaAAppPower - HisTermSharedData.PhaAAppPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateAppPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 视在功率 PhaAAppPower 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBAppPower=%d, HisTermSharedData.PhaBAppPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBAppPower - HisTermSharedData.PhaBAppPower), MidTermSharedData.PhaBAppPower, HisTermSharedData.PhaBAppPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag)
                        || (abs(MidTermSharedData.PhaBAppPower - HisTermSharedData.PhaBAppPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateAppPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 视在功率 PhaBAppPower 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 3)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag:%d, gHisPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag, gHisPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCAppPower=%d, HisTermSharedData.PhaCAppPower=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCAppPower - HisTermSharedData.PhaCAppPower), MidTermSharedData.PhaCAppPower, HisTermSharedData.PhaCAppPower, DEAD_ZONE_POWER);
                    if((gMidPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag != gHisPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag)
                        || (abs(MidTermSharedData.PhaCAppPower - HisTermSharedData.PhaCAppPower) >= DEAD_ZONE_POWER))
                    {
                        gUpdateFlag.bUpdateAppPower = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 视在功率 PhaCAppPower 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        /* 增加	视在功率 end*/

        case 0x20000200:			   //(当前)三相电压
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAVolt=%d, HisTermSharedData.PhaAVolt=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAVolt - HisTermSharedData.PhaAVolt), MidTermSharedData.PhaAVolt, HisTermSharedData.PhaAVolt, DEAD_ZONE_VOLT);
                    if(abs(MidTermSharedData.PhaAVolt - HisTermSharedData.PhaAVolt) >= DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateVolt = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电压 PhaAVolt 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBVolt=%d, HisTermSharedData.PhaBVolt=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBVolt - HisTermSharedData.PhaBVolt), MidTermSharedData.PhaBVolt, HisTermSharedData.PhaBVolt, DEAD_ZONE_VOLT);
                    if(abs(MidTermSharedData.PhaBVolt - HisTermSharedData.PhaBVolt) >= DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateVolt = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电压 PhaBVolt 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCVolt=%d, HisTermSharedData.PhaCVolt=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCVolt - HisTermSharedData.PhaCVolt), MidTermSharedData.PhaCVolt, HisTermSharedData.PhaCVolt, DEAD_ZONE_VOLT);
                    if(abs(MidTermSharedData.PhaCVolt - HisTermSharedData.PhaCVolt) >= DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateVolt = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电压 PhaCVolt 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20000400:			   //(当前)三相电压
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for (i = 0; i < nNum; i++)
            {
                if (i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAVoltHD=%d, HisTermSharedData.PhaAVoltHD=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAVoltHD - HisTermSharedData.PhaAVoltHD), MidTermSharedData.PhaAVoltHD, HisTermSharedData.PhaAVoltHD, 10 * DEAD_ZONE_VOLT);
                    if (abs(MidTermSharedData.PhaAVoltHD - HisTermSharedData.PhaAVoltHD) >= 10 * DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateVoltHD = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电压 PhaAVoltHD 变化! \n", nOAD, i);
                        break;
                    }
                }
                if (i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBVoltHD=%d, HisTermSharedData.PhaBVoltHD=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBVoltHD - HisTermSharedData.PhaBVoltHD), MidTermSharedData.PhaBVoltHD, HisTermSharedData.PhaBVoltHD, 10 * DEAD_ZONE_VOLT);
                    if (abs(MidTermSharedData.PhaBVoltHD - HisTermSharedData.PhaBVoltHD) >= 10 * DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateVoltHD = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电压 PhaBVoltHD 变化! \n", nOAD, i);
                        break;
                    }
                }
                if (i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCVoltHD=%d, HisTermSharedData.PhaCVoltHD=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCVoltHD - HisTermSharedData.PhaCVoltHD), MidTermSharedData.PhaCVoltHD, HisTermSharedData.PhaCVoltHD, 10 * DEAD_ZONE_VOLT);
                    if (abs(MidTermSharedData.PhaCVoltHD - HisTermSharedData.PhaCVoltHD) >= 10 * DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateVoltHD = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电压 PhaCVoltHD 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20000600:			   //(当前)零序电压
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaZeroVolt=%d, HisTermSharedData.PhaZeroVolt=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaZeroVolt - HisTermSharedData.PhaZeroVolt), MidTermSharedData.PhaZeroVolt, HisTermSharedData.PhaZeroVolt, DEAD_ZONE_VOLT);
                    if(abs(MidTermSharedData.PhaZeroVolt - HisTermSharedData.PhaZeroVolt) >= DEAD_ZONE_VOLT)
                    {
                        gUpdateFlag.bUpdateZeroVolt = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 零序电压 PhaZeroVolt 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20010200:						//(当前)三相电流
        {
            //nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            nNum = 3;  //目前只使用前3个数据项, 手动填3
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag:%d, gHisPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag, gHisPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaACurr=%d, HisTermSharedData.PhaACurr=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaACurr - HisTermSharedData.PhaACurr), MidTermSharedData.PhaACurr, HisTermSharedData.PhaACurr, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag != gHisPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag)
                        || (abs(MidTermSharedData.PhaACurr - HisTermSharedData.PhaACurr) >= DEAD_ZONE_CURR))
                    {
                        gUpdateFlag.bUpdateCurr = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电流 方向 PhaAAppCurrentFlag 或 数值 PhaACurr 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag:%d, gHisPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag, gHisPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBCurr=%d, HisTermSharedData.PhaBCurr=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBCurr - HisTermSharedData.PhaBCurr), MidTermSharedData.PhaBCurr, HisTermSharedData.PhaBCurr, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag != gHisPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag)
                        || (abs(MidTermSharedData.PhaBCurr - HisTermSharedData.PhaBCurr) >= DEAD_ZONE_CURR))
                    {
                        gUpdateFlag.bUpdateCurr = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电流 方向 PhaBAppCurrentFlag 或 数值 PhaBCurr 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag:%d, gHisPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag, gHisPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCCurr=%d, HisTermSharedData.PhaCCurr=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCCurr - HisTermSharedData.PhaCCurr), MidTermSharedData.PhaCCurr, HisTermSharedData.PhaCCurr, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag != gHisPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag)
                        || (abs(MidTermSharedData.PhaCCurr - HisTermSharedData.PhaCCurr) >= DEAD_ZONE_CURR))
                    {
                        gUpdateFlag.bUpdateCurr = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 三相电流 方向 PhaCAppCurrentFlag 或 数值 PhaCCurr 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20010400:                            //(当前)零线电流
        {
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            for(i=0; i < nNum; i++)
            {
                if(i == 0)
                {
                    if((gMidPriMeasurePara.CurrentSignType.ZeroLineCurrentFlag != gHisPriMeasurePara.CurrentSignType.ZeroLineCurrentFlag)
                        || (abs(MidTermSharedData.PhaGCurr - HisTermSharedData.PhaGCurr) >= DEAD_ZONE_CURR))
                    {
                        gUpdateFlag.bUpdateCurr = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 零线电流 方向 ZeroLineCurrentFlag 或 数值 PhaGCurr 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20010600:						//(当前)零序电流
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.CurrentSignType.ZeroCurrentFlag:%d, gHisPriMeasurePara.CurrentSignType.ZeroCurrentFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.CurrentSignType.ZeroCurrentFlag, gHisPriMeasurePara.CurrentSignType.ZeroCurrentFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaMCurr=%d, HisTermSharedData.PhaMCurr=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaMCurr - HisTermSharedData.PhaMCurr), MidTermSharedData.PhaMCurr, HisTermSharedData.PhaMCurr, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.CurrentSignType.ZeroCurrentFlag != gHisPriMeasurePara.CurrentSignType.ZeroCurrentFlag)
                        || (abs(MidTermSharedData.PhaMCurr - HisTermSharedData.PhaMCurr) >= DEAD_ZONE_CURR))
                    {
                        gUpdateFlag.bUpdateCurr = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 零序电流 方向 ZeroCurrentFlag 或 数值 PhaMCurr 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x200F0200:						//(当前)电网频率
        {
            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.LineFrz=%d, HisTermSharedData.LineFrz=%d, DEAD_ZONE=%d \n", 
                nOAD, i, abs(MidTermSharedData.LineFrz - HisTermSharedData.LineFrz), MidTermSharedData.LineFrz, HisTermSharedData.LineFrz, DEAD_ZONE_FR);
            if(abs(MidTermSharedData.LineFrz - HisTermSharedData.LineFrz) >= DEAD_ZONE_FR)
            {
                gUpdateFlag.bUpdateLineFrz = 1;
                result = 1;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电网频率 变化! \n", nOAD, i);
                break;
            }
        }
            break;

        /***增加 电压不平衡率 begin***/
        case 0x20260200:						//电压不平衡率
        {
            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.VoltUnbalanceRate=%d, HisTermSharedData.VoltUnbalanceRate=%d, DEAD_ZONE=%d \n", 
                nOAD, i, abs(MidTermSharedData.VoltUnbalanceRate - HisTermSharedData.VoltUnbalanceRate), MidTermSharedData.VoltUnbalanceRate, HisTermSharedData.VoltUnbalanceRate, DEAD_ZONE_FR);
            if(abs(MidTermSharedData.VoltUnbalanceRate - HisTermSharedData.VoltUnbalanceRate) >= DEAD_ZONE_RATE)
            {
                gUpdateFlag.bUpdateVoltUnRate = 1;
                result = 1;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压不平衡率 变化! \n", nOAD, i);
                break;
            }
        }
            break;
        /***增加 电压不平衡率 end***/

        /***增加 电流不平衡率 begin***/
        case 0x20270200:						//电流不平衡率
        {
            ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.CurrUnbalanceRate=%d, HisTermSharedData.CurrUnbalanceRate=%d, DEAD_ZONE=%d \n", 
                nOAD, i, abs(MidTermSharedData.CurrUnbalanceRate - HisTermSharedData.CurrUnbalanceRate), MidTermSharedData.CurrUnbalanceRate, HisTermSharedData.CurrUnbalanceRate, DEAD_ZONE_FR);
            if(abs(MidTermSharedData.CurrUnbalanceRate - HisTermSharedData.CurrUnbalanceRate) >= DEAD_ZONE_RATE)
            {
                gUpdateFlag.bUpdateCurrUnRate = 1;
                result = 1;
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电流不平衡率 变化! \n", nOAD, i);
                break;
            }
        }
            break;
        /***增加 电流不平衡率 end***/

        case 0x200A0200:						//(当前)瞬时总及分相功率因数
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PowerFactorType.AppPfFlag:%d, gHisPriMeasurePara.PowerFactorType.AppPfFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.PowerFactorType.AppPfFlag, gHisPriMeasurePara.PowerFactorType.AppPfFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PowerFactor=%d, HisTermSharedData.PowerFactor=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PowerFactor - HisTermSharedData.PowerFactor), MidTermSharedData.PowerFactor, HisTermSharedData.PowerFactor, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.PowerFactorType.AppPfFlag != gHisPriMeasurePara.PowerFactorType.AppPfFlag)
                        || (abs(MidTermSharedData.PowerFactor - HisTermSharedData.PowerFactor) >= DEAD_ZONE_PF))
                    {
                        gUpdateFlag.bUpdatePowerFactor = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 瞬时总及分相功率因数 方向 AppPfFlag 或 数值 PowerFactor 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PowerFactorType.PhaAAppPfFlag:%d, gHisPriMeasurePara.PowerFactorType.PhaAAppPfFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.PowerFactorType.PhaAAppPfFlag, gHisPriMeasurePara.PowerFactorType.PhaAAppPfFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAPowerFactor=%d, HisTermSharedData.PhaAPowerFactor=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAPowerFactor - HisTermSharedData.PhaAPowerFactor), MidTermSharedData.PhaAPowerFactor, HisTermSharedData.PhaAPowerFactor, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.PowerFactorType.PhaAAppPfFlag != gHisPriMeasurePara.PowerFactorType.PhaAAppPfFlag)
                        || (abs(MidTermSharedData.PhaAPowerFactor - HisTermSharedData.PhaAPowerFactor) >= DEAD_ZONE_PF))
                    {
                        gUpdateFlag.bUpdatePowerFactor = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 瞬时总及分相功率因数 方向 PhaAAppPfFlag 或 数值 PhaAPowerFactor 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PowerFactorType.PhaBAppPfFlag:%d, gHisPriMeasurePara.PowerFactorType.PhaBAppPfFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.PowerFactorType.PhaBAppPfFlag, gHisPriMeasurePara.PowerFactorType.PhaBAppPfFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBPowerFactor=%d, HisTermSharedData.PhaBPowerFactor=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBPowerFactor - HisTermSharedData.PhaBPowerFactor), MidTermSharedData.PhaBPowerFactor, HisTermSharedData.PhaBPowerFactor, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.PowerFactorType.PhaBAppPfFlag != gHisPriMeasurePara.PowerFactorType.PhaBAppPfFlag)
                        || (abs(MidTermSharedData.PhaBPowerFactor - HisTermSharedData.PhaBPowerFactor) >= DEAD_ZONE_PF))
                    {
                        gUpdateFlag.bUpdatePowerFactor = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 瞬时总及分相功率因数 方向 PhaBAppPfFlag 或 数值 PhaBPowerFactor 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 3)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.PowerFactorType.PhaCAppPfFlag:%d, gHisPriMeasurePara.PowerFactorType.PhaCAppPfFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.PowerFactorType.PhaCAppPfFlag, gHisPriMeasurePara.PowerFactorType.PhaCAppPfFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCPowerFactor=%d, HisTermSharedData.PhaCPowerFactor=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCPowerFactor - HisTermSharedData.PhaCPowerFactor), MidTermSharedData.PhaCPowerFactor, HisTermSharedData.PhaCPowerFactor, DEAD_ZONE_CURR);
                    if((gMidPriMeasurePara.PowerFactorType.PhaCAppPfFlag != gHisPriMeasurePara.PowerFactorType.PhaCAppPfFlag)
                        || (abs(MidTermSharedData.PhaCPowerFactor - HisTermSharedData.PhaCPowerFactor) >= DEAD_ZONE_PF))
                    {
                        gUpdateFlag.bUpdatePowerFactor = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 瞬时总及分相功率因数 方向 PhaCAppPfFlag 或 数值 PhaCPowerFactor 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        /* 增加	电表状态字1-7 begin*/
        case 0x20140200:						//电表运行状态字1-7
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw1.Word=%d, HisTermSharedData.MetStusPara.Rsw1.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw1.Word, HisTermSharedData.MetStusPara.Rsw1.Word);

                    if(MidTermSharedData.MetStusPara.Rsw1.BitSect.ReservedBit7 == 1 
                        && HisTermSharedData.MetStusPara.Rsw1.BitSect.ReservedBit7 == 0)//发生磁场干扰事件
                    {
                        ACDB_FMT_DEBUG("CheckDataDeadZone()检测: 发生磁场干扰事件! \n");
                        #if TID_MAGNETIC == 0
                        gEventCommInfo.EffectState = MidTermSharedData.MetStusPara.Rsw1.BitSect.ReservedBit7;
                        InitEventPara();
                        SaveMagneticEventOccur();
                        #endif
                    }
                    else if(MidTermSharedData.MetStusPara.Rsw1.BitSect.ReservedBit7 == 0 
                        && HisTermSharedData.MetStusPara.Rsw1.BitSect.ReservedBit7 == 1)//磁场干扰事件恢复
                    {
                        ACDB_FMT_DEBUG("CheckDataDeadZone()检测: 磁场干扰事件恢复! \n");
                        #if TID_MAGNETIC == 0
                        gEventCommInfo.EffectState = MidTermSharedData.MetStusPara.Rsw1.BitSect.ReservedBit7;
                        InitEventPara();
                        //SaveMagneticEventRecover();//事件恢复时, 只更新, 不新增
                        SaveMagneticEventOccur();//事件发生与恢复分别为一条事件
                        #endif
                    }
                    
                    if(MidTermSharedData.MetStusPara.Rsw1.Word != HisTermSharedData.MetStusPara.Rsw1.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw1 变化! \n", nOAD, i);
                        break;
                    }
                }
                else if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw2.Word=%d, HisTermSharedData.MetStusPara.Rsw2.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw2.Word, HisTermSharedData.MetStusPara.Rsw2.Word);
                    if(MidTermSharedData.MetStusPara.Rsw2.Word != HisTermSharedData.MetStusPara.Rsw2.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw2 变化! \n", nOAD, i);
                        break;
                    }
                }
                else if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw3.Word=%d, HisTermSharedData.MetStusPara.Rsw3.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw3.Word, HisTermSharedData.MetStusPara.Rsw3.Word);
                    if(MidTermSharedData.MetStusPara.Rsw3.Word != HisTermSharedData.MetStusPara.Rsw3.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw3 变化! \n", nOAD, i);
                        break;
                    }
                }
                else if(i == 3)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw4.Word=%d, HisTermSharedData.MetStusPara.Rsw4.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw4.Word, HisTermSharedData.MetStusPara.Rsw4.Word);
                    if(MidTermSharedData.MetStusPara.Rsw4.Word != HisTermSharedData.MetStusPara.Rsw4.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw4 变化! \n", nOAD, i);
                        break;
                    }
                }
                else if(i == 4)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw5.Word=%d, HisTermSharedData.MetStusPara.Rsw5.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw5.Word, HisTermSharedData.MetStusPara.Rsw5.Word);
                    if(MidTermSharedData.MetStusPara.Rsw5.Word != HisTermSharedData.MetStusPara.Rsw5.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw5 变化! \n", nOAD, i);
                        break;
                    }
                }
                else if(i == 5)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw6.Word=%d, HisTermSharedData.MetStusPara.Rsw6.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw6.Word, HisTermSharedData.MetStusPara.Rsw6.Word);
                    if(MidTermSharedData.MetStusPara.Rsw6.Word != HisTermSharedData.MetStusPara.Rsw6.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw6 变化! \n", nOAD, i);
                        break;
                    }
                }
                else if(i == 6)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, MidTermSharedData.MetStusPara.Rsw7.Word=%d, HisTermSharedData.MetStusPara.Rsw7.Word=%d \n", 
                        nOAD, i, MidTermSharedData.MetStusPara.Rsw7.Word, HisTermSharedData.MetStusPara.Rsw7.Word);
                    if(MidTermSharedData.MetStusPara.Rsw7.Word != HisTermSharedData.MetStusPara.Rsw7.Word)
                    {
                        gUpdateFlag.bUpdateMetStusPara = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电表运行状态字 Rsw7 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
            CheckEvent300F();
        }
            break;
        
        /* 增加	电表状态字1-7 end*/


        /* 增加	相角 begin*/
        case 0x20020200:			   //(当前)电压相角
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAVoltAngle=%d, HisTermSharedData.PhaAVoltAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAVoltAngle - HisTermSharedData.PhaAVoltAngle), MidTermSharedData.PhaAVoltAngle, HisTermSharedData.PhaAVoltAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag)
                        || (abs(MidTermSharedData.PhaAVoltAngle - HisTermSharedData.PhaAVoltAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateVoltAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压相角 方向 PhaAVolAngFlag 或 数值 PhaAVoltAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBVoltAngle=%d, HisTermSharedData.PhaBVoltAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBVoltAngle - HisTermSharedData.PhaBVoltAngle), MidTermSharedData.PhaBVoltAngle, HisTermSharedData.PhaBVoltAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag)
                        || (abs(MidTermSharedData.PhaBVoltAngle - HisTermSharedData.PhaBVoltAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateVoltAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压相角 方向 PhaBVolAngFlag 或 数值 PhaBVoltAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCVoltAngle=%d, HisTermSharedData.PhaCVoltAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCVoltAngle - HisTermSharedData.PhaCVoltAngle), MidTermSharedData.PhaCVoltAngle, HisTermSharedData.PhaCVoltAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag)
                        || (abs(MidTermSharedData.PhaCVoltAngle - HisTermSharedData.PhaCVoltAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateVoltAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压相角 方向 PhaCVolAngFlag 或 数值 PhaCVoltAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;
        case 0xAAAA0001:			   //(当前)电流相角
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaACurrAngle=%d, HisTermSharedData.PhaACurrAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaACurrAngle - HisTermSharedData.PhaACurrAngle), MidTermSharedData.PhaACurrAngle, HisTermSharedData.PhaACurrAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag)
                        || (abs(MidTermSharedData.PhaACurrAngle - HisTermSharedData.PhaACurrAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateCurrAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电流相角 方向 PhaACurrAngFlag 或 数值 PhaACurrAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBCurrAngle=%d, HisTermSharedData.PhaBCurrAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBCurrAngle - HisTermSharedData.PhaBCurrAngle), MidTermSharedData.PhaBCurrAngle, HisTermSharedData.PhaBCurrAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag)
                        || (abs(MidTermSharedData.PhaBCurrAngle - HisTermSharedData.PhaBCurrAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateCurrAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电流相角 方向 PhaBCurrAngFlag 或 数值 PhaBCurrAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCCurrAngle=%d, HisTermSharedData.PhaCCurrAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCCurrAngle - HisTermSharedData.PhaCCurrAngle), MidTermSharedData.PhaCCurrAngle, HisTermSharedData.PhaCCurrAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag)
                        || (abs(MidTermSharedData.PhaCCurrAngle - HisTermSharedData.PhaCCurrAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateCurrAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电流相角 方向 PhaCCurrAngFlag 或 数值 PhaCCurrAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        case 0x20030200:			   //(当前)电压电流相角
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAAngle=%d, HisTermSharedData.PhaAAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaAAngle - HisTermSharedData.PhaAAngle), MidTermSharedData.PhaAAngle, HisTermSharedData.PhaAAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag)
                        || (abs(MidTermSharedData.PhaAAngle - HisTermSharedData.PhaAAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateVoltCurrAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压电流相角 方向 PhaAVolCurrAngFlag 或 数值 PhaAAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 1)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBAngle=%d, HisTermSharedData.PhaBAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaBAngle - HisTermSharedData.PhaBAngle), MidTermSharedData.PhaBAngle, HisTermSharedData.PhaBAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag)
                        || (abs(MidTermSharedData.PhaBAngle - HisTermSharedData.PhaBAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateVoltCurrAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压电流相角 方向 PhaBVolCurrAngFlag 或 数值 PhaBAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
                if(i == 2)
                {
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag:%d, gHisPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag=%d \n", 
                        nOAD, i, gMidPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag, gHisPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag);
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCAngle=%d, HisTermSharedData.PhaCAngle=%d, DEAD_ZONE=%d \n", 
                        nOAD, i, abs(MidTermSharedData.PhaCAngle - HisTermSharedData.PhaCAngle), MidTermSharedData.PhaCAngle, HisTermSharedData.PhaCAngle, DEAD_ZONE_ANGLE);
                    if((gMidPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag != gHisPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag)
                        || (abs(MidTermSharedData.PhaCAngle - HisTermSharedData.PhaCAngle) >= DEAD_ZONE_ANGLE))
                    {
                        gUpdateFlag.bUpdateVoltCurrAngle = 1;
                        result = 1;
                        ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, 电压电流相角 方向 PhaCVolCurrAngFlag 或 数值 PhaCAngle 变化! \n", nOAD, i);
                        break;
                    }
                }
            }
        }
            break;

        /* 增加	相角 end*/

        /* 增加 谐波 begin*/
        case 0x200D0200:			   //(当前)A相 电压谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {	
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAVoltHarmonic[i]=%d, HisTermSharedData.PhaAVoltHarmonic[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaAVoltHarmonic[i] - HisTermSharedData.PhaAVoltHarmonic[i]), MidTermSharedData.PhaAVoltHarmonic[i], HisTermSharedData.PhaAVoltHarmonic[i], DEAD_ZONE_HARM);
                if(abs(MidTermSharedData.PhaAVoltHarmonic[i] - HisTermSharedData.PhaAVoltHarmonic[i]) >= DEAD_ZONE_HARM)
                {
                    gUpdateFlag.bUpdateAVoltHarmonic = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 电压谐波含有率 PhaAVoltHarmonic 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x200D0300:			   //(当前)B相 电压谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBVoltHarmonic[i]=%d, HisTermSharedData.PhaBVoltHarmonic[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaBVoltHarmonic[i] - HisTermSharedData.PhaBVoltHarmonic[i]), MidTermSharedData.PhaBVoltHarmonic[i], HisTermSharedData.PhaBVoltHarmonic[i], DEAD_ZONE_HARM);
                if(abs(MidTermSharedData.PhaBVoltHarmonic[i] - HisTermSharedData.PhaBVoltHarmonic[i]) >= DEAD_ZONE_HARM)
                {
                    gUpdateFlag.bUpdateBVoltHarmonic = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 电压谐波含有率 PhaBVoltHarmonic 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x200D0400:			   //(当前)C相 电压谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCVoltHarmonic[i]=%d, HisTermSharedData.PhaCVoltHarmonic[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaCVoltHarmonic[i] - HisTermSharedData.PhaCVoltHarmonic[i]), MidTermSharedData.PhaCVoltHarmonic[i], HisTermSharedData.PhaCVoltHarmonic[i], DEAD_ZONE_HARM);
                if(abs(MidTermSharedData.PhaCVoltHarmonic[i] - HisTermSharedData.PhaCVoltHarmonic[i]) >= DEAD_ZONE_HARM)
                {
                    gUpdateFlag.bUpdateCVoltHarmonic = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 电压谐波含有率 PhaCVoltHarmonic 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x200E0200:			   //(当前)A相 电流谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaACurrHarmonic[i]=%d, HisTermSharedData.PhaACurrHarmonic[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaACurrHarmonic[i] - HisTermSharedData.PhaACurrHarmonic[i]), MidTermSharedData.PhaACurrHarmonic[i], HisTermSharedData.PhaACurrHarmonic[i], DEAD_ZONE_HARM);
                if(abs(MidTermSharedData.PhaACurrHarmonic[i] - HisTermSharedData.PhaACurrHarmonic[i]) >= DEAD_ZONE_HARM)
                {
                    gUpdateFlag.bUpdateACurrHarmonic = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 电流谐波含有率 PhaACurrHarmonic 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x200E0300:			   //(当前)B相 电流谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBCurrHarmonic[i]=%d, HisTermSharedData.PhaBCurrHarmonic[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaBCurrHarmonic[i] - HisTermSharedData.PhaBCurrHarmonic[i]), MidTermSharedData.PhaBCurrHarmonic[i], HisTermSharedData.PhaBCurrHarmonic[i], DEAD_ZONE_HARM);
                if(abs(MidTermSharedData.PhaBCurrHarmonic[i] - HisTermSharedData.PhaBCurrHarmonic[i]) >= DEAD_ZONE_HARM)
                {
                    gUpdateFlag.bUpdateBCurrHarmonic = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 电流谐波含有率 PhaBCurrHarmonic 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x200E0400:			   //(当前)C相 电流谐波含有率（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=0; i<nNum; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCCurrHarmonic[i]=%d, HisTermSharedData.PhaCCurrHarmonic[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaCCurrHarmonic[i] - HisTermSharedData.PhaCCurrHarmonic[i]), MidTermSharedData.PhaCCurrHarmonic[i], HisTermSharedData.PhaCCurrHarmonic[i], DEAD_ZONE_HARM);
                if(abs(MidTermSharedData.PhaCCurrHarmonic[i] - HisTermSharedData.PhaCCurrHarmonic[i]) >= DEAD_ZONE_HARM)
                {
                    gUpdateFlag.bUpdateCCurrHarmonic = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 电流谐波含有率 PhaCCurrHarmonic 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        /* 增加 谐波 end*/

        /* 增加 谐波含量 begin*/
        case 0x20330200:			   //(当前)A相 电压谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {	
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaAVoltHarmonicValue[i]=%d, HisTermSharedData.PhaAVoltHarmonicValue[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaAVoltHarmonicValue[i] - HisTermSharedData.PhaAVoltHarmonicValue[i]), MidTermSharedData.PhaAVoltHarmonicValue[i], HisTermSharedData.PhaAVoltHarmonicValue[i], DEAD_ZONE_VOLT);
                if(abs(MidTermSharedData.PhaAVoltHarmonicValue[i] - HisTermSharedData.PhaAVoltHarmonicValue[i]) >= DEAD_ZONE_VOLT)
                {
                    gUpdateFlag.bUpdateAVoltHarmonicValue = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 电压谐波含量 PhaAVoltHarmonicValue 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x20330300:			   //(当前)B相 电压谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBVoltHarmonicValue[i]=%d, HisTermSharedData.PhaBVoltHarmonicValue[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaBVoltHarmonicValue[i] - HisTermSharedData.PhaBVoltHarmonicValue[i]), MidTermSharedData.PhaBVoltHarmonicValue[i], HisTermSharedData.PhaBVoltHarmonicValue[i], DEAD_ZONE_VOLT);
                if(abs(MidTermSharedData.PhaBVoltHarmonicValue[i] - HisTermSharedData.PhaBVoltHarmonicValue[i]) >= DEAD_ZONE_VOLT)
                {
                    gUpdateFlag.bUpdateBVoltHarmonicValue = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 电压谐波含量 PhaBVoltHarmonicValue 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x20330400:			   //(当前)C相 电压谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCVoltHarmonicValue[i]=%d, HisTermSharedData.PhaCVoltHarmonicValue[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaCVoltHarmonicValue[i] - HisTermSharedData.PhaCVoltHarmonicValue[i]), MidTermSharedData.PhaCVoltHarmonicValue[i], HisTermSharedData.PhaCVoltHarmonicValue[i], DEAD_ZONE_VOLT);
                if(abs(MidTermSharedData.PhaCVoltHarmonicValue[i] - HisTermSharedData.PhaCVoltHarmonicValue[i]) >= DEAD_ZONE_VOLT)
                {
                    gUpdateFlag.bUpdateCVoltHarmonicValue = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 电压谐波含量 PhaCVoltHarmonicValue 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x20340200:			   //(当前)A相 电流谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i]:%d, gHisPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i]=%d \n", 
                    nOAD, i, gMidPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i], gHisPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i]);
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaACurrHarmonicValue[i]=%d, HisTermSharedData.PhaACurrHarmonicValue[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaACurrHarmonicValue[i] - HisTermSharedData.PhaACurrHarmonicValue[i]), MidTermSharedData.PhaACurrHarmonicValue[i], HisTermSharedData.PhaACurrHarmonicValue[i], DEAD_ZONE_CURR);
                if((gMidPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i] != gHisPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i]) 
                    || (abs(MidTermSharedData.PhaACurrHarmonicValue[i] - HisTermSharedData.PhaACurrHarmonicValue[i]) >= DEAD_ZONE_CURR))
                {
                    gUpdateFlag.bUpdateACurrHarmonicValue = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, A相 电流谐波含量 PhaACurrHarmonicValue 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x20340300:			   //(当前)B相 电流谐波含量（2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i]:%d, gHisPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i]=%d \n", 
                    nOAD, i, gMidPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i], gHisPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i]);
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaBCurrHarmonicValue[i]=%d, HisTermSharedData.PhaBCurrHarmonicValue[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaBCurrHarmonicValue[i] - HisTermSharedData.PhaBCurrHarmonicValue[i]), MidTermSharedData.PhaBCurrHarmonicValue[i], HisTermSharedData.PhaBCurrHarmonicValue[i], DEAD_ZONE_CURR);
                if((gMidPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i] != gHisPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i]) 
                    || (abs(MidTermSharedData.PhaBCurrHarmonicValue[i] - HisTermSharedData.PhaBCurrHarmonicValue[i]) >= DEAD_ZONE_CURR))
                {
                    gUpdateFlag.bUpdateBCurrHarmonicValue = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, B相 电流谐波含量 PhaBCurrHarmonicValue 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        case 0x20340400:			   //(当前)C相 电流谐波含量（总及2…n次）
        {
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            for(i=1; i<nNum+1; i++)
            {
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, gMidPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i]:%d, gHisPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i]=%d \n", 
                    nOAD, i, gMidPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i], gHisPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i]);
                ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, abs(DValue)=%d, MidTermSharedData.PhaCCurrHarmonicValue[i]=%d, HisTermSharedData.PhaCCurrHarmonicValue[i]=%d, DEAD_ZONE=%d \n", 
                    nOAD, i, abs(MidTermSharedData.PhaCCurrHarmonicValue[i] - HisTermSharedData.PhaCCurrHarmonicValue[i]), MidTermSharedData.PhaCCurrHarmonicValue[i], HisTermSharedData.PhaCCurrHarmonicValue[i], DEAD_ZONE_CURR);
                if((gMidPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i] != gHisPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i]) 
                    || (abs(MidTermSharedData.PhaCCurrHarmonicValue[i] - HisTermSharedData.PhaCCurrHarmonicValue[i]) >= DEAD_ZONE_CURR))
                {
                    gUpdateFlag.bUpdateCCurrHarmonicValue = 1;
                    result = 1;
                    ACDB_FMT_LOGCC("nOAD=0x%08x, i=%d, C相 电流谐波含量 PhaCCurrHarmonicValue 变化! \n", nOAD, i);
                    break;
                }
            }
        }
            break;

        /* 增加 谐波含量 end*/


        default:
            return -2;
            break;
   }

    return result;
}


/****************************************************************************
*模块编号：
*名称：Find07AcDataByOad
*功能：通过oad查询07版645与oad的对应关系
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
int Find07AcDataByOad(uint8 *pDesbuffer, uint16 *nDesLen, const Map645ToOop_NEW *pOadInfo)
{
    int     i    = 0;
    uint16  nNum = 0;
    uint32  nOAD = 0;

    nOAD = pOadInfo->Oad.value;
    
    switch(nOAD)
    {
        case 0x00100200:                        //(当前)正向有功电能总尖峰平谷示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PosActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00200200:                        //(当前)反向有功电能总尖峰平谷示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.NegActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00300200:                        //(当前)正向无功电能总尖峰平谷示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PosReaEnergyType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PosReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PosReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00400200:                        //(当前)反向无功电能总尖峰平谷示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.NegReaEnergyType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.NegReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.NegReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00500200:                        //(当前)第一象限无功总尖峰平谷电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad1ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00600200:                        //(当前)第二象限无功总尖峰平谷电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad2ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00700200:                        //(当前)第三象限无功总尖峰平谷电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad3ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));

        }
            break;

        case 0x00800200:                        //(当前)第四象限无功总尖峰平谷电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad4ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00010200:                        //(A相)组合有功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy, 0x00, sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for (i = 0; i < nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaACmbActEng[i].SLinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
            memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00110200:                        //(A相)正向有功总电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaAPosActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00210200:                        //(A相)反向有功总电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaANegActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));

        }
            break;

        case 0x00310200:                        //(A相)正向无功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaAPosReaEngType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaAPosReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaAPosReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));

        }
            break;

        case 0x00410200:                        //(A相)反向无功总电能示值
        {
           OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaANegReaEngType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaANegReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaANegReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));

        }
            break;

        case 0x00020200:                        //(B相)组合有功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy, 0x00, sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for (i = 0; i < nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBCmbActEng[i].SLinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
            memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00120200:                        //(B相)正向有功总电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBPosActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00220200:                        //(B相)反向有功总电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBNegActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));

        }
            break;

        case 0x00320200:                        //(B相)正向无功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBPosReaEngType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaBPosReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaBPosReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00420200:                        //(B相)反向无功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBNegReaEngType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaBNegReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaBNegReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00030200:                        //(C相)组合有功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy, 0x00, sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for (i = 0; i < nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCCmbActEng[i].SLinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
            memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00130200:                        //(C相)正向有功总电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCPosActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00230200:                        //(C相)反向有功总电能示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCNegActEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00330200:                        //(C相)正向无功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCPosReaEngType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaCPosReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaCPosReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00430200:                        //(C相)反向无功总电能示值
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCNegReaEngType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaCNegReaEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaCNegReaEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;


        /* 增加 电能 start*/
        case 0x00000200:                        //(当前)组合有功电能总尖峰平谷示值(带符号)
        {
            OOP_ENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.CmbEnergyType[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.CmbActEng[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.CmbActEng[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
                
            }
            *nDesLen = sizeof(OOP_ENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGYS_T));
        }
            break;

        case 0x00900200:                        //(当前)正向视在电能总尖峰平谷示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PosAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00A00200:                        //(当前)反向视在电能总尖峰平谷示值
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.NegAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00510200:                        //A相第一象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA1ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00520200:                        //B相第一象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB1ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00530200:                        //C相第一象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC1ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00610200:                        //A相第二象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA2ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00620200:                        //B相第二象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB2ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00630200:                        //C相第二象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC2ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00710200:                        //A相第三象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA3ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00720200:                        //B相第三象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB3ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00730200:                        //C相第三象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC3ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00810200:                        //A相第四象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA4ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00820200:                        //B相第四象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB4ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00830200:                        //C相第四象限无功电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC4ReaEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00910200:                        //A相正向视在电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaAActAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00920200:                        //B相正向视在电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBActAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00930200:                        //C相正向视在电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCActAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00A10200:                        //A 相反向视在电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaANegAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00A20200:                        //B相反向视在电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBNegAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        case 0x00A30200:                        //C相反向视在电能
        {
            OOP_ENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_ENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCNegAppEng[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_ENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_ENERGY_T));
        }
            break;

        /* 增加 电能 end*/

        /***高精度 电能量 begin***/

        case 0x00100400:                        //(当前)正向有功电能总尖峰平谷示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PosActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00200400:                        //(当前)反向有功电能总尖峰平谷示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.NegActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00300400:                        //(当前)正向无功电能总尖峰平谷示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PosReaEnergyTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PosReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PosReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;

        case 0x00400400:                        //(当前)反向无功电能总尖峰平谷示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.NegReaEnergyTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.NegReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.NegReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;

        case 0x00500400:                        //(当前)第一象限无功总尖峰平谷电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad1ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00600400:                        //(当前)第二象限无功总尖峰平谷电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad2ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00700400:                        //(当前)第三象限无功总尖峰平谷电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad3ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));

        }
            break;

        case 0x00800400:                        //(当前)第四象限无功总尖峰平谷电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.Quad4ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00110400:                        //(A相)正向有功总电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaAPosActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00210400:                        //(A相)反向有功总电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaANegActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));

        }
            break;

        case 0x00310400:                        //(A相)正向无功总电能示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaAPosReaEngTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaAPosReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaAPosReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));

        }
            break;

        case 0x00410400:                        //(A相)反向无功总电能示值
        {
           OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaANegReaEngTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaANegReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaANegReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));

        }
            break;

        case 0x00120400:                        //(B相)正向有功总电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBPosActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00220400:                        //(B相)反向有功总电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBNegActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));

        }
            break;

        case 0x00320400:                        //(B相)正向无功总电能示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBPosReaEngTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaBPosReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaBPosReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;

        case 0x00420400:                        //(B相)反向无功总电能示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaBNegReaEngTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaBNegReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaBNegReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;

        case 0x00130400:                        //(C相)正向有功总电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCPosActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00230400:                        //(C相)反向有功总电能示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCNegActEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00330400:                        //(C相)正向无功总电能示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCPosReaEngTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaCPosReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaCPosReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;

        case 0x00430400:                        //(C相)反向无功总电能示值
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.PhaCNegReaEngTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.PhaCNegReaEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.PhaCNegReaEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;


        /* 增加 电能 start*/
        case 0x00000400:                        //(当前)组合有功电能总尖峰平谷示值(带符号)
        {
            OOP_HENERGYS_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGYS_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.CmbEnergyTypeHD[i] == 1)
                {
                    Energy.nValue[i] = 0 - MidTermSharedData.CmbActEngHD[i].ULinteger;
                }
                else
                {
                    Energy.nValue[i] = MidTermSharedData.CmbActEngHD[i].ULinteger;
                }
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGYS_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGYS_T));
        }
            break;

        case 0x00900400:                        //(当前)正向视在电能总尖峰平谷示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PosAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00A00400:                        //(当前)反向视在电能总尖峰平谷示值
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.NegAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00510400:                        //A相第一象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA1ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00520400:                        //B相第一象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB1ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00530400:                        //C相第一象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC1ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00610400:                        //A相第二象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA2ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00620400:                        //B相第二象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB2ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00630400:                        //C相第二象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC2ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00710400:                        //A相第三象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA3ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00720400:                        //B相第三象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB3ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00730400:                        //C相第三象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC3ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00810400:                        //A相第四象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaA4ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00820400:                        //B相第四象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaB4ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00830400:                        //C相第四象限无功电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaC4ReaEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00910400:                        //A相正向视在电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaAActAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00920400:                        //B相正向视在电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBActAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00930400:                        //C相正向视在电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCActAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00A10400:                        //A 相反向视在电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaANegAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00A20400:                        //B相反向视在电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaBNegAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        case 0x00A30400:                        //C相反向视在电能
        {
            OOP_HENERGY_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_HENERGY_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Energy.nValue[i] = MidTermSharedData.PhaCNegAppEngHD[i].ULinteger;
                set_bit_value((uint8*)&Energy.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HENERGY_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_HENERGY_T));
        }
            break;

        /* 增加 电能 end*/

        /***高精度 电能量 end***/

        case 0x10100200:                //(当前)正向有功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.CurrDemand[0][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.CurrDemandTime[0][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.CurrDemandTime[0][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.CurrDemandTime[0][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.CurrDemandTime[0][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.CurrDemandTime[0][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.CurrDemandTime[0][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10200200:                //(当前)反向有功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.CurrDemand[1][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.CurrDemandTime[1][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.CurrDemandTime[1][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.CurrDemandTime[1][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.CurrDemandTime[1][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.CurrDemandTime[1][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.CurrDemandTime[1][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10300200:                //(当前)正向无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.CurrDemand[2][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.CurrDemandTime[2][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.CurrDemandTime[2][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.CurrDemandTime[2][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.CurrDemandTime[2][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.CurrDemandTime[2][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.CurrDemandTime[2][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10400200:                //(当前)反向无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.CurrDemand[3][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.CurrDemandTime[3][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.CurrDemandTime[3][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.CurrDemandTime[3][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.CurrDemandTime[3][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.CurrDemandTime[3][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.CurrDemandTime[3][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        /* 增加 需量 begin*/
        case 0x10500200:                //(当前)1象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.QuaDemand[0][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.QuaDemandTime[0][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.QuaDemandTime[0][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.QuaDemandTime[0][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.QuaDemandTime[0][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.QuaDemandTime[0][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.QuaDemandTime[0][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10600200:                //(当前)2象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.QuaDemand[1][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.QuaDemandTime[1][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.QuaDemandTime[1][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.QuaDemandTime[1][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.QuaDemandTime[1][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.QuaDemandTime[1][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.QuaDemandTime[1][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10700200:                //(当前)3象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.QuaDemand[2][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.QuaDemandTime[2][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.QuaDemandTime[2][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.QuaDemandTime[2][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.QuaDemandTime[2][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.QuaDemandTime[2][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.QuaDemandTime[2][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10800200:                //(当前)4象限无功总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.QuaDemand[3][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.QuaDemandTime[3][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.QuaDemandTime[3][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.QuaDemandTime[3][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.QuaDemandTime[3][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.QuaDemandTime[3][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.QuaDemandTime[3][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10900200:                //(当前)正向视在电能总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.AppaDemand[0][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.AppaDemandTime[0][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.AppaDemandTime[0][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.AppaDemandTime[0][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.AppaDemandTime[0][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.AppaDemandTime[0][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.AppaDemandTime[0][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10A00200:                //(当前)反向视在电能总尖峰平谷最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.AppaDemand[1][i].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.AppaDemandTime[1][i].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.AppaDemandTime[1][i].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.AppaDemandTime[1][i].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.AppaDemandTime[1][i].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.AppaDemandTime[1][i].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.AppaDemandTime[1][i].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        /* 增加 需量 end*/

        /* 增加 分项需量 begin*/
        case 0x10110200:                //(当前)A相 正向有功最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.PosActDemand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.PosActDemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.PosActDemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.PosActDemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.PosActDemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.PosActDemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.PosActDemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10120200:                //(当前)B相 正向有功最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.PosActDemand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.PosActDemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.PosActDemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.PosActDemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.PosActDemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.PosActDemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.PosActDemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10130200:                //(当前)C相 正向有功最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                Demand.demand[i].nValue = MidTermSharedData.PosActDemand[2].DemNum[0] + 
                    MidTermSharedData.PosActDemand[2].DemNum[1]*256 + 
                    MidTermSharedData.PosActDemand[2].DemNum[2]*256*256;
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.PosActDemand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.PosActDemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.PosActDemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.PosActDemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.PosActDemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.PosActDemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.PosActDemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10210200:                //(当前)A相 反向有功最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegActDemand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegActDemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegActDemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegActDemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegActDemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegActDemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegActDemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10220200:                //(当前)B相 反向有功最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegActDemand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegActDemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegActDemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegActDemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegActDemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegActDemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegActDemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10230200:                //(当前)C相 反向有功最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegActDemand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegActDemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegActDemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegActDemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegActDemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegActDemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegActDemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10310200:                //(当前)A相 组合无功1最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.PosReaDemand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.PosReaDemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.PosReaDemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.PosReaDemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.PosReaDemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.PosReaDemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.PosReaDemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10320200:                //(当前)B相 组合无功1最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.PosReaDemand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.PosReaDemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.PosReaDemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.PosReaDemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.PosReaDemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.PosReaDemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.PosReaDemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10330200:                //(当前)C相 组合无功1最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.PosReaDemand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.PosReaDemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.PosReaDemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.PosReaDemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.PosReaDemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.PosReaDemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.PosReaDemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10410200:                //(当前)A相 组合无功2最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegReaDemand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegReaDemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegReaDemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegReaDemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegReaDemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegReaDemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegReaDemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10420200:                //(当前)B相 组合无功2最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegReaDemand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegReaDemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegReaDemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegReaDemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegReaDemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegReaDemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegReaDemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10430200:                //(当前)C相 组合无功2最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegReaDemand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegReaDemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegReaDemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegReaDemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegReaDemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegReaDemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegReaDemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10510200:                //(当前)A相 第一象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua1Demand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua1DemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua1DemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua1DemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua1DemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua1DemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua1DemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10520200:                //(当前)B相 第一象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua1Demand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua1DemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua1DemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua1DemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua1DemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua1DemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua1DemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10530200:                //(当前)C相 第一象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua1Demand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua1DemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua1DemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua1DemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua1DemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua1DemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua1DemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10610200:                //(当前)A相 第二象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua2Demand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua2DemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua2DemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua2DemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua2DemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua2DemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua2DemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10620200:                //(当前)B相 第二象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua2Demand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua2DemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua2DemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua2DemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua2DemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua2DemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua2DemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10630200:                //(当前)C相 第二象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua2Demand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua2DemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua2DemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua2DemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua2DemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua2DemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua2DemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10710200:                //(当前)A相 第三象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua3Demand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua3DemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua3DemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua3DemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua3DemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua3DemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua3DemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10720200:                //(当前)B相 第三象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua3Demand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua3DemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua3DemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua3DemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua3DemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua3DemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua3DemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10730200:                //(当前)C相 第三象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua3Demand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua3DemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua3DemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua3DemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua3DemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua3DemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua3DemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10810200:                //(当前)A相 第四象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua4Demand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua4DemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua4DemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua4DemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua4DemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua4DemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua4DemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10820200:                //(当前)B相 第四象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua4Demand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua4DemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua4DemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua4DemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua4DemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua4DemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua4DemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10830200:                //(当前)C相 第四象限最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.Qua4Demand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.Qua4DemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.Qua4DemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.Qua4DemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.Qua4DemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.Qua4DemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.Qua4DemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10910200:                //(当前)A相 正向视在最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.ActAppDemand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.ActAppDemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.ActAppDemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.ActAppDemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.ActAppDemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.ActAppDemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.ActAppDemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10920200:                //(当前)B相 正向视在最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.ActAppDemand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.ActAppDemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.ActAppDemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.ActAppDemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.ActAppDemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.ActAppDemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.ActAppDemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10930200:                //(当前)C相 正向视在最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.ActAppDemand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.ActAppDemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.ActAppDemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.ActAppDemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.ActAppDemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.ActAppDemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.ActAppDemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;


            case 0x10A10200:                //(当前)A相 反向视在最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegAppDemand[0].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegAppDemandTime[0].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegAppDemandTime[0].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegAppDemandTime[0].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegAppDemandTime[0].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegAppDemandTime[0].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegAppDemandTime[0].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10A20200:                //(当前)B相 反向视在最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegAppDemand[1].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegAppDemandTime[1].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegAppDemandTime[1].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegAppDemandTime[1].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegAppDemandTime[1].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegAppDemandTime[1].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegAppDemandTime[1].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        case 0x10A30200:                //(当前)C相 反向视在最大需量
        {
            OOP_DEMAND_T Demand;
            uint8 ntemp = 0;
            memset((uint8*)&Demand,0x00,sizeof(OOP_DEMAND_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Demand.nNum = nNum;
            Demand.rsv = 0;
            i = 0;
            {
                BcdX_To_BinY(3, 4, (uint8*)&(Demand.demand[i].nValue), &(MidTermSharedData.NegAppDemand[2].DemNum[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.second), &(MidTermSharedData.NegAppDemandTime[2].DemTime[0]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.minute), &(MidTermSharedData.NegAppDemandTime[2].DemTime[1]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.hour), &(MidTermSharedData.NegAppDemandTime[2].DemTime[2]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.day), &(MidTermSharedData.NegAppDemandTime[2].DemTime[3]), 1);
                BcdX_To_BinY(1, 1, &(Demand.demand[i].time.month), &(MidTermSharedData.NegAppDemandTime[2].DemTime[4]), 1);
                BcdX_To_BinY(1, 1, &ntemp, &(MidTermSharedData.NegAppDemandTime[2].DemTime[5]), 1);
                Demand.demand[i].time.year = ntemp + 2000;
                set_bit_value((uint8*)&Demand.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_DEMAND_T);
               memcpy(pDesbuffer, &Demand, sizeof(OOP_DEMAND_T));
        }
            break;

        /* 增加 分项需量 end*/
            

        case 0x20040200:						//(当前)瞬时有功功率
        {
            OOP_INT4V_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_INT4V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.ActPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.NegActPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PosActPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaAActPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaAActPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaAActPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaBActPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaBActPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaBActPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 3)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaCActPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaCActPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaCActPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_INT4V_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_INT4V_T));
        }
            break;

        case 0x20050200:			   //(当前)瞬时无功功率
        {
            OOP_INT4V_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_INT4V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.ReaPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.NegReaPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PosReaPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaAReaPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaAReaPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaAReaPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaBReaPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaBReaPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaBReaPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 3)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaCReaPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaCReaPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaCReaPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_INT4V_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_INT4V_T));
        }
            break;

        case 0x20000200:			   //(当前)三相电压
        {
            OOP_WORD3V_T Voltage;
            memset((uint8*)&Voltage,0x00,sizeof(OOP_WORD3V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Voltage.nNum = nNum;
            Voltage.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {            
                    Voltage.nValue[i] = MidTermSharedData.PhaAVolt;
                    set_bit_value((uint8*)&Voltage.rsv, 32, i);
                }
                if(i == 1)
                {            
                    Voltage.nValue[i] = MidTermSharedData.PhaBVolt;
                    set_bit_value((uint8*)&Voltage.rsv, 32, i);
                }
                if(i == 2)
                {            
                    Voltage.nValue[i] = MidTermSharedData.PhaCVolt;
                    set_bit_value((uint8*)&Voltage.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_WORD3V_T);
               memcpy(pDesbuffer, &Voltage, sizeof(OOP_WORD3V_T));
        }
            break;

        case 0x20000400:			   //(当前)高精度三相电压
        {
            OOP_DWORD3V_T Voltage;
            memset((uint8*)&Voltage, 0x00, sizeof(OOP_DWORD3V_T));
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            Voltage.nNum = nNum;
            Voltage.rsv = 0;
            for (i = 0; i < nNum; i++)
            {
                if (i == 0)
                {            
                    Voltage.nValue[i] = MidTermSharedData.PhaAVoltHD;
                    set_bit_value((uint8*)&Voltage.rsv, 32, i);
                }
                if (i == 1)
                {            
                    Voltage.nValue[i] = MidTermSharedData.PhaBVoltHD;
                    set_bit_value((uint8*)&Voltage.rsv, 32, i);
                }
                if (i == 2)
                {            
                    Voltage.nValue[i] = MidTermSharedData.PhaCVoltHD;
                    set_bit_value((uint8*)&Voltage.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_DWORD3V_T);
               memcpy(pDesbuffer, &Voltage, sizeof(OOP_DWORD3V_T));
        }
            break;

        case 0x20000600:			   //(当前)零序电压
        {
            uint16 Voltage;
            memset((uint8*)&Voltage,0x00,sizeof(uint16));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Voltage = MidTermSharedData.PhaZeroVolt;
            *nDesLen = sizeof(uint16);
               memcpy(pDesbuffer, &Voltage, sizeof(uint16));
        }
            break;

        case 0x20010200:						//(当前)三相电流
        {
            OOP_INT3V_T Current;
            memset((uint8*)&Current,0x00,sizeof(OOP_INT3V_T));
            //nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            nNum = 3;  //目前只使用前3个数据项, 手动填3
            Current.nNum = nNum;
            Current.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.CurrentSignType.PhaAAppCurrentFlag == 1)
                        Current.nValue[i] = 0 - MidTermSharedData.PhaACurr;
                    else
                        Current.nValue[i] = MidTermSharedData.PhaACurr;
                    set_bit_value((uint8*)&Current.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.CurrentSignType.PhaBAppCurrentFlag == 1)
                        Current.nValue[i] = 0 - MidTermSharedData.PhaBCurr;
                    else
                        Current.nValue[i] = MidTermSharedData.PhaBCurr;
                    set_bit_value((uint8*)&Current.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.CurrentSignType.PhaCAppCurrentFlag == 1)
                        Current.nValue[i] = 0 - MidTermSharedData.PhaCCurr;
                    else
                        Current.nValue[i] = MidTermSharedData.PhaCCurr;
                    set_bit_value((uint8*)&Current.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_INT3V_T);
               memcpy(pDesbuffer, &Current, sizeof(OOP_INT3V_T));
        }
            break;
        
        case 0x20010400:                         //(当前)零线电流
        {
            int32 Current;
            memset((uint8*)&Current, 0x00, sizeof(int32));
            nNum = pOadInfo->TotalDataLen / pOadInfo->DataLen;
            Current = MidTermSharedData.PhaGCurr;
            *nDesLen = sizeof(int32);
            memcpy(pDesbuffer, &Current, sizeof(int32));
        }
            break;

        case 0x20010600:                        //(当前)零序电流
        {
            int32 Current;
            memset((uint8*)&Current,0x00,sizeof(int32));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            if(gMidPriMeasurePara.CurrentSignType.ZeroCurrentFlag == 1)//1负0正
            {
                Current = 0 - MidTermSharedData.PhaMCurr;
            }
            else
            {
                Current = MidTermSharedData.PhaMCurr;
            }
            *nDesLen = sizeof(int32);
               memcpy(pDesbuffer, &Current, sizeof(int32));
        }
            break;

        case 0x200F0200:						//(当前)电网频率
        {
            uint32 Frequency;
            Frequency = MidTermSharedData.LineFrz;
            *nDesLen = sizeof(uint32);
               memcpy(pDesbuffer, &Frequency, sizeof(uint32));
        }
            break;

        /***增加 电压不平衡率 begin***/
        case 0x20260200:						//电压不平衡率
        {
            uint16 VoltUnRate;			   
            VoltUnRate = MidTermSharedData.VoltUnbalanceRate;
            *nDesLen = sizeof(uint16);
               memcpy(pDesbuffer, &VoltUnRate, sizeof(uint16));
        }
            break;
        /***增加 电压不平衡率 end***/

        /***增加 电流不平衡率 begin***/
        case 0x20270200:						//电流不平衡率
        {
            uint16 CurrUnRate;			   
            CurrUnRate = MidTermSharedData.CurrUnbalanceRate;
            *nDesLen = sizeof(uint16);
               memcpy(pDesbuffer, &CurrUnRate, sizeof(uint16));
        }
            break;
        /***增加 电流不平衡率 end***/

        case 0x200A0200:						//(当前)瞬时总及分相功率因数
        {
            OOP_LONG4V_T Pf;
            memset((uint8*)&Pf,0x00,sizeof(OOP_LONG4V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Pf.nNum = nNum;
            Pf.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.PowerFactorType.AppPfFlag == 1)//1负0正
                    {
                        Pf.nValue[i] = 0 - MidTermSharedData.PowerFactor;
                    }
                    else
                    {
                        Pf.nValue[i] = MidTermSharedData.PowerFactor;
                    }
                    set_bit_value((uint8*)&Pf.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.PowerFactorType.PhaAAppPfFlag == 1)//1负0正
                    {
                        Pf.nValue[i] = 0 - MidTermSharedData.PhaAPowerFactor;
                    }
                    else
                    {
                        Pf.nValue[i] = MidTermSharedData.PhaAPowerFactor;
                    }
                    set_bit_value((uint8*)&Pf.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.PowerFactorType.PhaBAppPfFlag == 1)//1负0正
                    {
                        Pf.nValue[i] = 0 - MidTermSharedData.PhaBPowerFactor;
                    }
                    else
                    {
                        Pf.nValue[i] = MidTermSharedData.PhaBPowerFactor;
                    }
                    set_bit_value((uint8*)&Pf.rsv, 32, i);
                }
                if(i == 3)
                {
                    if(gMidPriMeasurePara.PowerFactorType.PhaCAppPfFlag == 1)//1负0正
                    {
                        Pf.nValue[i] = 0 - MidTermSharedData.PhaCPowerFactor;
                    }
                    else
                    {
                        Pf.nValue[i] = MidTermSharedData.PhaCPowerFactor;
                    }
                    set_bit_value((uint8*)&Pf.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_LONG4V_T);
               memcpy(pDesbuffer, &Pf, sizeof(OOP_LONG4V_T));
        }
            break;

        /* 增加   电表状态字1-7 begin*/
        case 0x20140200:                        //电表运行状态字1-7
        {
            OOP_METWORD_T OopMetword;
            memset((uint8*)&OopMetword,0x00,sizeof(OOP_METWORD_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            OopMetword.nNum = nNum;
            OopMetword.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw1, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
                else if(i == 1)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw2, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
                else if(i == 2)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw3, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
                else if(i == 3)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw4, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
                else if(i == 4)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw5, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
                else if(i == 5)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw6, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
                else if(i == 6)
                {            
                    memcpy(&OopMetword.metWord[i], (uint8*)&MidTermSharedData.MetStusPara.Rsw7, 2);
                    set_bit_value((uint8*)&OopMetword.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_METWORD_T);
               memcpy(pDesbuffer, &OopMetword, sizeof(OOP_METWORD_T));
        }
            break;
        
        /* 增加   电表状态字1-7 end*/

        /* 增加   视在功率 begin*/
        case 0x20060200:						//(当前)瞬时视在功率
        {
            OOP_INT4V_T Energy;
            memset((uint8*)&Energy,0x00,sizeof(OOP_INT4V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Energy.nNum = nNum;
            Energy.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.AppPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.NegApparentPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PosApparentPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaAAppPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaAAppPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaAAppPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaBAppPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaBAppPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaBAppPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
                if(i == 3)
                {
                    if(gMidPriMeasurePara.CurPowDir.BitSect.PhaCAppPowFlag == 1)
                        Energy.nValue[i] = 0 - MidTermSharedData.PhaCAppPower;
                    else
                        Energy.nValue[i] = MidTermSharedData.PhaCAppPower;
                    set_bit_value((uint8*)&Energy.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_INT4V_T);
               memcpy(pDesbuffer, &Energy, sizeof(OOP_INT4V_T));
        }
            break;

        /* 增加   视在功率 end*/

        /* 增加   相角 begin*/
        case 0x20020200:			   //(当前)电压相角
        {
            OOP_WORD3V_T Angle;
            memset((uint8*)&Angle,0x00,sizeof(OOP_WORD3V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Angle.nNum = nNum;
            Angle.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaAVolAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaAVoltAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaAVoltAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaBVolAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaBVoltAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaBVoltAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaCVolAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaCVoltAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaCVoltAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_WORD3V_T);
               memcpy(pDesbuffer, &Angle, sizeof(OOP_WORD3V_T));
        }
            break;
        case 0xAAAA0001:			   //(当前)电流相角
        {
            OOP_WORD3V_T Angle;
            memset((uint8*)&Angle,0x00,sizeof(OOP_WORD3V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Angle.nNum = nNum;
            Angle.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaACurrAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaACurrAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaACurrAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaBCurrAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaBCurrAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaBCurrAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaCCurrAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaCCurrAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaCCurrAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_WORD3V_T);
               memcpy(pDesbuffer, &Angle, sizeof(OOP_WORD3V_T));
        }
            break;

        case 0x20030200:			   //(当前)电压电流相角
        {
            OOP_WORD3V_T Angle;
            memset((uint8*)&Angle,0x00,sizeof(OOP_WORD3V_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Angle.nNum = nNum;
            Angle.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(i == 0)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaAVolCurrAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaAAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaAAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
                if(i == 1)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaBVolCurrAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaBAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaBAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
                if(i == 2)
                {
                    if(gMidPriMeasurePara.AngleDir.BitSect.PhaCVolCurrAngFlag == 1)
                        Angle.nValue[i] = 0 - MidTermSharedData.PhaCAngle;
                    else
                        Angle.nValue[i] = MidTermSharedData.PhaCAngle;
                    set_bit_value((uint8*)&Angle.rsv, 32, i);
                }
            }
            *nDesLen = sizeof(OOP_WORD3V_T);
               memcpy(pDesbuffer, &Angle, sizeof(OOP_WORD3V_T));
        }
            break;

        /* 增加   相角 end*/

        /* 增加 谐波 begin*/
        case 0x200D0200:			   //(当前)A相 电压谐波含有率（总及2…n次）
        {
            OOP_HARMONIC_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaAVoltHarmonic[i];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_T));
        }
            break;

        case 0x200D0300:			   //(当前)B相 电压谐波含有率（总及2…n次）
        {
            OOP_HARMONIC_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaBVoltHarmonic[i];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_T));
        }
            break;

        case 0x200D0400:			   //(当前)C相 电压谐波含有率（总及2…n次）
        {
            OOP_HARMONIC_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaCVoltHarmonic[i];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_T));
        }
            break;

        case 0x200E0200:			   //(当前)A相 电流谐波含有率（总及2…n次）
        {
            OOP_HARMONIC_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaACurrHarmonic[i];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_T));
        }
            break;

        case 0x200E0300:			   //(当前)B相 电流谐波含有率（总及2…n次）
        {
            OOP_HARMONIC_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaBCurrHarmonic[i];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_T));
        }
            break;

        case 0x200E0400:			   //(当前)C相 电流谐波含有率（总及2…n次）
        {
            OOP_HARMONIC_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaCCurrHarmonic[i];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_T));
        }
            break;

        /* 增加 谐波 end*/

        /* 增加 谐波含量 begin*/
        case 0x20330200:			   //(当前)A相 电压谐波含量（2…n次）
        {
            OOP_HARMONIC_U_VALUE_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_U_VALUE_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaAVoltHarmonicValue[i+1];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_U_VALUE_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_U_VALUE_T));
        }
            break;

        case 0x20330300:			   //(当前)B相 电压谐波含量（2…n次）
        {
            OOP_HARMONIC_U_VALUE_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_U_VALUE_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaBVoltHarmonicValue[i+1];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_U_VALUE_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_U_VALUE_T));
        }
            break;

        case 0x20330400:			   //(当前)C相 电压谐波含量（2…n次）
        {
            OOP_HARMONIC_U_VALUE_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_U_VALUE_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                Harmonic.nValue[i] = MidTermSharedData.PhaCVoltHarmonicValue[i+1];
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_U_VALUE_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_U_VALUE_T));
        }
            break;

        case 0x20340200:			   //(当前)A相 电流谐波含量（2…n次）
        {
            OOP_HARMONIC_I_VALUE_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_I_VALUE_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.HarmonicRateValueType.PhaACurrHarmonicValueFlag[i+1] == 1)//1负0正
                {
                    Harmonic.nValue[i] = 0 - MidTermSharedData.PhaACurrHarmonicValue[i+1];
                }
                else
                {
                    Harmonic.nValue[i] = MidTermSharedData.PhaACurrHarmonicValue[i+1];
                }
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_I_VALUE_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_I_VALUE_T));
        }
            break;

        case 0x20340300:			   //(当前)B相 电流谐波含量（2…n次）
        {
            OOP_HARMONIC_I_VALUE_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_I_VALUE_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.HarmonicRateValueType.PhaBCurrHarmonicValueFlag[i+1] == 1)//1负0正
                {
                    Harmonic.nValue[i] = 0 - MidTermSharedData.PhaBCurrHarmonicValue[i+1];
                }
                else
                {
                    Harmonic.nValue[i] = MidTermSharedData.PhaBCurrHarmonicValue[i+1];
                }
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_I_VALUE_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_I_VALUE_T));
        }
            break;

        case 0x20340400:			   //(当前)C相 电流谐波含量（2…n次）
        {
            OOP_HARMONIC_I_VALUE_T Harmonic;
            memset((uint8*)&Harmonic,0x00,sizeof(OOP_HARMONIC_I_VALUE_T));
            nNum = pOadInfo->TotalDataLen/pOadInfo->DataLen;
            Harmonic.nNum = nNum;
            Harmonic.rsv = 0;
            for(i=0; i<nNum; i++)
            {
                if(gMidPriMeasurePara.HarmonicRateValueType.PhaCCurrHarmonicValueFlag[i+1] == 1)//1负0正
                {
                    Harmonic.nValue[i] = 0 - MidTermSharedData.PhaCCurrHarmonicValue[i+1];
                }
                else
                {
                    Harmonic.nValue[i] = MidTermSharedData.PhaCCurrHarmonicValue[i+1];
                }
                set_bit_value((uint8*)&Harmonic.rsv, 32, i);
            }
            *nDesLen = sizeof(OOP_HARMONIC_I_VALUE_T);
               memcpy(pDesbuffer, &Harmonic, sizeof(OOP_HARMONIC_I_VALUE_T));
        }
            break;

        /* 增加 谐波含量 end*/

        /* 增加  交采参数 begin*/
        case 0x40080200:			   //备用套时区表切换时间
        {
            OOP_DATETIME_S_T data = {0};
            memcpy(&data, &MidTermSharedData.AddiZoneChangeTimeRD, sizeof(OOP_DATETIME_S_T));
            *nDesLen = sizeof(OOP_DATETIME_S_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_DATETIME_S_T));
        }
            break;
        case 0x40090200:			   //备用套日时段切换时间
        {
            OOP_DATETIME_S_T data = {0};
            memcpy(&data, &MidTermSharedData.AddiPeriChangeTimeRD, sizeof(OOP_DATETIME_S_T));
            *nDesLen = sizeof(OOP_DATETIME_S_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_DATETIME_S_T));
        }
            break;
        case 0x400C0200:			   //时区时段数
        {
            OOP_PERIOD_T data = {0};
            memcpy(&data, &MidTermSharedData.ZonePeriNumRD, sizeof(OOP_PERIOD_T));
            *nDesLen = sizeof(OOP_PERIOD_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_PERIOD_T));
        }
            break;
        case 0x40140200:			   //当前套时区表
        {
            OOP_TIMEZONE_T data = {0};
            memcpy(&data, &MidTermSharedData.CurrZoneTableRD, sizeof(OOP_TIMEZONE_T));
            *nDesLen = sizeof(OOP_TIMEZONE_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_TIMEZONE_T));
        }
            break;
        case 0x40150200:			   //备用套时区表
        {
            OOP_TIMEZONE_T data = {0};
            memcpy(&data, &MidTermSharedData.AddiZoneTableRD, sizeof(OOP_TIMEZONE_T));
            *nDesLen = sizeof(OOP_TIMEZONE_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_TIMEZONE_T));
        }
            break;
        case 0x40160200:			   //当前套日时段表
        {
            OOP_DAYPERIOD_T data = {0};
            if(0 == TermSharedData.g_nCurrDayPeriLabel)//当前套是第一套
            {
                memcpy(&data, &TermSharedData.CurrDayPeriTableRD, sizeof(OOP_DAYPERIOD_T));
            }
            else
            {
                memcpy(&data, &TermSharedData.AddiDayPeriTableRD, sizeof(OOP_DAYPERIOD_T));
            }
            *nDesLen = sizeof(OOP_DAYPERIOD_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_DAYPERIOD_T));
        }
            break;
        case 0x40170200:			   //备用套日时段表
        {
            OOP_DAYPERIOD_T data = {0};
            if(1 == TermSharedData.g_nCurrDayPeriLabel)//当前套是第二套
            {
                memcpy(&data, &TermSharedData.CurrDayPeriTableRD, sizeof(OOP_DAYPERIOD_T));
            }
            else
            {
                memcpy(&data, &TermSharedData.AddiDayPeriTableRD, sizeof(OOP_DAYPERIOD_T));
            }
            *nDesLen = sizeof(OOP_DAYPERIOD_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_DAYPERIOD_T));
        }
            break;
        case 0x41000200:			   //最大需量周期
        {
            uint8 data = 0;
            memcpy(&data, &MidTermSharedData.MaxDemandPeriodRD, sizeof(uint8));
            *nDesLen = sizeof(uint8);
               memcpy(pDesbuffer, &data, sizeof(uint8));
        }
            break;
        case 0x41010200:			   //滑差时间
        {
            uint8 data = 0;
            memcpy(&data, &MidTermSharedData.SlipDiffTimeRD, sizeof(uint8));
            *nDesLen = sizeof(uint8);
               memcpy(pDesbuffer, &data, sizeof(uint8));
        }
            break;
        case 0x41120200:			   //有功组合方式特征字
        {
            OOP_BITSTR8_T data = {0};
            memcpy(&data, &MidTermSharedData.ActPowCombWordRD, sizeof(OOP_BITSTR8_T));
            *nDesLen = sizeof(OOP_BITSTR8_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_BITSTR8_T));
        }
            break;
        case 0x41130200:			   //无功组合方式1特征字
        {
            OOP_BITSTR8_T data = {0};
            memcpy(&data, &MidTermSharedData.ReaPowComb1WordRD, sizeof(OOP_BITSTR8_T));
            *nDesLen = sizeof(OOP_BITSTR8_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_BITSTR8_T));
        }
            break;
        case 0x41140200:			   //无功组合方式2特征字
        {
            OOP_BITSTR8_T data = {0};
            memcpy(&data, &MidTermSharedData.ReaPowComb2WordRD, sizeof(OOP_BITSTR8_T));
            *nDesLen = sizeof(OOP_BITSTR8_T);
               memcpy(pDesbuffer, &data, sizeof(OOP_BITSTR8_T));
        }
            break;

        case 0x43000300:			   //版本信息
        {
            OOP_VERSION_T data;

            memset(&data, 0, sizeof(data));

            memcpy(data.szFactory.value, g_tVer.factory, 8);
            memcpy(data.szSoftVer.value, gVerBuf, 4);
            memcpy(data.szSoftDate.value, g_tVer.softDate, 8);
            memcpy(data.szHardVer.value, g_tVer.hardVer, 8);
            memcpy(data.szHardDate.value, g_tVer.hardDate, 8);
            memcpy(g_tVer.extend, gVerBuf, 4);
            #ifdef AREA_SHANDONG
            //计量芯片版本信息
            memcpy(&g_tVer.extend[5], &gVerBuf[4], 2);
            #endif
            memcpy(data.szExtend.value, g_tVer.extend, 8);
            
            *nDesLen = sizeof(OOP_VERSION_T);
            memcpy(pDesbuffer, &data, sizeof(OOP_VERSION_T));
            break;
        }
        

        /* 增加  交采参数 end*/
        
        default:
            return -1;
            break;
   }

    return 1;
}


/****************************************************************************
*模块编号：
*名称：Save07AcIntoDataCenter
*功能：将交采采样数据写入数据中心
*输入参数：
*输出参数：
*处理：
*返回：无
****************************************************************************/
uint16 Save07AcIntoDataCenter(uint8 type)
{
    const uint32 *pSaveTaskOAD = NULL;
    BOOL bNeedCheck = TRUE;  //是否需要检测变化死区(第一次直接存, 不需要检测)
    
    if(type == SAVE_TYPE_ENERGY)
    {
        //没有采集到数据，不进行存储
        if (!gSaveFlag.bFirstSampEnergy)
        {
            return 0;
        }
        
        if(gSaveFlag.bFirstSaveEnergy)
        {
            bNeedCheck = FALSE;
            gSaveFlag.bFirstSaveEnergy = FALSE;
            ACDB_FMT_DEBUG("启动或者初始化后 存储电量数据 存储标记[%d]\n", gSaveFlag.bFirstSaveEnergy);
        }
        pSaveTaskOAD = gSaveTaskEnergy;
    }
    else if(type == SAVE_TYPE_DEMAND)
    {
        //没有采集到数据，不进行存储
        if (!gSaveFlag.bFirstSampDemand)
        {
            return 0;
        }
        
        if(gSaveFlag.bFirstSaveDemand)
        {
            bNeedCheck = FALSE;
            gSaveFlag.bFirstSaveDemand = FALSE;
            ACDB_FMT_DEBUG("启动或者初始化后 存储需量数据 存储标记[%d]\n", gSaveFlag.bFirstSaveDemand);
        }
        pSaveTaskOAD = gSaveTaskDemand;
    }
    else if(type == SAVE_TYPE_REALTIME)
    {
        //没有采集到数据，不进行存储
        if (!gSaveFlag.bFirstSampRealtime)
        {
            return 0;
        }
        
        if(gSaveFlag.bFirstSaveRealtime)
        {
            bNeedCheck = FALSE;
            gSaveFlag.bFirstSaveRealtime = FALSE;
            ACDB_FMT_DEBUG("启动或者初始化后 存储实时数据 存储标记[%d]\n", gSaveFlag.bFirstSaveRealtime);
        }
        pSaveTaskOAD = gSaveTaskRealtime;
    }
    else if(type == SAVE_TYPE_HARMONIC)
    {
        //没有采集到数据，不进行存储
        if (!gSaveFlag.bFirstSampHarmonic)
        {
            return 0;
        }
        
        if(gSaveFlag.bFirstSaveHarmonic)
        {
            bNeedCheck = FALSE;
            gSaveFlag.bFirstSaveHarmonic = FALSE;
            ACDB_FMT_DEBUG("启动或者初始化后 存储谐波数据 存储标记[%d]\n", gSaveFlag.bFirstSaveHarmonic);
        }
        pSaveTaskOAD = gSaveTaskHarmonic;
    }
    else if(type == SAVE_TYPE_SPECIAL)
    {
        //没有采集到数据，不进行存储
        if (!gSaveFlag.bFirstSampSpecial)
        {
            return 0;
        }
        
        if(gSaveFlag.bFirstSaveSpecial)
        {
            bNeedCheck = FALSE;
            gSaveFlag.bFirstSaveSpecial = FALSE;
            ACDB_FMT_DEBUG("启动或者初始化后 存储特殊数据 存储标记[%d]\n", gSaveFlag.bFirstSaveSpecial);
        }
        pSaveTaskOAD = gSaveTaskSpecial;
    }
    else
    {
        return 0;
    }

    if (pSaveTaskOAD == NULL)
    {
        ACDB_FMT_DEBUG("没有找到对应的存储数据数组\n");
        return 0;
    }
    
    const Map645ToOop_NEW *pMap645ToOop = NULL;
    uint32  nOAD = 0;
    uint8   aSendBuff[MAX_DB_R_W_LEN] = {0};
    uint16  nSendBuffLen = 0;

    int     ret  = 0;
    NOMAL_OAD_T NomalOad;
    int     CheckRet = 0;  //越死区检查结果

    NomalOad.logicId = 1;  //逻辑地址
    NomalOad.infoNum = 0;  //信息点

    
    while((*pSaveTaskOAD) != 0xFFFFFFFF)
    {
        nOAD = *pSaveTaskOAD;

        //查找645与oad匹配关系
        pMap645ToOop = FindDetailInfoByOad(nOAD);
        if (pMap645ToOop == NULL)
        {
            ACDB_FMT_DEBUG("没有找到对应的数据标识, OAD[%08x]\n", nOAD);
            pSaveTaskOAD++;
            continue;
        }

        //查找交采采集数据
        memset(aSendBuff, 0x00, sizeof(aSendBuff));
        ret = Find07AcDataByOad(aSendBuff, &nSendBuffLen, pMap645ToOop);
        if(ret < 0)
        {
            ACDB_FMT_TRACE("没有找到对应的数据源, OAD[%08x] 错误码[%d]\n", nOAD, ret);
            pSaveTaskOAD++;
            continue;
        }

        //检查oad数据项有没有越过死区
        if(bNeedCheck)
        {
            CheckRet = CheckDataDeadZone(pMap645ToOop);
            if(CheckRet < 0)
            {
                pSaveTaskOAD++;
                continue;
            }
            else
            {
                ACDB_FMT_TRACE("越过死区! CheckRet=%d, nOAD=%08x\n", CheckRet, nOAD);
            }
        }

        //写入数据
        NomalOad.oad = pMap645ToOop->Oad;  //普通OAD
        NomalOad.classtag = CLASS_DATA_NORMAL;
        ret = db_write_nomal(gDataCenterClient, &NomalOad, (uint8*)aSendBuff, nSendBuffLen);
        if (ret == 0)
        {
            //写入成功之后刷新历史数据
            SynReportedInfoToHis(pMap645ToOop);
        }

        pSaveTaskOAD++;
    }

    return 1;
}

#if DESC("电压合格率计算",1)

/**
*********************************************************************
* @brief：      计算两次统计的时间差,结果为计算电压合格率使用，日月统计同时计算
* @param[out]：alterTime 两次统计的时间增加量, 2个元素，0-日，1-月
* @return：     void
*********************************************************************
*/
void sta_volt_monitor_time(int *alterTime)
{
    time_t tmpTime = 0;
    time_t tmpLstTime = 0;
    int  addTime = 0;     // 变化时间 
    int  detaTime[2] = {0}; // 2个元素，0-日，1-月,因过日月时计算不同，不能合一
    static BOOLEAN firstRun = 1;

    //这里曾经是ramdisk，可以用全局或static变量等价替换
    tmpTime = TimetoSec(gSaveCommonData.CurTime);
    tmpLstTime = TimetoSec(gSavePrivateData.LastCompTime);

    //计算两次统计间隔的分钟数,上次时间忽略掉非整分秒数
    addTime = (int)(tmpTime -(tmpLstTime/60)*60)/60;

    // 复位肯定是在1分钟内完成，有终端复位的情况不能丢失合格时间
    if(firstRun)
    {
        if (addTime > 1)
        {
            return;
        }

        firstRun = 0;
    }

    STAT_FMT_DEBUG("volt monitor curTime(%d) - lstTime(%d) = (%d)s ~ (%d)min.\n", tmpTime, tmpLstTime, tmpTime-tmpLstTime, addTime);

    /* 往回对时第一次不计算时间 */
    if (addTime < 0)
    {
        return;
    }

    /*上面处理过程日和月时间一致*/
    detaTime[STA_CALC_DAY] = addTime;
    detaTime[STA_CALC_MON] = addTime;

    /* 非正常 非0时0分的过日，对时过日*/
    if ((gSaveTimeFlag.BitSect.Day) && ((gSaveCommonData.CurTime.hh != 0x00) || (gSaveCommonData.CurTime.nn != 0x00)))
    {
        STAT_FMT_DEBUG("past day by datetime update.\n");
        // 经过了这一天,到此刻的越限时间全算
        detaTime[STA_CALC_DAY] = gSaveCommonData.CurTime.hh * 60 + gSaveCommonData.CurTime.nn;
    }

    /* 非正常 非1日0时0分的过月，对时过月*/
    if ((gSaveTimeFlag.BitSect.Month) && ((gSaveCommonData.CurTime.DD != 0x01) || (gSaveCommonData.CurTime.hh != 0x00) || (gSaveCommonData.CurTime.nn != 0x00)))
    {
        STAT_FMT_DEBUG("past month by datetime update.\n");
        // 经过了这一月,到此刻的越限时间全算
        detaTime[STA_CALC_MON] = (gSaveCommonData.CurTime.DD - 1) * 1440 + gSaveCommonData.CurTime.hh * 60 + gSaveCommonData.CurTime.nn;
    }

    memcpy(alterTime, detaTime, sizeof(detaTime));
}

/**
*********************************************************************
* @brief：      读取电压越限参数
* @param[out]：olimTime 越限时间数组
* @param[out]：qTime 合格时间数组
* @return：     void
*********************************************************************
*/
int sta_volt_param_read(OOP_VOLTPARAM_T *param)
{
    int ret = 0;
    NOMAL_OAD_T nomalOAD = {0};
    uint32 len = 0;
    uint32 inMaxLen = sizeof(OOP_VOLTPARAM_T);
    OOP_OAD_U voltpOAD = {0x40300200};

    nomalOAD.logicId = 1;
    memcpy(&nomalOAD.oad, &voltpOAD, sizeof(OOP_OAD_U));

    ret = db_read_nomal(gDataCenterClient, &nomalOAD, inMaxLen, (uint8*)param, &len);
    if(ret != 0 )
    {
        STAT_FMT_DEBUG("volt limit paramter read failed.ret(%d), logicId(%d), infoNum(%d), oad(0x%08x), inMaxLen(%d)\n",
            ret, nomalOAD.logicId, nomalOAD.infoNum, nomalOAD.oad.value, inMaxLen);
        return ret;
    }

    return ret;
}

/**
*********************************************************************
* @brief：      计算电压越上限时间累积值
* @param[in]： voltAccCfg 累加配置参数
* @param[out]：accTime  越限累积时间数组
* @param[out]：isQuality 是否合格
* @return：     void
*********************************************************************
*/
void sta_volt_uptime_calc(STA_VOLT_ACCTIME_CFG_T         voltAccCfg, uint32 i, uint16 *accTime, uint8 *isQuality)
{
    uint16 volt[3] = {0};
    uint16 acctime[12] = {0};
    OOP_WORD3V_T phaseVolt;   //分相电压
    OOP_VOLTPARAM_T voltParam; //电压合格率参数
    uint16 addTime;            //到此次统计时累积时间  
    uint8 upflag = 1;
    uint8 upupflag = 1;

    phaseVolt = voltAccCfg.phaseVolt;
    voltParam = voltAccCfg.voltParam;
    addTime = voltAccCfg.addTime;
    
    memcpy(volt, phaseVolt.nValue, phaseVolt.nNum*sizeof(uint16));
    memcpy(acctime, accTime, sizeof(acctime));

    //TODO 判读越限参数的有效性，据此设置upflag，upupflag,或在voltAccCfg中带下

    //计算电压越上限累积时间   
    if(upflag && !upupflag) 
    {
        if(volt[i] >= voltParam.upVolt)
        {
            acctime[i] += addTime;
            *isQuality = 0;
        }

    }
    else if(upflag && upupflag)                 
    {
        if(volt[i] >= voltParam.upVolt && volt[i] <voltParam.uupVolt) 
        {
            acctime[i] += addTime;
            *isQuality = 0;
        }
    }

    memcpy(accTime, acctime, sizeof(acctime));    
}

/**
*********************************************************************
* @brief：      计算电压越上上限时间累积值
* @param[in]： voltAccCfg 累加配置参数
* @param[out]：accTime  越限累积时间数组
* @param[out]：isQuality 是否合格
* @return：     void
*********************************************************************
*/
void sta_volt_uuptime_calc(STA_VOLT_ACCTIME_CFG_T         voltAccCfg, uint32 i, uint16 *accTime, uint8 *isQuality)
{
    uint16 volt[3] = {0};
    uint16 acctime[12] = {0};
    OOP_WORD3V_T phaseVolt;   //分相电压
    OOP_VOLTPARAM_T voltParam; //电压合格率参数
    uint16 addTime;            //到此次统计时累积时间  
    uint8 upupflag = 1;
    static  uint16 upupTime[3] = {0};  //越上上限累计时间
    uint8   upupLmtTime = 0;        //上上限持续时间参数
    uint16  upupRate = 0;           //上上限返回系数

    phaseVolt = voltAccCfg.phaseVolt;
    voltParam = voltAccCfg.voltParam;
    addTime = voltAccCfg.addTime;
    
    memcpy(volt, phaseVolt.nValue, phaseVolt.nNum*sizeof(uint16));
    memcpy(acctime, accTime, sizeof(acctime));

    //TODO 判读越限参数的有效性，据此设置upflag，upupflag,或在voltAccCfg中带下

    /* 计算电压越上上限累积时间 TODO (1-upupRate)计算不对，都是整数
       upupRate要设默认值，默认值可配么，不可配考虑用宏吧。 
    */
    if(upupflag)
    {
        if(upupTime[i] > 0)      //出现了越上上限
        {
            if(volt[i] > (voltParam.uupVolt * (1-upupRate))) //没有小于恢复值此时合格时间也不计
            {
                *isQuality = 0;
            }
        }
    
        if(volt[i] >= voltParam.uupVolt)
        {
            if(voltAccCfg.interval == STA_CALC_DAY)//只写一次日的,防止月统计时再写一次
            {
                upupTime[i] += addTime;
            }
    
            if(upupTime[i] >= upupLmtTime)
            {
            #if UPUP_EN == 1
                acctime[i] += addTime;
            #endif
                acctime[i+6] += addTime;
            }
            *isQuality = 0;
        }
        else
        {
            upupTime[i] = 0;
        }
    }

    memcpy(accTime, acctime, sizeof(acctime));    
}

/**
*********************************************************************
* @brief：      计算电压越下限时间累积值
* @param[in]： voltAccCfg 累加配置参数
* @param[out]：accTime  越限累积时间数组
* @param[out]：isQuality 是否合格
* @return：     void
*********************************************************************
*/
void sta_volt_lowtime_calc(STA_VOLT_ACCTIME_CFG_T         voltAccCfg, uint32 i, uint16 *accTime, uint8 *isQuality)
{
    uint16 volt[3] = {0};
    uint16 acctime[12] = {0};
    OOP_WORD3V_T phaseVolt;   //分相电压
    OOP_VOLTPARAM_T voltParam; //电压合格率参数
    uint16 addTime;            //到此次统计时累积时间  
    uint8 dwflag = 1;
    uint8 dwdwflag = 1;

    phaseVolt = voltAccCfg.phaseVolt;
    voltParam = voltAccCfg.voltParam;
    addTime = voltAccCfg.addTime;
    
    memcpy(volt, phaseVolt.nValue, phaseVolt.nNum*sizeof(uint16));
    memcpy(acctime, accTime, sizeof(acctime));

    //TODO 判读越限参数的有效性，据此设置dwflag，dwdwflag,或在voltAccCfg中带下

    //计算电压越下限累积时间
    if(dwflag && !dwdwflag) //不统计下下限,只统计下限
    {
        if(volt[i] <= voltParam.ldVolt)
        {
            acctime[i+3] += addTime;
            *isQuality = 0;
        }
    }
    else if(dwflag && dwdwflag)
    {
        if(volt[i] <= voltParam.ldVolt && volt[i] > voltParam.lldVolt) //小于下限大于下下限
        {
            acctime[i+3] += addTime;
            *isQuality = 0;
        }
    }

    memcpy(accTime, acctime, sizeof(acctime));    
}

/**
*********************************************************************
* @brief：      计算电压越下下限时间累积值
* @param[in]： voltAccCfg 累加配置参数
* @param[out]：accTime  越限累积时间数组
* @param[out]：isQuality 是否合格
* @return：     void
*********************************************************************
*/
void sta_volt_llowtime_calc(STA_VOLT_ACCTIME_CFG_T         voltAccCfg, uint32 i, uint16 *accTime, uint8 *isQuality)
{
    uint16 volt[3] = {0};
    uint16 acctime[12] = {0};
    OOP_WORD3V_T phaseVolt;   //分相电压
    OOP_VOLTPARAM_T voltParam; //电压合格率参数
    uint16 addTime;            //到此次统计时累积时间  
    uint8 dwdwflag = 1;
    static  uint16 dwdwTime[3] = {0};  //越下下限累计时间
    uint8   dwdwLmtTime = 0;        //下下限持续时间参数
    uint16  dwdwRate = 0;           //下下限返回系数

    phaseVolt = voltAccCfg.phaseVolt;
    voltParam = voltAccCfg.voltParam;
    addTime = voltAccCfg.addTime;
    
    memcpy(volt, phaseVolt.nValue, phaseVolt.nNum*sizeof(uint16));
    memcpy(acctime, accTime, sizeof(acctime));

    //TODO 判读越限参数的有效性，据此设置upflag，upupflag,或在voltAccCfg中带下

    /* 计算电压越下下限累积时间 TODO (1-upupRate)计算不对，都是整数
       upupRate要设默认值，默认值可配么，不可配考虑用宏吧。 */
    if(dwdwflag)
    {
        if(dwdwTime[i] > 0)      //出现了越下下限
        {
            if(volt[i] < (voltParam.lldVolt * (1+dwdwRate))) //没有大于下下限恢复值此时合格时间也不计
            {
                *isQuality = 0;
            }
        }
    
        if(volt[i] <= voltParam.lldVolt)
        {
            if(voltAccCfg.interval == STA_CALC_DAY)//只写一次日的,防止月统计时再写一次
            {
                dwdwTime[i] += addTime;
            }
    
            if(dwdwTime[i] >= dwdwLmtTime)
            {
            #if UPUP_EN == 1
                acctime[i+3] += addTime;
            #endif
                acctime[i+9] += addTime;
            }
            *isQuality = 0;
        }
        else
        {
            dwdwTime[i] = 0;
        }
    }

    memcpy(accTime, acctime, sizeof(acctime));    
}

/**
*********************************************************************
* @brief：      判断越限并计算越限时间累积值
* @param[in]： voltAccCfg 累加配置参数
* @param[out]：accTime  越限累积时间数组
* @param[out]：isQuality 是否合格
* @return：     void
*********************************************************************
*/
void sta_volt_overlim_judge(STA_VOLT_ACCTIME_CFG_T         voltAccCfg, uint32 i, uint16 *accTime, uint8 *isQuality)
{
  //TODO 判读越限参数的有效性，在voltAccCfg中带下

   //先做上上限判断
   sta_volt_uuptime_calc(voltAccCfg, i, accTime, isQuality);

   //上上限未越限才做上限判断
   if(*isQuality)
   {      
        sta_volt_uptime_calc(voltAccCfg, i, accTime, isQuality);

        //上限未越限才做下限判断
        if(*isQuality)
        {
            sta_volt_lowtime_calc(voltAccCfg, i, accTime, isQuality);
        
            //下限未越限才做下下限判断
            if(*isQuality)
            {
                sta_volt_llowtime_calc(voltAccCfg, i, accTime, isQuality);   
            }
        }
   }

   return;
}

/**
*********************************************************************
* @brief：      电压越限和合格时间累加
* @param[in]： voltAccCfg 累加配置参数
* @param[out]：accTime  越限累积时间数组
* @param[out]：quaTime 合格累积时间数组
* @return：     void
*********************************************************************
*/
void sta_volt_quaolimtime_acc(STA_VOLT_ACCTIME_CFG_T voltAccCfg, uint16 *accTime, uint16 *quaTime)
{
    uint16 volt[3] = {0};
    uint16 acctime[12] = {0};//上限(A,B,C),下限(A,B,C),上上限(A,B,C),下下限(A,B,C)
    uint32 i;
    uint8 isQuality;
    OOP_WORD3V_T phaseVolt;   //分相电压
    uint16 addTime;            //到此次统计时累积时间 
    uint8 powerType = 0;

    phaseVolt = voltAccCfg.phaseVolt;
    addTime = voltAccCfg.addTime;
    powerType = voltAccCfg.powerType;
    
    memcpy(volt, phaseVolt.nValue, phaseVolt.nNum*sizeof(uint16));
    memcpy(acctime, accTime, sizeof(acctime));

    STAT_FMT_DEBUG("calcType(%d) addTime(%d), voltParam value: up(%d), upup(%d), dw(%d), dwdw(%d)\n", 
        voltAccCfg.interval, voltAccCfg.addTime, voltAccCfg.voltParam.upVolt, voltAccCfg.voltParam.uupVolt, voltAccCfg.voltParam.ldVolt, voltAccCfg.voltParam.lldVolt);

    for(i = 0; i < 3; i++)
    {
        STAT_FMT_DEBUG("volt[%d] over limit time last: qualify(%d), up(%d), dw(%d), upup(%d), dwdw(%d)\n", 
            i, quaTime[i], acctime[i], acctime[i+3], acctime[i+6], acctime[i+9]);

        STAT_FMT_DEBUG("volt[%d] rt value(%d)\n", i, volt[i]); 
    }
    
    if(volt[0] == 0 && volt[1] == 0 && volt[2] == 0)//TODO 停电不判
    {
        return;
    }

    for(i = 0; i < 12; i++)
    {
        if(acctime[i] == NONEWORD)
        {
            acctime[i] = 0;
        }
    }

    for(i = 0; i < 3; i++)
    {
        //三相三线，B相不统计
        if((i == 1) && (powerType == PWRTYPE_3PHASE3)) continue;
        
        if(volt[i] == NONEWORD) continue;

        //默认电压合格
        isQuality = 1;

        sta_volt_overlim_judge(voltAccCfg, i, acctime, &isQuality);

        //经过判断后没有任何越限，则这段时间电压合格
        if(isQuality == 1)
        {
            quaTime[i]  += addTime;
        }

        // 日数据容错（日数据有错更明显）
        if (voltAccCfg.interval == STA_CALC_DAY)
        {
            if (acctime[i+0] > 1440)
                acctime[i+0] = 1440;
            if (acctime[i+3] > 1440)
                acctime[i+3] = 1440;
            if (acctime[i+6] > 1440)
                acctime[i+6] = 1440;
            if (acctime[i+9] > 1440)
                acctime[i+9] = 1440;
        }
    }

    //三相三线，B相直接合格
    if (powerType == PWRTYPE_3PHASE3)
    {
        quaTime[1] += addTime;
    }

    memcpy(accTime, acctime, sizeof(acctime));

    return;
}

/**
*********************************************************************
* @brief：      日电压合格率计算容错
* @param[in]： voltAccCfg 累加配置参数
* @param[in]： accTime  越限累积时间数组
* @param[out]：quaTime   合格累加时间数组
* @return：     void
*********************************************************************
*/
void sta_volt_fault_tolerant(const uint16 *accTime, uint16 *quaTime)
{
    uint16 acctime[12] = {0};
    uint16 extTime[3] = {0};
    uint8 i = 0;

    memcpy(acctime, accTime, sizeof(acctime));
    memcpy(extTime, quaTime, sizeof(extTime));

    for(i=0;i<3;i++)// 2013 COMMON BUG 
    {
        /*1440分钟是24小时*/
        if(extTime[i] > 1440)  
        {
            extTime[i] = 1440;  
        }
    }

    if(gSaveTimeFlag.BitSect.Day)
    {
        #if UPUP_EN == 1
            if((acctime[0]+acctime[3])<1440)
                extTime[0] = 1440-(acctime[0]+acctime[3]);
            else
                extTime[0] = 0;
        #else
            if((acctime[0]+acctime[3]+acctime[6]+acctime[9])<1440)
                extTime[0] = 1440-(acctime[0]+acctime[3]+acctime[6]+acctime[9]);
            else
                extTime[0] = 0;
        #endif

        #if UPUP_EN == 1
            if((acctime[1]+acctime[4])<1440)
                extTime[1] = 1440-(acctime[1]+acctime[4]);
            else
                extTime[1] = 0;
        #else
            if((acctime[1]+acctime[4]+acctime[7]+acctime[10])<1440)
                extTime[1] = 1440-(acctime[1]+acctime[4]+acctime[7]+acctime[10]);
            else
                extTime[1] = 0;
        #endif

        #if UPUP_EN == 1
            if((acctime[2]+acctime[5])<1440)
                extTime[2] = 1440-(acctime[2]+acctime[5]);
            else
                extTime[2] = 0;
        #else
            if((acctime[2]+acctime[5]+acctime[8]+acctime[11])<1440)
                extTime[2] = 1440-(acctime[2]+acctime[5]+acctime[8]+acctime[11]);
            else
                extTime[2] = 0;
        #endif                
    }    
    
    memcpy(quaTime, extTime, sizeof(extTime));
}

/**
*********************************************************************
* @brief：      统计电压越限累计时间,结果为计算电压合格率使用，日月统计同时计算
* @param[in]： cVolt 当前电压
* @param[out]：qolimTime 合格及越限累积时间数组
* @return：     void
*********************************************************************
*/
int sta_volt_qualifytime_calc(uint16 qolimTimeDay[5][3], uint16 qolimTimeMon[5][3])
{
    int ret = ERR_OK;;
    NOMAL_OAD_T nomalOAD = {0};
    uint32 len = 0;
    STA_VOLT_ACCTIME_CFG_T  voltAccCfg;
    static uint16 olimTime[STA_CALC_MAX][12] = {{0}}; /*用于存储上一次电压越限时间*/
    static uint16 qrateTime[STA_CALC_MAX][3] = {{0}}; /*用于存储上一次电压合格时间*/   
    uint16  acctime[STA_CALC_MAX][12] = {{0}};//三相，每相有越上限，越上上限，越下限，越下下限
    uint16  extTime[STA_CALC_MAX][3] = {{0}};       //电压合格时间,三相   
    int alterTime[STA_CALC_MAX] = {0};    //2个元素，0-日，1-月
    
    //读取电压越限参数
    ret = sta_volt_param_read(&voltAccCfg.voltParam);
    if(ret != 0)
    {
        return ret;
    }

    /* 读取已经记录的越限累积时间（即上次计算的）*/ //TODO 需要存到文件，防止掉电
    memcpy(acctime, olimTime, sizeof(acctime));
    memcpy(extTime, qrateTime, sizeof(extTime));

    /* 时间差计算，电压监测时间 2个元素，0-日，1-月*/
    sta_volt_monitor_time(alterTime);

    //读取交采实时电压
    voltAccCfg.phaseVolt.nNum = 3;
    voltAccCfg.phaseVolt.nValue[0] = TermSharedData.PhaAVolt;
    voltAccCfg.phaseVolt.nValue[1] = TermSharedData.PhaBVolt;
    voltAccCfg.phaseVolt.nValue[2] = TermSharedData.PhaCVolt;

    //交采参数，逻辑设备号为1
    nomalOAD.logicId = 1;
    nomalOAD.oad.value = 0x40100200;

    //交采接线方式
    ret = db_read_nomal(gDataCenterClient, &nomalOAD, sizeof(uint16), &voltAccCfg.powerType, &len);
    if((ret != 0) || (voltAccCfg.powerType == PWRTYPE_UNKNOWN))
    {
        STAT_FMT_DEBUG("power type read failed.ret(%d), logicId(%d), infoNum(%d), oad(0x%08x), inMaxLen(%d), powerType(%d), use default(PWRTYPE_3PHASE4).\n",
            ret, nomalOAD.logicId, nomalOAD.infoNum, nomalOAD.oad.value, sizeof(uint16), voltAccCfg.powerType);
        voltAccCfg.powerType = PWRTYPE_3PHASE4;
        ret = ERR_OK;
    }

    voltAccCfg.interval = STA_CALC_DAY;
    voltAccCfg.addTime = alterTime[STA_CALC_DAY];

    //计算越限与合格累积时间
    sta_volt_quaolimtime_acc(voltAccCfg, acctime[STA_CALC_DAY], extTime[STA_CALC_DAY]);

    voltAccCfg.interval = STA_CALC_MON;
    voltAccCfg.addTime = alterTime[STA_CALC_MON];

    //计算月越限与合格月累积时间
    sta_volt_quaolimtime_acc(voltAccCfg, acctime[STA_CALC_MON], extTime[STA_CALC_MON]);

    /*写越限累积时间*/
    memcpy(olimTime, acctime, sizeof(olimTime));

    //日数据做容错处理
    sta_volt_fault_tolerant(acctime[STA_CALC_DAY], extTime[STA_CALC_DAY]);

    /*写合格累积时间*/
    memcpy(qrateTime, extTime,sizeof(qrateTime));

    memcpy(qolimTimeDay[0],qrateTime[STA_CALC_DAY], sizeof(qolimTimeDay[0])); //合格
    memcpy(qolimTimeDay[1],olimTime[STA_CALC_DAY],   sizeof(qolimTimeDay[1]));//越上限   
    memcpy(qolimTimeDay[2],olimTime[STA_CALC_DAY]+3, sizeof(qolimTimeDay[2]));//越下限 
    memcpy(qolimTimeDay[3],olimTime[STA_CALC_DAY]+6, sizeof(qolimTimeDay[3]));//越上上限   
    memcpy(qolimTimeDay[4],olimTime[STA_CALC_DAY]+9, sizeof(qolimTimeDay[4]));//越下下限
    
    memcpy(qolimTimeMon[0],qrateTime[STA_CALC_MON], sizeof(qolimTimeMon[0])); //合格
    memcpy(qolimTimeMon[1],olimTime[STA_CALC_MON],   sizeof(qolimTimeMon[1]));//越上限   
    memcpy(qolimTimeMon[2],olimTime[STA_CALC_MON]+3, sizeof(qolimTimeMon[2]));//越下限 
    memcpy(qolimTimeMon[3],olimTime[STA_CALC_MON]+6, sizeof(qolimTimeMon[3]));//越上上限   
    memcpy(qolimTimeMon[4],olimTime[STA_CALC_MON]+9, sizeof(qolimTimeMon[4]));//越下下限  
    
    //过日或过月清当日数据,前面的数据已经写到对应OAD的，后面用从数据中心取
    if(gSaveTimeFlag.BitSect.Day)
    {
        STAT_FMT_DEBUG("past day clear qualify time.\n");
        memset(olimTime[STA_CALC_DAY], 0x00, sizeof(olimTime[STA_CALC_DAY]));
        memset(qrateTime[STA_CALC_DAY], 0x00, sizeof(qrateTime[STA_CALC_DAY]));
    }
    
    if(gSaveTimeFlag.BitSect.Month)
    {
        STAT_FMT_DEBUG("past month clear qualify time.\n");
        memset(olimTime[STA_CALC_MON], 0x00, sizeof(olimTime[STA_CALC_MON]));
        memset(qrateTime[STA_CALC_MON], 0x00, sizeof(qrateTime[STA_CALC_MON]));
    }   

    return ret;
}

/**
*********************************************************************
* @brief：      检查电压合格率是日还是月
* @param[in]： cVolt 当前电压
* @param[in]： qRate 合格率
* @return：     void
*********************************************************************
*/
void sta_volt_qualifyobjs_check(OOP_OAD_U qRate, STA_CALC_INTERVAL_E *interval)
{
    *interval = STA_CALC_MON;

    if(qRate.nIndex == 1)
    {
        *interval  = STA_CALC_DAY;
    }

    return;
}

/**
*********************************************************************
* @brief：      电压合格率计算,电压在正常范围内的时间占监测总时间的比率
* @param[in]： cVolt 当前电压
* @param[in]： qRate 合格率
* @return：     void
*********************************************************************
*/
void sta_volt_qualifyrate_unit_calc(uint16 *extTime, OOP_VOLTQR_T *voltObj)
{   
    uint32 tmTime=0;
        
    #if UPUP_EN == 1
    tmTime = (extTime[0] + extTime[1] + extTime[2]);
    #else
    tmTime = (extTime[0] + extTime[1] + extTime[2]+extTime[3]+extTime[4]);
    #endif

    //终端供电时间为0就不处理了
    if(tmTime != 0)
    {
        //电压合格率，%(*100) 换算-2(*100)，四舍五入,
        voltObj->dwTime1 = tmTime;           //电压监测时间
        #if UPUP_EN == 1
        voltObj->dwTime3 = extTime[1];       //电压超上限时间
        voltObj->dwTime4 = extTime[2];       //电压超下限时间
        #else 
        voltObj->dwTime3 = extTime[1]+extTime[3];
        voltObj->dwTime4 = extTime[2]+extTime[4];
        #endif

        voltObj->wRate1  = (uint16)(extTime[0]*10000/tmTime + 0.5);   //电压合格率
        //voltObj->wRate2 =  (uint16)((voltObj->dwTime3 + voltObj->dwTime4)*10000/tmTime);; //电压越限率   
        voltObj->wRate2 = 10000-voltObj->wRate1;
    }

    return;
}

/**
*********************************************************************
* @brief：      电压合格率计算,电压在正常范围内的时间占监测总时间的比率
* @param[in]： cVolt 当前电压
* @param[in]： qRate 合格率
* @return：     void
*********************************************************************
*/
void sta_volt_qualifyrate_calc(void)
{   
    int16 i;
    int ret = 0;
    uint16 extTime[5] = {0,0,0,0,0};    //电压合格时间
    uint16 phaseTimeDay[5][3] = {{0}};  //三相的日合格时间
    uint16 phaseTimeMon[5][3] = {{0}};  //三相的月合格时间    
    OOP_VOLTSTAT_T  voltObj;//电压合格率对象
    NOMAL_OAD_T nomalOAD = {0};
    
    ret = sta_volt_qualifytime_calc(phaseTimeDay, phaseTimeMon);
    if(ret != 0)
    {
        STAT_FMT_DEBUG("sta_volt_qualifytime_calc failed.\n");
        return;
    }
    
    nomalOAD.oad.value = 0x21310200; //A相电压合格率属性

    for(i = 0; i < 3; i++)
    {
        extTime[0] = phaseTimeDay[0][i]; //合格
        extTime[1] = phaseTimeDay[1][i]; //越上限
        extTime[2] = phaseTimeDay[2][i]; //越下限
        extTime[3] = phaseTimeDay[3][i]; //越上上限
        extTime[4] = phaseTimeDay[4][i]; //越下下限

        STAT_FMT_DEBUG("volt[%d] over limit time day: qualify(%d), up(%d), dw(%d), upup(%d), dwdw(%d)\n", 
            i, extTime[0], extTime[1], extTime[2], extTime[3], extTime[4]);

        sta_volt_qualifyrate_unit_calc(extTime, &voltObj.day);

        extTime[0] = phaseTimeMon[0][i];
        extTime[1] = phaseTimeMon[1][i];
        extTime[2] = phaseTimeMon[2][i];
        extTime[3] = phaseTimeMon[3][i];
        extTime[4] = phaseTimeMon[4][i];

        STAT_FMT_DEBUG("volt[%d] over limit time mon: qualify(%d), up(%d), dw(%d), upup(%d), dwdw(%d)\n", 
            i, extTime[0], extTime[1], extTime[2], extTime[3], extTime[4]);

        sta_volt_qualifyrate_unit_calc(extTime, &voltObj.mon);

        nomalOAD.logicId = 1;
        nomalOAD.oad.nObjID = 0x2131 + i; //分别遍历 A,B,C相的电压合格率
        nomalOAD.classtag = CLASS_DATA_NORMAL;
        
        ret = db_write_nomal(gDataCenterClient, &nomalOAD, (uint8*)&voltObj, sizeof(voltObj));
        if(ret != ERR_OK )
        {
            STAT_FMT_DEBUG("volt_qualifyrate_calc write failed.ret(%d), logicId(%d), infoNum(%d), oad(0x%08x), inMaxLen(%d)\n",
                ret, nomalOAD.logicId, nomalOAD.infoNum, nomalOAD.oad.value, sizeof(voltObj));
            return;
        }       
    }

    return;
}

#endif

#if DESC("冻结处理函数",1)
/**
*********************************************************************
* @brief：      设置时间更新标志
* @param[in]： NA
* @param[out]：NA
* @return：     void
*********************************************************************
*/
void sta_time_update_fset(BOOLEAN isUpdate)
{
    pthread_mutex_lock(&g_staUpdateData.mutex);

    g_staUpdateData.timeUpdate = isUpdate;
    
    pthread_mutex_unlock(&g_staUpdateData.mutex);    
}

int stat_change_update(int clientid, uint8 logicId, uint16 infoNum, uint32 value)
{    
    /* 使用互斥量进行加锁 */
    pthread_mutex_lock(&g_staUpdateData.mutex);

    switch(value)
    {
        case 0x50000300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<0);
        }break;
        case 0x50010300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<1);
        }break;      
        case 0x50020300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<2);
        }break;   
        case 0x50030300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<3);
        }break;  
        case 0x50040300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<4);
        }break;  
        case 0x50050300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<5);
        }break;            
        case 0x50060300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<6);
        }break;  
        case 0x50070300:
        {
            g_staUpdateData.frzInitFlag |= (1UL<<7);
        }break;

        default:break;        
    }


    /* 使用互斥量进行解锁 */
    pthread_mutex_unlock(&g_staUpdateData.mutex);    

    return 0;
}

/**
*********************************************************************
* @brief：     统计数据变更初始化
* @param[in]： NA
* @param[out]：NA
* @return：     -1 执行错误
*********************************************************************
*/
void stat_change_init()
{
    pthread_mutex_init(&g_staUpdateData.mutex, NULL);
}

/**
*********************************************************************
* @brief：      统计间隔分析，统计周期处理函数提供统一的输入
* @param[in]： oad       待分析的OAD
* @param[out]：interval 分析出的间隔
* @return：     void
*********************************************************************
*/
void sta_interval_analyse(OOP_OAD_U oad, OOP_TI_SPAN_E *interval)
{

    if(oad.nObjID == STA_FROZEN_SEC)
    {
        *interval = TI_SEC; 
    }

    if(oad.nObjID == STA_FROZEN_MIN)
    {
        *interval = TI_MIN;    
    }

    if(oad.nObjID == STA_FROZEN_HOUR)
    {
        *interval = TI_HOUR;    
    } 

    if(oad.nObjID == STA_FROZEN_DAY)
    {
        *interval =TI_DAY; 
    }

    if(oad.nObjID == STA_FROZEN_MON)
    {
        *interval = TI_MON;    
    }

    if(oad.nObjID == STA_FROZEN_YEAR)
    {
        *interval = TI_YEAR;    
    }      
}

/**
*********************************************************************
* @brief：      下一次统计时间刷新
* @param[in]： pTmpNode 冻结参数
* @param[out]：NA
* @return：     time_t 下一次冻结时间
*********************************************************************
*/
void sta_nexttime_update(OOP_TI_T ti, time_t lasttime, time_t *nextFrzTime)
{
    *nextFrzTime = lasttime;

    DT_TimeAddInv(nextFrzTime, ti);

    return;
}

/**
*********************************************************************
* @brief：      初始化上次采集时间
* @param[in]： lastTime
* @param[out]：NA
* @return：     void
*********************************************************************
*/
void sta_last_time_init(OOP_TI_T freq, time_t *lastTime)
{
    time_t curTime = TimetoSec(gSaveCommonData.CurTime);
    OOP_DATETIME_S_T begin={2000,1,1,0,0,0,0};//2000-01-01 00:00:00
    time_t beginTime;
    DT_DateTimeShort2Time(&begin,&beginTime);
    time_t tmpLastTime = 0;

    //周期为0，表示立即冻结，冻结时间就是当前时间
    if(freq.value == 0)
    {
        *lastTime = curTime;
    }
    else
    {
        /* 
         算法目的，计算距离下一个过秒，过分，过时，过日，过月，过年剩余的秒数,再减掉一个周期。
        */
        switch(freq.unit)
        {
            case TI_SEC:
                tmpLastTime = (curTime-beginTime)/freq.value;   //TODO 间隔可以为0
                tmpLastTime = beginTime+tmpLastTime*freq.value; //结果小与或等于curTime
                if(tmpLastTime==curTime)//相等时，推后一个间隔，后面计算的下次时间会等于curTime,立即进入统计
                {
                    tmpLastTime = tmpLastTime-freq.value;
                }
                *lastTime  = tmpLastTime;
                break;
            case TI_MIN:
                tmpLastTime = (curTime-beginTime)/(60*freq.value);
                tmpLastTime = beginTime+(tmpLastTime*(60*freq.value));
                if(tmpLastTime==curTime)
                {
                    tmpLastTime = tmpLastTime-60*freq.value;
                }
                *lastTime = tmpLastTime;
                break;
            case TI_HOUR:
                tmpLastTime = (curTime-beginTime)/(3600*freq.value);
                tmpLastTime = beginTime+(tmpLastTime*(3600*freq.value));
                if(tmpLastTime==curTime)
                {
                    tmpLastTime = tmpLastTime-3600*freq.value;
                }
                *lastTime = tmpLastTime;
                break;
            case TI_DAY:
                tmpLastTime = (curTime-beginTime)/(86400*freq.value);
                tmpLastTime = beginTime+(tmpLastTime*(86400*freq.value));
                if(tmpLastTime==curTime)
                {
                    tmpLastTime = tmpLastTime-86400*freq.value;
                }
                *lastTime = tmpLastTime;
                break;
            case TI_MON:
                while(beginTime<curTime)
                {
                    DT_TimeAddInv(&beginTime,freq);
                }
                DT_TimeSubInv(&beginTime,freq);
                *lastTime = beginTime;
                break;
            case TI_YEAR:
                while(beginTime<curTime)
                {
                    DT_TimeAddInv(&beginTime,freq);
                }
                DT_TimeSubInv(&beginTime,freq);
                *lastTime = beginTime;
                break;
            default:
                *lastTime = 0;
                break;
        }   
    }
    
    DT_Time2DateTimeShort(*lastTime, &begin);

    STAT_FMT_DEBUG("init last time: %04d-%02d-%02d:%02d:%02d:%02d\n", 
        begin.year,begin.month,begin.day,begin.hour,begin.minute,begin.second);

    return;
}


//清空冻结运行参数列表
FrzRunParaList_t* sta_frozen_paralist_clear(FrzRunParaList_t* pFrzRunParaListHead)
{
    FrzRunParaList_t *pTmpNode;//临时节点

    while(pFrzRunParaListHead!=NULL)
    {
        pTmpNode = pFrzRunParaListHead->pNext;
        if(pFrzRunParaListHead->frzRunPara.pColOad!=NULL)
            free(pFrzRunParaListHead->frzRunPara.pColOad);
        free(pFrzRunParaListHead);
        pFrzRunParaListHead = pTmpNode;
    }
    return NULL;
}

//增加关联对象
FrzRunParaList_t* sta_frozen_paranode_add(FrzRunParaList_t* pFrzRunParaListHead, OOP_FROZENOBJ_T incOadInfo)
{
    uint16 i;
    FrzRunParaList_t *pTmpNode,*pCurNode;//临时节点
    OOP_OAD_U *pColOad;
    pTmpNode = pFrzRunParaListHead;
    pCurNode = pFrzRunParaListHead;
    while(pTmpNode != NULL)
    {
        pCurNode = pTmpNode;
        if(pTmpNode->frzRunPara.period == incOadInfo.nPeriod
            && pTmpNode->frzRunPara.storeDepth == incOadInfo.nDepth)
        {
            if(pTmpNode->frzRunPara.pColOad == NULL)
                pTmpNode->frzRunPara.oadNum = 0;
            for(i=0;i<pTmpNode->frzRunPara.oadNum;i++)
            {
                if(pTmpNode->frzRunPara.pColOad[i].nObjID == incOadInfo.oad.nObjID
                    &&pTmpNode->frzRunPara.pColOad[i].attID == incOadInfo.oad.attID
                    &&pTmpNode->frzRunPara.pColOad[i].nIndex == incOadInfo.oad.nIndex)
                {
                    break;
                }
            }
            if(i>=pTmpNode->frzRunPara.oadNum)
            {
                if(i==0) 
                {
                    STAT_FMT_DEBUG("frozen_paranode_add：not possible.\n");
                    i=1;
                }
                
                pColOad = (OOP_OAD_U*)malloc((i+1)*sizeof(OOP_OAD_U));
                memcpy((uint8*)pColOad,(uint8*)pTmpNode->frzRunPara.pColOad,(i)*sizeof(OOP_OAD_U));
                pColOad[i] = incOadInfo.oad;
                free(pTmpNode->frzRunPara.pColOad);
                pTmpNode->frzRunPara.pColOad = pColOad; 
                pTmpNode->frzRunPara.oadNum++; 
            }
            break;
        }
        pTmpNode = pTmpNode->pNext;
    }
    //新增结点并添加到链接尾部
    if(pTmpNode==NULL)
    {
        pTmpNode = (FrzRunParaList_t*)malloc(sizeof(FrzRunParaList_t));
        memset((uint8*)pTmpNode,0x00,sizeof(FrzRunParaList_t));
        pTmpNode->frzRunPara.period = incOadInfo.nPeriod;
        pTmpNode->frzRunPara.storeDepth = incOadInfo.nDepth;
        pTmpNode->frzRunPara.oadNum = 1;
        pTmpNode->frzRunPara.pColOad = (OOP_OAD_U*)malloc(sizeof(OOP_OAD_U));
        pTmpNode->frzRunPara.pColOad[0] = incOadInfo.oad;

        if(pCurNode == NULL)
        {
            return pTmpNode;
        }
        else 
        {
            pCurNode->pNext = pTmpNode;
        }        
    }

    return pFrzRunParaListHead;
}

/**
*********************************************************************
* @brief：      从数据中心获取冻结方案
* @param[in]： NA
* @param[out]：NA
* @return：     void
*********************************************************************
*/
int sta_frozen_scheme_get(const OOP_OAD_U mainOad, OOP_FROZENSETS_T *frzPara)
{
    NOMAL_OAD_T nomalOAD;
    uint32 len = 0;

    MEMZERO(&nomalOAD, sizeof(NOMAL_OAD_T));

    //关联对象属性表
    nomalOAD.logicId = 1;
    nomalOAD.oad.value = mainOad.value + 0x300;
    
    return db_read_nomal(gDataCenterClient, &nomalOAD, sizeof(OOP_FROZENSETS_T), (uint8*)frzPara, &len);
}

//根据冻结对象标识初始化冻结运行参数
FrzRunParaList_t* sta_frozen_paralist_init(OOP_OAD_U FrzOAD,FrzRunParaList_t* pFrzRunParaListHead)
{
    OOP_TI_SPAN_E time_span;
    OOP_TI_T tmpTI;    
    FrzRunParaList_t *pTmpNode;//临时节点
    pFrzRunParaListHead = sta_frozen_paralist_clear(pFrzRunParaListHead);//清空链表
    OOP_FROZENSETS_T frozensets;
    uint16 i = 0;
    memset(&frozensets, 0x00, sizeof(OOP_FROZENSETS_T));

    /*从数据中心读取配置*/
    sta_frozen_scheme_get(FrzOAD,&frozensets);

    STAT_FMT_DEBUG("frzOAD(0x%08x), nObjs(%d)\n", FrzOAD.value, frozensets.nNum);
    
    //初始化关联属性表
    for(i = 0; i < frozensets.nNum; i++)
    {
        STAT_FMT_DEBUG("oad(0x%08x), nPeriod(%d), nDepth(%d)\n",
            frozensets.objs[i].oad.value, frozensets.objs[i].nPeriod,frozensets.objs[i].nDepth);
        pFrzRunParaListHead = sta_frozen_paranode_add(pFrzRunParaListHead,frozensets.objs[i]);
    }
    
    //初始化上一次冻结时间
    //先按照停电不补冻结设计    
    pTmpNode = pFrzRunParaListHead;
    sta_interval_analyse(FrzOAD, &time_span);

    while(pTmpNode!=NULL)
    {
        //需要用这个OAD去写记录表
        pTmpNode->frzOAD.value = FrzOAD.value + 0x200;
        
        tmpTI.unit = time_span;
        tmpTI.value = pTmpNode->frzRunPara.period;
        
        sta_last_time_init(tmpTI,&pTmpNode->frzRunPara.lastFrzTm);
        
        pTmpNode = pTmpNode->pNext;
    }
    
    return pFrzRunParaListHead;
}

/**
*********************************************************************
* @brief：      冻结功能处理
* @param[in]： NA
* @param[out]：NA
* @return：     void
*********************************************************************
*/
void sta_frozen_init()
{
    uint8 i;
    OOP_OAD_U frzOad = {0x50000000};
    uint8 frzInitFlg=0;

    pthread_mutex_lock(&g_staUpdateData.mutex);
    
    /*冻结参数改变，获取冻结运行参数*/
    frzInitFlg = g_staUpdateData.frzInitFlag;
    
    /*遍历每一个节点*/
    for(i=0; i<STA_FROZEN_OBJNUMS; i++)
    {
        if(frzInitFlg&(1UL<<i))
        {
            frzOad.nObjID = STA_FROZEN_TRAN + i;

            //TODO 后续改为数组，链表的时候OI动态写，过滤终端不需要的OI
            g_staFrozenParaList[i] = sta_frozen_paralist_init(frzOad, g_staFrozenParaList[i]);

            frzInitFlg &= ~(1UL<<i);

            g_frozen_index[i] = 0; //冻结记录序号，每次冻结参数变更，初始化为0
        }
    }
    
    g_staUpdateData.frzInitFlag = frzInitFlg;

    pthread_mutex_unlock(&g_staUpdateData.mutex);    

    return;
}

/**
*********************************************************************
* @brief：      读取冻结列对象数据
* @param[in]： ColOAD 冻结关联对象OAD
* @param[out]：outData 输出缓冲区
* @param[in]： outLen  输出缓大小
* @return：     真实数据长度
*********************************************************************
*/
int sta_frozen_objdata_read(OOP_OAD_U ColOAD, uint8 *outData, uint32 outLen, uint32 *realLen)
{
    int ret = ERR_OK;
    NOMAL_OAD_T nomalOAD = {0};   
    uint32 nIndex = ColOAD.nIndex;
    OOP_VOLTSTAT_T VOLTSTAT_T;

    nomalOAD.logicId = 1; //交采
    nomalOAD.oad.value = ColOAD.value&0xffffff00;
    
    ret = db_read_nomal(gDataCenterClient, &nomalOAD, outLen, outData, realLen);
    if(ret != 0)
    { 
        STAT_FMT_DEBUG("frozen data read failed.ret(%d), logicId(%d), infoNum(%d), oad(0x%08x), inMaxLen(%d)\n",
            ret, nomalOAD.logicId, nomalOAD.infoNum, nomalOAD.oad.value, outLen);

        return ret;
    }

    //交采规约还不完整，专门为读电压合格率定制
    if((ColOAD.nObjID == 0x2131)||(ColOAD.nObjID == 0x2132)||(ColOAD.nObjID == 0x2133))
    {
        memcpy(&VOLTSTAT_T, outData, *realLen);
        
        switch(nIndex)
        {
            case 0: 
            {
                memcpy(outData, &VOLTSTAT_T, sizeof(VOLTSTAT_T)); 
                *realLen = sizeof(OOP_VOLTSTAT_T);
            }break;

            case 1: 
            {
                memcpy(outData, &VOLTSTAT_T.day, sizeof(OOP_VOLTQR_T)); 
                *realLen = sizeof(OOP_VOLTQR_T);
                STAT_FMT_DEBUG("日合格率: 监测时间 %d 合格率 %d 越限率 %d 越上限时间 %d 越下限时间 %d\n", 
                    VOLTSTAT_T.day.dwTime1, VOLTSTAT_T.day.wRate1, VOLTSTAT_T.day.wRate2, VOLTSTAT_T.day.dwTime3, VOLTSTAT_T.day.dwTime4);
                
            }break;
            
            case 2: 
            {
                memcpy(outData, &VOLTSTAT_T.mon, sizeof(OOP_VOLTQR_T)); 
                *realLen = sizeof(OOP_VOLTQR_T);
                STAT_FMT_DEBUG("月合格率: 监测时间 %d 合格率 %d 越限率 %d 越上限时间 %d 越下限时间 %d\n", 
                    VOLTSTAT_T.mon.dwTime1, VOLTSTAT_T.mon.wRate1, VOLTSTAT_T.mon.wRate2, VOLTSTAT_T.mon.dwTime3, VOLTSTAT_T.mon.dwTime4);
            }break;  
        }        
    }

    return ret;
}

/**
*********************************************************************
* @brief：      写一条冻结记录
* @param[in]： ColOAD 冻结关联对象OAD
* @param[out]：outData 输出缓冲区
* @param[in]： outLen  输出缓大小
* @return：     真实数据长度
*********************************************************************
*/
uint16 sta_frozen_record_write(const OOP_OAD_U mainOad, OOP_FROZENOBJ_T frzObjs, BOOLEAN bStart, time_t storeTime, const uint8 *dataBuf, const uint32 dataLen)
{
    int ret = ERR_OK;
    WRITE_RECORD_T inData;
    uint32 storeNo = 0;
    OOP_DATETIME_S_T tmStore = {0};

    MEMZERO(&inData, sizeof(WRITE_RECORD_T));
    
//    inData.MAC = MAC;

    // 注：+8个小时(28800)转成格林时间
    inData.recordOAD.logicId = 1;
    inData.colStoreTm =  storeTime + COMPENSATION_TIME;
    inData.recordOAD.classtag = CLASS_DATA_NORMAL;
    inData.recordOAD.road.oadMain.value = mainOad.value;
    inData.recordOAD.road.oadCols.nNum = 1;

    //如果是第一个，那么把冻结序号和冻结时间也作为关联数据写入
    if(bStart == TRUE)
    {
        STAT_FMT_TRACE("tmn frozen record write: mainOad = %lu(0x%08x)\n", 
            inData.recordOAD.road.oadMain.value, inData.recordOAD.road.oadMain.value);
        
        //冻结记录序号
        inData.recordOAD.road.oadCols.oad[0].value = 0x20230200;
        inData.inDatalen = 4;
        memcpy(inData.inDataBuf, &g_frozen_index[mainOad.nObjID-STA_FROZEN_TRAN], inData.inDatalen);
        g_frozen_index[mainOad.nObjID-STA_FROZEN_TRAN]++;
        
        ret = db_write_record(gDataCenterClient, &inData, &storeNo);
        if(ret != ERR_OK)
        {
            return ret;
        }
        
        STAT_FMT_TRACE("tmn frozen record write: oadCols.oad[0] = %lu(0x%08x)\n", 
            inData.recordOAD.road.oadCols.oad[0].value, inData.recordOAD.road.oadCols.oad[0].value);

        //数据冻结时间
        DT_Time2DateTimeShort(storeTime, &tmStore);
        inData.recordOAD.road.oadCols.oad[0].value = 0x20210200;
        inData.inDatalen = sizeof(OOP_DATETIME_S_T);
        memcpy(inData.inDataBuf, &tmStore, inData.inDatalen);
        
        ret = db_write_record(gDataCenterClient, &inData, &storeNo); 
        if(ret != ERR_OK)
        {
            return ret;
        }
        
        STAT_FMT_TRACE("tmn frozen record write: oadCols.oad[0] = %lu(0x%08x)\n", 
            inData.recordOAD.road.oadCols.oad[0].value, inData.recordOAD.road.oadCols.oad[0].value);
    }
    
    inData.inDatalen = dataLen;
    memcpy(inData.inDataBuf, dataBuf, dataLen);

    inData.recordOAD.road.oadCols.nNum = 1;
    inData.recordOAD.road.oadCols.oad[0].value = frzObjs.oad.value;

    ret = db_write_record(gDataCenterClient, &inData, &storeNo);    
    if(ret != ERR_OK)
    {
        return ret;
    }

    STAT_FMT_TRACE("tmn frozen record write: oadCols.oad[0] = %lu(0x%08x)\n", 
        inData.recordOAD.road.oadCols.oad[0].value, inData.recordOAD.road.oadCols.oad[0].value);

    return ret;
}

/**
*********************************************************************
* @brief：      执行冻结
* @param[in]： pTmpNode 冻结参数
* @param[out]：NA
* @return：     time_t 下一次冻结时间
*********************************************************************
*/
void sta_frozen_execute(time_t storeTime, FrzRunParaList_t *pTmpNode)
{
    int ret = ERR_OK;
    uint8 FrzDataBuff[300];
    uint32 FrzDataLen;
    uint16 j;
    OOP_FROZENOBJ_T frzObjs;
    BOOLEAN bStart = TRUE;

    STAT_FMT_DEBUG("---------frozen execute start--------\n");

    frzObjs.nPeriod = pTmpNode->frzRunPara.period;
    frzObjs.nDepth= pTmpNode->frzRunPara.storeDepth;

    /*遍历每个关联对象属性*/
    for(j = 0; j < pTmpNode->frzRunPara.oadNum; j++)
    {
        frzObjs.oad = pTmpNode->frzRunPara.pColOad[j];

        /*读一个普通OAD db_read_nomal*/
        ret = sta_frozen_objdata_read(frzObjs.oad, FrzDataBuff, sizeof(FrzDataBuff), &FrzDataLen);
        if(ret != 0)
        {
            STAT_FMT_DEBUG("sta_frozen_objdata_read failed. ret(%d) OAD(0x%08x)\n", ret, frzObjs.oad.value);
            continue;   
        }
        
        /* 写一个记录型数据 db_write_record*/
        ret = sta_frozen_record_write(pTmpNode->frzOAD, frzObjs, bStart, storeTime, FrzDataBuff, FrzDataLen);
        if(ret != 0)
        {
            STAT_FMT_DEBUG("sta_frozen_record_write failed. ret(%d), mainOAD(0x%08x), subOAD(0x%08x)\n", ret, pTmpNode->frzOAD.value, frzObjs.oad.value);
            return;   
        }

        bStart = FALSE;
    }

    STAT_FMT_DEBUG("---------frozen execute end--------\n");

    return;
}

/**
*********************************************************************
* @brief：      冻结时间刷新
* @param[in]： NA
* @param[out]：NA
* @return：     void
*********************************************************************
*/
void sta_frozen_lasttime_reinit(void)
{
    uint8 i = 0;
    FrzRunParaList_t *pstPara = NULL;
    OOP_TI_SPAN_E time_span;
    OOP_TI_T tmpTI;    

    for(i = 0; i < STA_FROZEN_OBJNUMS; i++)
    {
        if(g_staFrozenParaList[i] == NULL)
        {
            continue;
        }
        
        pstPara = g_staFrozenParaList[i];
                
        sta_interval_analyse(pstPara->frzOAD, &time_span);

        STAT_FMT_DEBUG("frozen last time reinit. oda(0x%08x)\n", pstPara->frzOAD.value);

        //初始化上一次时间
        while(pstPara!=NULL)
        {
            tmpTI.unit = time_span;
            tmpTI.value = pstPara->frzRunPara.period;
            
            sta_last_time_init(tmpTI,&pstPara->frzRunPara.lastFrzTm);
            
            pstPara = pstPara->pNext;
        }

    }
    
    return;
}

/**
*********************************************************************
* @brief：      冻结功能处理
* @param[in]： NA
* @param[out]：NA
* @return：     void
*********************************************************************
*/
void sta_frozen_proc()
{
    uint8 i;
    FrzRunParaList_t *pTmpNode;//临时节点
    time_t nextFrzTime;        //时间为秒数，方便转化为协议要求的时间格式
    time_t curTime = TimetoSec(gSaveCommonData.CurTime);
    OOP_TI_SPAN_E time_span;
    OOP_TI_T time_interval;
    
    /*初始化冻结参数链表*/
    sta_frozen_init();

    /*遍历冻结类型（秒，分，时，日，月，年）没有12种*/
    for(i = 0; i < STA_FROZEN_OBJNUMS; i++)
    {
        if(g_staFrozenParaList[i] == NULL)
        {
            continue;
        }
        
        pTmpNode = g_staFrozenParaList[i];

        sta_interval_analyse(pTmpNode->frzOAD, &time_span);
        
        while(pTmpNode != NULL)
        {
            time_interval.unit = time_span;
            time_interval.value = pTmpNode->frzRunPara.period;
            
            sta_nexttime_update(time_interval, pTmpNode->frzRunPara.lastFrzTm, &nextFrzTime);

            /* 满足冻结条件，执行冻结 */
            if((nextFrzTime!=0) && (nextFrzTime<=curTime))
            {
                sta_frozen_execute(nextFrzTime, pTmpNode);
                pTmpNode->frzRunPara.lastFrzTm = nextFrzTime;
            }
            
            pTmpNode = pTmpNode->pNext;
        }
        
    }
    
    return;
}

#endif

