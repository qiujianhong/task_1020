/*
*********************************************************************
* Copyright(C) 2019 China Electric Power Research Institute
* All rights reserved. 
* @brief：   APP交互消息解析
* @date：    2020/1/3
* @history： 
*********************************************************************
*/
#include "baseCommon.h"
#include "mapmsg_split.h"

static uint16 g_fcstab[256] =
{
    0x0000,0x1189,0x2312,0x329b,0x4624,0x57ad,0x6536,0x74bf,
    0x8c48,0x9dc1,0xaf5a,0xbed3,0xca6c,0xdbe5,0xe97e,0xf8f7,
    0x1081,0x0108,0x3393,0x221a,0x56a5,0x472c,0x75b7,0x643e,
    0x9cc9,0x8d40,0xbfdb,0xae52,0xdaed,0xcb64,0xf9ff,0xe876,
    0x2102,0x308b,0x0210,0x1399,0x6726,0x76af,0x4434,0x55bd,
    0xad4a,0xbcc3,0x8e58,0x9fd1,0xeb6e,0xfae7,0xc87c,0xd9f5,
    0x3183,0x200a,0x1291,0x0318,0x77a7,0x662e,0x54b5,0x453c,
    0xbdcb,0xac42,0x9ed9,0x8f50,0xfbef,0xea66,0xd8fd,0xc974,
    0x4204,0x538d,0x6116,0x709f,0x0420,0x15a9,0x2732,0x36bb,
    0xce4c,0xdfc5,0xed5e,0xfcd7,0x8868,0x99e1,0xab7a,0xbaf3,
    0x5285,0x430c,0x7197,0x601e,0x14a1,0x0528,0x37b3,0x263a,
    0xdecd,0xcf44,0xfddf,0xec56,0x98e9,0x8960,0xbbfb,0xaa72,
    0x6306,0x728f,0x4014,0x519d,0x2522,0x34ab,0x0630,0x17b9,
    0xef4e,0xfec7,0xcc5c,0xddd5,0xa96a,0xb8e3,0x8a78,0x9bf1,
    0x7387,0x620e,0x5095,0x411c,0x35a3,0x242a,0x16b1,0x0738,
    0xffcf,0xee46,0xdcdd,0xcd54,0xb9eb,0xa862,0x9af9,0x8b70,
    0x8408,0x9581,0xa71a,0xb693,0xc22c,0xd3a5,0xe13e,0xf0b7,
    0x0840,0x19c9,0x2b52,0x3adb,0x4e64,0x5fed,0x6d76,0x7cff,
    0x9489,0x8500,0xb79b,0xa612,0xd2ad,0xc324,0xf1bf,0xe036,
    0x18c1,0x0948,0x3bd3,0x2a5a,0x5ee5,0x4f6c,0x7df7,0x6c7e,
    0xa50a,0xb483,0x8618,0x9791,0xe32e,0xf2a7,0xc03c,0xd1b5,
    0x2942,0x38cb,0x0a50,0x1bd9,0x6f66,0x7eef,0x4c74,0x5dfd,
    0xb58b,0xa402,0x9699,0x8710,0xf3af,0xe226,0xd0bd,0xc134,
    0x39c3,0x284a,0x1ad1,0x0b58,0x7fe7,0x6e6e,0x5cf5,0x4d7c,
    0xc60c,0xd785,0xe51e,0xf497,0x8028,0x91a1,0xa33a,0xb2b3,
    0x4a44,0x5bcd,0x6956,0x78df,0x0c60,0x1de9,0x2f72,0x3efb,
    0xd68d,0xc704,0xf59f,0xe416,0x90a9,0x8120,0xb3bb,0xa232,
    0x5ac5,0x4b4c,0x79d7,0x685e,0x1ce1,0x0d68,0x3ff3,0x2e7a,
    0xe70e,0xf687,0xc41c,0xd595,0xa12a,0xb0a3,0x8238,0x93b1,
    0x6b46,0x7acf,0x4854,0x59dd,0x2d62,0x3ceb,0x0e70,0x1ff9,
    0xf78f,0xe606,0xd49d,0xc514,0xb1ab,0xa022,0x92b9,0x8330,
    0x7bc7,0x6a4e,0x58d5,0x495c,0x3de3,0x2c6a,0x1ef1,0x0f78
};

#define PPPINITFCS16 0xffff     /* Initial FCS value */
#define PPPGOODFCS16 0xf0b8     /* Good final FCS value */

/*
* Calculate a new fcs given the current fcs and the new data.
*/
uint16 pppfcs16(uint16 fcs, uint8 *cp, uint16 len)
{
    while(len--)
    {
        fcs = (fcs >> 8) ^ g_fcstab[(fcs ^ *cp++) & 0xff];
    }
    return (fcs);
}

// 该函数内部已执行CRC字节的高低字节换序，该函数的返回值是已经调换的CRC。
const unsigned char auchCRCHi[] = 
{
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,  
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,  
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,  
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,  
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,  
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,  
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,  
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,  
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,  
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,  
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,  
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,  
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,  
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40  
} ;  

const char auchCRCLo[] = 
{
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,  
    0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,  
    0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,  
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,  
    0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,  
    0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,  
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,  
    0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,  
    0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,  
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,  
    0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,  
    0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,  
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,  
    0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,  
    0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,  
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,  
    0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,  
    0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,  
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,  
    0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,  
    0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,  
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,  
    0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,  
    0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,  
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,  
    0x43, 0x83, 0x41, 0x81, 0x80, 0x40  
};

/**********************************************************************
* @name      : CRC16
* @brief     ：求CRC16校验码
* @param[in] ：uint8*  pMsg       输入缓冲区
               uint16  len        帧长度
* @param[out]：
* @return    ：校验值
* @Create    : 
* @Date      ：2020-4-7
* @Update    :
**********************************************************************/
uint16 CRC16(uint8 *pMsg, uint16 len)
{
    uint8 uchCRCHi =0xff;     /*CRC高字节初始化*/
    uint8 uchCRCLo =0xff;     /*CRC低字节初始化*/
    uint8 uIndex ;            /*CRC循环索引*/
    
    while (len--)    /*传输消息缓冲区*/
    {
        uIndex = uchCRCHi ^ *pMsg++;    /*计算CRC*/
        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
        uchCRCLo = auchCRCLo[uIndex];
    }
    return (uchCRCHi << 8 | uchCRCLo);
}

/**********************************************************************
* @name      : mapmsg_memcpy_r
* @brief     ：倒序拷贝内存
* @param[in] ：void *dest        目的地址
               void *src         源地址
               int count         拷贝长度
* @param[out]：
* @return    ：目的地址
* @Create    : 
* @Date      ：2020-2-29
* @Update    :
**********************************************************************/
void *mapmsg_memcpy_r(void *dest, void *src, int count)
{
    void *ptr = dest;
    
    if(NULL == dest || NULL == src || count <= 0)  
    {   
        return NULL;    
    }
    
    while(count--)
    {
        *(char *)dest++ = *(char *)(src+count); 
    }

    return ptr;
}

/**********************************************************************
* @name      : mapmsg_get_len_offset
* @brief     ：获取串类型数据元素长度
* @param[in] ：const uint8 *indata      数据Buffer
* @param[out]：uint8 *bytes             便宜量
* @return    ：长度
* @Create    : 
* @Date      ：2020-2-28
* @Update    :
**********************************************************************/
uint16 mapmsg_get_len_offset(uint8 *indata,uint8 *bytes)
{
    uint16 EleNum;
    uint8 nbytes = 1;
    
    EleNum = indata[0];
    if(EleNum==0x81)
    {
        EleNum = indata[1];
        nbytes = 2;
    }
    else if(EleNum==0x82)
    {
        EleNum = indata[1];
        EleNum <<= 8;
        EleNum += indata[2];
        nbytes = 3;
    }
    else if(EleNum==0x80 || EleNum>0x82)
    {
        return 0;
    }
    
    if(bytes != NULL)
        *bytes = nbytes;
        
    return EleNum;
}

/**********************************************************************
* @name      : mapmsg_set_len_offset
* @brief     ：设置元素长度
* @param[in] ：const uint8 *indata      数据Buffer
* @param[out]：const uint8 *indata      数据Buffer
* @return    ：长度
* @Create    : 
* @Date      ：2020-2-28
* @Update    :
**********************************************************************/
uint8 mapmsg_set_len_offset(uint16 eleLen, uint8 *indata)
{
    if(eleLen < 0x80)
    {
        indata[0] = eleLen;
        return 1;
    }
    else if(eleLen <= 0xffff)
    {
        indata[0] = 0x82;
        indata[1] = (uint8)((eleLen >> 8) & 0xff);
        indata[2] = (uint8)(eleLen & 0xff);
        return 3;
    }
        
    return 0;
}

/**********************************************************************
* @name      : mapmsg_split
* @brief     ：接收消息解析成 MAPMSG_INFO_T
* @param[in] ：uint8 *pBuf              接受到的报文
               uint16 bufLen            报文长度
* @param[out]：MAPMSG_INFO_T **ppMsgOut 解析出来的消息
* @return    ：0-成功/错误码
* @Create    : 
* @Date      ：2020-1-3
* @Update    :
**********************************************************************/
int mapmsg_split(uint8 *pBuf, uint16 bufLen, MAPMSG_INFO_T **ppMsgOut)
{
    uint8  *pTemp = pBuf + 1;
    MAPMSG_INFO_T tMsgTemp;
    MAPMSG_INFO_T *ptNewMsg = NULL;
    uint16 trialfcs = 0;
    uint16 fcs = 0;
    
    if(NULL == pBuf || NULL == ppMsgOut || 0 == bufLen)
    {
        return -1;
    }

    memset(&tMsgTemp, 0, sizeof(MAPMSG_INFO_T));

    memcpy(&tMsgTemp.len, pTemp, sizeof(uint16));
    pTemp += sizeof(uint16);

    memcpy(&tMsgTemp.cmt, pTemp, sizeof(uint16));
    pTemp += sizeof(uint16);

    memcpy(&fcs, pTemp + tMsgTemp.len, sizeof(uint16));
    
    // 计算效验
    trialfcs = pppfcs16(PPPINITFCS16, pBuf + 1, 4 + tMsgTemp.len);
    trialfcs ^= PPPINITFCS16;
    if (fcs != trialfcs)
    {   
        return -2;
    }

    if(FRAMESTART != *pBuf || FRAMEEND != *(pTemp + tMsgTemp.len + 2))
    {
        return -3;
    }
    
    /* 拷贝 */
    ptNewMsg = (MAPMSG_INFO_T *)malloc(sizeof(MAPMSG_INFO_T) + tMsgTemp.len);
    if(NULL == ptNewMsg)
    {
        return -4;
    }
    
    memcpy(ptNewMsg, &tMsgTemp, sizeof(MAPMSG_INFO_T));
    if(tMsgTemp.len > 0)
    {
        memcpy(ptNewMsg->apdu, pTemp, tMsgTemp.len);
    }
    *ppMsgOut = ptNewMsg;

    return 0;
}

/**********************************************************************
* @name      : mapmsg_package
* @brief     ：指定格式消息组装成
* @param[in] ：MAPMSG_INFO_T *pMsgInfo  结构消息
               uint16 maxlen            消息最大长度
* @param[out]：uint8 *pMsgBuf           组装消息
* @return    ：消息长度
* @Create    : 
* @Date      ：2020-2-28
* @Update    :
**********************************************************************/
uint16 mapmsg_package(MAPMSG_INFO_T *pMsgInfo, uint8 *pMsgBuf, uint16 maxlen)
{
    uint16 bufLen = 0;
    uint16 offset = 0;
    uint16 trialfcs = 0;

    if(NULL == pMsgInfo || NULL == pMsgBuf || 0 == maxlen)
    {
        return 0;
    }

    /*       标志 + 长度域 + 控制域 + 数据域        + FCS + 标志*/
    bufLen = 1    + 2      + 2      + pMsgInfo->len + 2   + 1;
    if(maxlen < bufLen)
    {
        return 0;
    }

    memset(pMsgBuf, 0, bufLen);
    pMsgBuf[offset++] = FRAMESTART;

    memcpy(pMsgBuf + offset, &(pMsgInfo->len), sizeof(uint16));
    offset += sizeof(uint16);
    memcpy(pMsgBuf + offset, &(pMsgInfo->cmt.wcmd), sizeof(uint16));
    offset += sizeof(uint16);

    memcpy(pMsgBuf + offset, pMsgInfo->apdu, pMsgInfo->len);
    offset += pMsgInfo->len;

    trialfcs = pppfcs16(PPPINITFCS16, pMsgBuf + 1, 4 + pMsgInfo->len);
    trialfcs ^= PPPINITFCS16;

    memcpy(pMsgBuf + offset, &trialfcs, sizeof(uint16));
    offset += sizeof(uint16);

    pMsgBuf[offset] = FRAMEEND;

    return bufLen;
}



